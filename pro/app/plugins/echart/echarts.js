!function(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define([],factory):"object"==typeof exports?exports.echarts=factory():root.echarts=factory()}(this,function(){/******/
return function(modules){/******/
// The require function
/******/
function __webpack_require__(moduleId){/******/
// Check if module is in cache
/******/
if(installedModules[moduleId])/******/
return installedModules[moduleId].exports;/******/
// Create a new module (and put it into the cache)
/******/
var module=installedModules[moduleId]={/******/
exports:{},/******/
id:moduleId,/******/
loaded:!1};/******/
// Return the exports of the module
/******/
/******/
// Execute the module function
/******/
/******/
// Flag the module as loaded
/******/
return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.loaded=!0,module.exports}// webpackBootstrap
/******/
// The module cache
/******/
var installedModules={};/******/
// Load entry module and return exports
/******/
/******/
// expose the modules object (__webpack_modules__)
/******/
/******/
// expose the module cache
/******/
/******/
// __webpack_public_path__
/******/
return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.p="",__webpack_require__(0)}([/* 0 */
/***/
function(module,exports,__webpack_require__){/**
	 * Export echarts as CommonJS module
	 */
module.exports=__webpack_require__(1),
// Import all charts and components
__webpack_require__(91),__webpack_require__(127),__webpack_require__(132),__webpack_require__(141),__webpack_require__(145),__webpack_require__(155),__webpack_require__(177),__webpack_require__(189),__webpack_require__(207),__webpack_require__(211),__webpack_require__(215),__webpack_require__(230),__webpack_require__(236),__webpack_require__(243),__webpack_require__(249),__webpack_require__(253),__webpack_require__(258),__webpack_require__(106),__webpack_require__(262),__webpack_require__(268),__webpack_require__(272),__webpack_require__(283),__webpack_require__(216),__webpack_require__(285),__webpack_require__(286),__webpack_require__(300),__webpack_require__(315),__webpack_require__(319),__webpack_require__(322),__webpack_require__(331),__webpack_require__(345)},/* 1 */
/***/
function(module,exports,__webpack_require__){function createRegisterEventWithLowercaseName(method){return function(eventName,handler,context){eventName=eventName&&eventName.toLowerCase(),Eventful.prototype[method].call(this,eventName,handler,context)}}/**
	     * @module echarts~MessageCenter
	     */
function MessageCenter(){Eventful.call(this)}/**
	     * @module echarts~ECharts
	     */
function ECharts(dom,theme,opts){opts=opts||{},"string"==typeof theme&&(theme=themeStorage[theme]),theme&&each(optionPreprocessorFuncs,function(preProcess){preProcess(theme)}),this.id,this.group,this._dom=dom,this._zr=zrender.init(dom,{renderer:opts.renderer||"canvas",devicePixelRatio:opts.devicePixelRatio}),this._theme=zrUtil.clone(theme),this._chartsViews=[],this._chartsMap={},this._componentsViews=[],this._componentsMap={},this._api=new ExtensionAPI(this),this._coordSysMgr=new CoordinateSystemManager,Eventful.call(this),this._messageCenter=new MessageCenter,this._initEvents(),this.resize=zrUtil.bind(this.resize,this)}/**
	     * @param {Object} payload
	     * @private
	     */
function toggleHighlight(method,payload){var ecModel=this._model;
// dispatchAction before setOption
ecModel&&ecModel.eachComponent({mainType:"series",query:payload},function(seriesModel,index){var chartView=this._chartsMap[seriesModel.__viewId];chartView&&chartView.__alive&&chartView[method](seriesModel,ecModel,this._api,payload)},this)}/**
	     * @param {string} methodName
	     * @private
	     */
function invokeUpdateMethod(methodName,ecModel,payload){var api=this._api;
// Update all components
each(this._componentsViews,function(component){var componentModel=component.__model;component[methodName](componentModel,ecModel,api,payload),updateZ(componentModel,component)},this),
// Upate all charts
ecModel.eachSeries(function(seriesModel,idx){var chart=this._chartsMap[seriesModel.__viewId];chart[methodName](seriesModel,ecModel,api,payload),updateZ(seriesModel,chart)},this)}/**
	     * Prepare view instances of charts and components
	     * @param  {module:echarts/model/Global} ecModel
	     * @private
	     */
function prepareView(type,ecModel){for(var isComponent="component"===type,viewList=isComponent?this._componentsViews:this._chartsViews,viewMap=isComponent?this._componentsMap:this._chartsMap,zr=this._zr,i=0;i<viewList.length;i++)viewList[i].__alive=!1;ecModel[isComponent?"eachComponent":"eachSeries"](function(componentType,model){if(isComponent){if("series"===componentType)return}else model=componentType;
// Consider: id same and type changed.
var viewId=model.id+"_"+model.type,view=viewMap[viewId];if(!view){var classType=ComponentModel.parseClassType(model.type),Clazz=isComponent?ComponentView.getClass(classType.main,classType.sub):ChartView.getClass(classType.sub);if(!Clazz)
// Error
return;view=new Clazz,view.init(ecModel,this._api),viewMap[viewId]=view,viewList.push(view),zr.add(view.group)}model.__viewId=viewId,view.__alive=!0,view.__id=viewId,view.__model=model},this);for(var i=0;i<viewList.length;){var view=viewList[i];view.__alive?i++:(zr.remove(view.group),view.dispose(ecModel,this._api),viewList.splice(i,1),delete viewMap[view.__id])}}/**
	     * Processor data in each series
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
function processData(ecModel,api){each(PROCESSOR_STAGES,function(stage){each(dataProcessorFuncs[stage]||[],function(process){process(ecModel,api)})})}/**
	     * @private
	     */
function stackSeriesData(ecModel){var stackedDataMap={};ecModel.eachSeries(function(series){var stack=series.get("stack"),data=series.getData();if(stack&&"list"===data.type){var previousStack=stackedDataMap[stack];previousStack&&(data.stackedOn=previousStack),stackedDataMap[stack]=data}})}/**
	     * Layout before each chart render there series, after visual coding and data processing
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
function doLayout(ecModel,payload){var api=this._api;each(layoutFuncs,function(layout){layout(ecModel,api,payload)})}/**
	     * Code visual infomation from data after data processing
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
function doVisualCoding(ecModel,payload){each(VISUAL_CODING_STAGES,function(stage){each(visualCodingFuncs[stage]||[],function(visualCoding){visualCoding(ecModel,payload)})})}/**
	     * Render each chart and component
	     * @private
	     */
function doRender(ecModel,payload){var api=this._api;
// Render all components
each(this._componentsViews,function(componentView){var componentModel=componentView.__model;componentView.render(componentModel,ecModel,api,payload),updateZ(componentModel,componentView)},this),each(this._chartsViews,function(chart){chart.__alive=!1},this),
// Render all charts
ecModel.eachSeries(function(seriesModel,idx){var chartView=this._chartsMap[seriesModel.__viewId];chartView.__alive=!0,chartView.render(seriesModel,ecModel,api,payload),chartView.group.silent=!!seriesModel.get("silent"),updateZ(seriesModel,chartView)},this),
// Remove groups of unrendered charts
each(this._chartsViews,function(chart){chart.__alive||chart.remove(ecModel,api)},this)}/**
	     * @param {module:echarts/model/Series|module:echarts/model/Component} model
	     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
	     * @return {string}
	     */
function updateZ(model,view){var z=model.get("z"),zlevel=model.get("zlevel");
// Set z and zlevel
view.group.traverse(function(el){null!=z&&(el.z=z),null!=zlevel&&(el.zlevel=zlevel)})}function enableConnect(chart){function updateConnectedChartsStatus(charts,status){for(var i=0;i<charts.length;i++){var otherChart=charts[i];otherChart[STATUS_KEY]=status}}var STATUS_PENDING=0,STATUS_UPDATING=1,STATUS_UPDATED=2,STATUS_KEY="__connectUpdateStatus";zrUtil.each(eventActionMap,function(actionType,eventType){chart._messageCenter.on(eventType,function(event){if(connectedGroups[chart.group]&&chart[STATUS_KEY]!==STATUS_PENDING){var action=chart.makeActionFromEvent(event),otherCharts=[];for(var id in instances){var otherChart=instances[id];otherChart!==chart&&otherChart.group===chart.group&&otherCharts.push(otherChart)}updateConnectedChartsStatus(otherCharts,STATUS_PENDING),each(otherCharts,function(otherChart){otherChart[STATUS_KEY]!==STATUS_UPDATING&&otherChart.dispatchAction(action)}),updateConnectedChartsStatus(otherCharts,STATUS_UPDATED)}})})}/*!
	 * ECharts, a javascript interactive chart library.
	 *
	 * Copyright (c) 2015, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	 */
/**
	 * @module echarts
	 */
var GlobalModel=__webpack_require__(2),ExtensionAPI=__webpack_require__(24),CoordinateSystemManager=__webpack_require__(25),OptionManager=__webpack_require__(26),ComponentModel=__webpack_require__(19),SeriesModel=__webpack_require__(27),ComponentView=__webpack_require__(28),ChartView=__webpack_require__(41),graphic=__webpack_require__(42),zrender=__webpack_require__(77),zrUtil=__webpack_require__(3),colorTool=__webpack_require__(38),env=__webpack_require__(78),Eventful=__webpack_require__(32),each=zrUtil.each,VISUAL_CODING_STAGES=["echarts","chart","component"],PROCESSOR_STAGES=["transform","filter","statistic"];MessageCenter.prototype.on=createRegisterEventWithLowercaseName("on"),MessageCenter.prototype.off=createRegisterEventWithLowercaseName("off"),MessageCenter.prototype.one=createRegisterEventWithLowercaseName("one"),zrUtil.mixin(MessageCenter,Eventful);var echartsProto=ECharts.prototype;/**
	     * @return {HTMLDomElement}
	     */
echartsProto.getDom=function(){return this._dom},/**
	     * @return {module:zrender~ZRender}
	     */
echartsProto.getZr=function(){return this._zr},/**
	     * @param {Object} option
	     * @param {boolean} notMerge
	     * @param {boolean} [notRefreshImmediately=false] Useful when setOption frequently.
	     */
echartsProto.setOption=function(option,notMerge,notRefreshImmediately){this._model&&!notMerge||(this._model=new GlobalModel(null,null,this._theme,new OptionManager(this._api))),this._model.setOption(option,optionPreprocessorFuncs),updateMethods.prepareAndUpdate.call(this),!notRefreshImmediately&&this._zr.refreshImmediately()},/**
	     * @DEPRECATED
	     */
echartsProto.setTheme=function(){console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")},/**
	     * @return {module:echarts/model/Global}
	     */
echartsProto.getModel=function(){return this._model},/**
	     * @return {Object}
	     */
echartsProto.getOption=function(){return this._model.getOption()},/**
	     * @return {number}
	     */
echartsProto.getWidth=function(){return this._zr.getWidth()},/**
	     * @return {number}
	     */
echartsProto.getHeight=function(){return this._zr.getHeight()},/**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
echartsProto.getRenderedCanvas=function(opts){if(env.canvasSupported){opts=opts||{},opts.pixelRatio=opts.pixelRatio||1,opts.backgroundColor=opts.backgroundColor||this._model.get("backgroundColor");var zr=this._zr,list=zr.storage.getDisplayList();
// Stop animations
return zrUtil.each(list,function(el){el.stopAnimation(!0)}),zr.painter.getRenderedCanvas(opts)}},/**
	     * @return {string}
	     * @param {Object} opts
	     * @param {string} [opts.type='png']
	     * @param {string} [opts.pixelRatio=1]
	     * @param {string} [opts.backgroundColor]
	     */
echartsProto.getDataURL=function(opts){opts=opts||{};var excludeComponents=opts.excludeComponents,ecModel=this._model,excludesComponentViews=[],self=this;each(excludeComponents,function(componentType){ecModel.eachComponent({mainType:componentType},function(component){var view=self._componentsMap[component.__viewId];view.group.ignore||(excludesComponentViews.push(view),view.group.ignore=!0)})});var url=this.getRenderedCanvas(opts).toDataURL("image/"+(opts&&opts.type||"png"));return each(excludesComponentViews,function(view){view.group.ignore=!1}),url},/**
	     * @return {string}
	     * @param {Object} opts
	     * @param {string} [opts.type='png']
	     * @param {string} [opts.pixelRatio=1]
	     * @param {string} [opts.backgroundColor]
	     */
echartsProto.getConnectedDataURL=function(opts){if(env.canvasSupported){var groupId=this.group,mathMin=Math.min,mathMax=Math.max,MAX_NUMBER=1/0;if(connectedGroups[groupId]){var left=MAX_NUMBER,top=MAX_NUMBER,right=-MAX_NUMBER,bottom=-MAX_NUMBER,canvasList=[],dpr=opts&&opts.pixelRatio||1;for(var id in instances){var chart=instances[id];if(chart.group===groupId){var canvas=chart.getRenderedCanvas(zrUtil.clone(opts)),boundingRect=chart.getDom().getBoundingClientRect();left=mathMin(boundingRect.left,left),top=mathMin(boundingRect.top,top),right=mathMax(boundingRect.right,right),bottom=mathMax(boundingRect.bottom,bottom),canvasList.push({dom:canvas,left:boundingRect.left,top:boundingRect.top})}}left*=dpr,top*=dpr,right*=dpr,bottom*=dpr;var width=right-left,height=bottom-top,targetCanvas=zrUtil.createCanvas();targetCanvas.width=width,targetCanvas.height=height;var zr=zrender.init(targetCanvas);return each(canvasList,function(item){var img=new graphic.Image({style:{x:item.left*dpr-left,y:item.top*dpr-top,image:item.dom}});zr.add(img)}),zr.refreshImmediately(),targetCanvas.toDataURL("image/"+(opts&&opts.type||"png"))}return this.getDataURL(opts)}};var updateMethods={/**
	         * @param {Object} payload
	         * @private
	         */
update:function(payload){
// console.time && console.time('update');
var ecModel=this._model,api=this._api,coordSysMgr=this._coordSysMgr;
// update before setOption
if(ecModel){ecModel.restoreData(),
// TODO
// Save total ecModel here for undo/redo (after restoring data and before processing data).
// Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
// Create new coordinate system each update
// In LineView may save the old coordinate system and use it to get the orignal point
coordSysMgr.create(this._model,this._api),processData.call(this,ecModel,api),stackSeriesData.call(this,ecModel),coordSysMgr.update(ecModel,api),doLayout.call(this,ecModel,payload),doVisualCoding.call(this,ecModel,payload),doRender.call(this,ecModel,payload);
// Set background
var backgroundColor=ecModel.get("backgroundColor")||"transparent",painter=this._zr.painter;
// TODO all use clearColor ?
if(painter.isSingleCanvas&&painter.isSingleCanvas())this._zr.configLayer(0,{clearColor:backgroundColor});else{
// In IE8
if(!env.canvasSupported){var colorArr=colorTool.parse(backgroundColor);backgroundColor=colorTool.stringify(colorArr,"rgb"),0===colorArr[3]&&(backgroundColor="transparent")}backgroundColor=backgroundColor,this._dom.style.backgroundColor=backgroundColor}}},
// PENDING
/**
	         * @param {Object} payload
	         * @private
	         */
updateView:function(payload){var ecModel=this._model;
// update before setOption
ecModel&&(doLayout.call(this,ecModel,payload),doVisualCoding.call(this,ecModel,payload),invokeUpdateMethod.call(this,"updateView",ecModel,payload))},/**
	         * @param {Object} payload
	         * @private
	         */
updateVisual:function(payload){var ecModel=this._model;
// update before setOption
ecModel&&(doVisualCoding.call(this,ecModel,payload),invokeUpdateMethod.call(this,"updateVisual",ecModel,payload))},/**
	         * @param {Object} payload
	         * @private
	         */
updateLayout:function(payload){var ecModel=this._model;
// update before setOption
ecModel&&(doLayout.call(this,ecModel,payload),invokeUpdateMethod.call(this,"updateLayout",ecModel,payload))},/**
	         * @param {Object} payload
	         * @private
	         */
highlight:function(payload){toggleHighlight.call(this,"highlight",payload)},/**
	         * @param {Object} payload
	         * @private
	         */
downplay:function(payload){toggleHighlight.call(this,"downplay",payload)},/**
	         * @param {Object} payload
	         * @private
	         */
prepareAndUpdate:function(payload){var ecModel=this._model;prepareView.call(this,"component",ecModel),prepareView.call(this,"chart",ecModel),updateMethods.update.call(this,payload)}};/**
	     * Resize the chart
	     */
echartsProto.resize=function(){this._zr.resize();var optionChanged=this._model&&this._model.resetOption("media");updateMethods[optionChanged?"prepareAndUpdate":"update"].call(this),
// Resize loading effect
this._loadingFX&&this._loadingFX.resize()};var defaultLoadingEffect=__webpack_require__(87);/**
	     * Show loading effect
	     * @param  {string} [name='default']
	     * @param  {Object} [cfg]
	     */
echartsProto.showLoading=function(name,cfg){zrUtil.isObject(name)&&(cfg=name,name="default"),this.hideLoading();var el=defaultLoadingEffect(this._api,cfg),zr=this._zr;this._loadingFX=el,zr.add(el)},/**
	     * Hide loading effect
	     */
echartsProto.hideLoading=function(){this._loadingFX&&this._zr.remove(this._loadingFX),this._loadingFX=null},/**
	     * @param {Object} eventObj
	     * @return {Object}
	     */
echartsProto.makeActionFromEvent=function(eventObj){var payload=zrUtil.extend({},eventObj);return payload.type=eventActionMap[eventObj.type],payload},/**
	     * @pubilc
	     * @param {Object} payload
	     * @param {string} [payload.type] Action type
	     * @param {boolean} [silent=false] Whether trigger event.
	     */
echartsProto.dispatchAction=function(payload,silent){var actionWrap=actions[payload.type];if(actionWrap){var actionInfo=actionWrap.actionInfo,updateMethod=actionInfo.update||"update",payloads=[payload],batched=!1;
// Batch action
payload.batch&&(batched=!0,payloads=zrUtil.map(payload.batch,function(item){return item=zrUtil.defaults(zrUtil.extend({},item),payload),item.batch=null,item}));for(var eventObj,eventObjBatch=[],isHighlightOrDownplay="highlight"===payload.type||"downplay"===payload.type,i=0;i<payloads.length;i++){var batchItem=payloads[i];
// Action can specify the event by return it.
eventObj=actionWrap.action(batchItem,this._model),
// Emit event outside
eventObj=eventObj||zrUtil.extend({},batchItem),
// Convert type to eventType
eventObj.type=actionInfo.event||eventObj.type,eventObjBatch.push(eventObj),
// Highlight and downplay are special.
isHighlightOrDownplay&&updateMethods[updateMethod].call(this,batchItem)}"none"!==updateMethod&&!isHighlightOrDownplay&&updateMethods[updateMethod].call(this,payload),silent||(
// Follow the rule of action batch
eventObj=batched?{type:actionInfo.event||payload.type,batch:eventObjBatch}:eventObjBatch[0],this._messageCenter.trigger(eventObj.type,eventObj))}},/**
	     * Register event
	     * @method
	     */
echartsProto.on=createRegisterEventWithLowercaseName("on"),echartsProto.off=createRegisterEventWithLowercaseName("off"),echartsProto.one=createRegisterEventWithLowercaseName("one");var MOUSE_EVENT_NAMES=["click","dblclick","mouseover","mouseout","mousedown","mouseup","globalout"];/**
	     * @private
	     */
echartsProto._initEvents=function(){var zr=this._zr;each(MOUSE_EVENT_NAMES,function(eveName){zr.on(eveName,function(e){var ecModel=this.getModel(),el=e.target;if(el&&null!=el.dataIndex){var dataModel=el.dataModel||ecModel.getSeriesByIndex(el.seriesIndex),params=dataModel&&dataModel.getDataParams(el.dataIndex)||{};params.event=e,params.type=eveName,this.trigger(eveName,params)}else el&&el.eventData&&this.trigger(eveName,el.eventData)},this)},this),each(eventActionMap,function(actionType,eventType){this._messageCenter.on(eventType,function(event){this.trigger(eventType,event)},this)},this)},/**
	     * @return {boolean}
	     */
echartsProto.isDisposed=function(){return this._disposed},/**
	     * Clear
	     */
echartsProto.clear=function(){this.setOption({},!0)},/**
	     * Dispose instance
	     */
echartsProto.dispose=function(){this._disposed=!0;var api=this._api,ecModel=this._model;each(this._componentsViews,function(component){component.dispose(ecModel,api)}),each(this._chartsViews,function(chart){chart.dispose(ecModel,api)}),this._zr.dispose(),delete instances[this.id]},zrUtil.mixin(ECharts,Eventful);/**
	     * @type {Array.<Function>}
	     * @inner
	     */
var actions=[],eventActionMap={},layoutFuncs=[],dataProcessorFuncs={},optionPreprocessorFuncs=[],visualCodingFuncs={},themeStorage={},instances={},connectedGroups={},idBase=new Date-0,groupIdBase=new Date-0,DOM_ATTRIBUTE_KEY="_echarts_instance_",echarts={/**
	         * @type {number}
	         */
version:"3.1.7",dependencies:{zrender:"3.0.8"}};/**
	     * @param {HTMLDomElement} dom
	     * @param {Object} [theme]
	     * @param {Object} opts
	     */
echarts.init=function(dom,theme,opts){
// Check version
if(zrender.version.replace(".","")-0<echarts.dependencies.zrender.replace(".","")-0)throw new Error("ZRender "+zrender.version+" is too old for ECharts "+echarts.version+". Current version need ZRender "+echarts.dependencies.zrender+"+");if(!dom)throw new Error("Initialize failed: invalid dom.");var chart=new ECharts(dom,theme,opts);return chart.id="ec_"+idBase++,instances[chart.id]=chart,dom.setAttribute&&dom.setAttribute(DOM_ATTRIBUTE_KEY,chart.id),enableConnect(chart),chart},/**
	     * @return {string|Array.<module:echarts~ECharts>} groupId
	     */
echarts.connect=function(groupId){
// Is array of charts
if(zrUtil.isArray(groupId)){var charts=groupId;groupId=null,
// If any chart has group
zrUtil.each(charts,function(chart){null!=chart.group&&(groupId=chart.group)}),groupId=groupId||"g_"+groupIdBase++,zrUtil.each(charts,function(chart){chart.group=groupId})}return connectedGroups[groupId]=!0,groupId},/**
	     * @return {string} groupId
	     */
echarts.disConnect=function(groupId){connectedGroups[groupId]=!1},/**
	     * Dispose a chart instance
	     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
	     */
echarts.dispose=function(chart){zrUtil.isDom(chart)?chart=echarts.getInstanceByDom(chart):"string"==typeof chart&&(chart=instances[chart]),chart instanceof ECharts&&!chart.isDisposed()&&chart.dispose()},/**
	     * @param  {HTMLDomElement} dom
	     * @return {echarts~ECharts}
	     */
echarts.getInstanceByDom=function(dom){var key=dom.getAttribute(DOM_ATTRIBUTE_KEY);return instances[key]},/**
	     * @param {string} key
	     * @return {echarts~ECharts}
	     */
echarts.getInstanceById=function(key){return instances[key]},/**
	     * Register theme
	     */
echarts.registerTheme=function(name,theme){themeStorage[name]=theme},/**
	     * Register option preprocessor
	     * @param {Function} preprocessorFunc
	     */
echarts.registerPreprocessor=function(preprocessorFunc){optionPreprocessorFuncs.push(preprocessorFunc)},/**
	     * @param {string} stage
	     * @param {Function} processorFunc
	     */
echarts.registerProcessor=function(stage,processorFunc){if(zrUtil.indexOf(PROCESSOR_STAGES,stage)<0)throw new Error("stage should be one of "+PROCESSOR_STAGES);var funcs=dataProcessorFuncs[stage]||(dataProcessorFuncs[stage]=[]);funcs.push(processorFunc)},/**
	     * Usage:
	     * registerAction('someAction', 'someEvent', function () { ... });
	     * registerAction('someAction', function () { ... });
	     * registerAction(
	     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
	     *     function () { ... }
	     * );
	     *
	     * @param {(string|Object)} actionInfo
	     * @param {string} actionInfo.type
	     * @param {string} [actionInfo.event]
	     * @param {string} [actionInfo.update]
	     * @param {string} [eventName]
	     * @param {Function} action
	     */
echarts.registerAction=function(actionInfo,eventName,action){"function"==typeof eventName&&(action=eventName,eventName="");var actionType=zrUtil.isObject(actionInfo)?actionInfo.type:[actionInfo,actionInfo={event:eventName}][0];
// Event name is all lowercase
actionInfo.event=(actionInfo.event||actionType).toLowerCase(),eventName=actionInfo.event,actions[actionType]||(actions[actionType]={action:action,actionInfo:actionInfo}),eventActionMap[eventName]=actionType},/**
	     * @param {string} type
	     * @param {*} CoordinateSystem
	     */
echarts.registerCoordinateSystem=function(type,CoordinateSystem){CoordinateSystemManager.register(type,CoordinateSystem)},/**
	     * @param {*} layout
	     */
echarts.registerLayout=function(layout){
// PENDING All functions ?
zrUtil.indexOf(layoutFuncs,layout)<0&&layoutFuncs.push(layout)},/**
	     * @param {string} stage
	     * @param {Function} visualCodingFunc
	     */
echarts.registerVisualCoding=function(stage,visualCodingFunc){if(zrUtil.indexOf(VISUAL_CODING_STAGES,stage)<0)throw new Error("stage should be one of "+VISUAL_CODING_STAGES);var funcs=visualCodingFuncs[stage]||(visualCodingFuncs[stage]=[]);funcs.push(visualCodingFunc)},/**
	     * @param {Object} opts
	     */
echarts.extendChartView=function(opts){return ChartView.extend(opts)},/**
	     * @param {Object} opts
	     */
echarts.extendComponentModel=function(opts){return ComponentModel.extend(opts)},/**
	     * @param {Object} opts
	     */
echarts.extendSeriesModel=function(opts){return SeriesModel.extend(opts)},/**
	     * @param {Object} opts
	     */
echarts.extendComponentView=function(opts){return ComponentView.extend(opts)},/**
	     * ZRender need a canvas context to do measureText.
	     * But in node environment canvas may be created by node-canvas.
	     * So we need to specify how to create a canvas instead of using document.createElement('canvas')
	     *
	     * Be careful of using it in the browser.
	     *
	     * @param {Function} creator
	     * @example
	     *     var Canvas = require('canvas');
	     *     var echarts = require('echarts');
	     *     echarts.setCanvasCreator(function () {
	     *         // Small size is enough.
	     *         return new Canvas(32, 32);
	     *     });
	     */
echarts.setCanvasCreator=function(creator){zrUtil.createCanvas=creator},echarts.registerVisualCoding("echarts",zrUtil.curry(__webpack_require__(88),"","itemStyle")),echarts.registerPreprocessor(__webpack_require__(89)),
// Default action
echarts.registerAction({type:"highlight",event:"highlight",update:"highlight"},zrUtil.noop),echarts.registerAction({type:"downplay",event:"downplay",update:"downplay"},zrUtil.noop),
// --------
// Exports
// --------
echarts.graphic=__webpack_require__(42),echarts.number=__webpack_require__(7),echarts.format=__webpack_require__(6),echarts.matrix=__webpack_require__(17),echarts.vector=__webpack_require__(16),echarts.util={},each(["map","each","filter","indexOf","inherits","reduce","filter","bind","curry","isArray","isString","isObject","isFunction","extend"],function(name){echarts.util[name]=zrUtil[name]}),module.exports=echarts},/* 2 */
/***/
function(module,exports,__webpack_require__){/**
	     * @inner
	     */
function mergeTheme(option,theme){for(var name in theme)
// 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
ComponentModel.hasClass(name)||("object"==typeof theme[name]?option[name]=option[name]?zrUtil.merge(option[name],theme[name],!1):zrUtil.clone(theme[name]):null==option[name]&&(option[name]=theme[name]))}function initBase(baseOption){baseOption=baseOption,this.option={},this.option[OPTION_INNER_KEY]=1,this._componentsMap={},this._seriesIndices=null,mergeTheme(baseOption,this._theme.option),zrUtil.merge(baseOption,globalDefault,!1),this.mergeOption(baseOption)}/**
	     * @inner
	     * @param {Array.<string>|string} types model types
	     * @return {Object} key: {string} type, value: {Array.<Object>} models
	     */
function getComponentsByTypes(componentsMap,types){zrUtil.isArray(types)||(types=types?[types]:[]);var ret={};return each(types,function(type){ret[type]=(componentsMap[type]||[]).slice()}),ret}/**
	     * @inner
	     */
function makeKeyInfo(mainType,mapResult){
// We use this id to hash component models and view instances
// in echarts. id can be specified by user, or auto generated.
// The id generation rule ensures new view instance are able
// to mapped to old instance when setOption are called in
// no-merge mode. So we generate model id by name and plus
// type in view id.
// name can be duplicated among components, which is convenient
// to specify multi components (like series) by one name.
// Ensure that each id is distinct.
var idMap={};each(mapResult,function(item,index){var existCpt=item.exist;existCpt&&(idMap[existCpt.id]=item)}),each(mapResult,function(item,index){var opt=item.option;
// Complete subType
if(zrUtil.assert(!opt||null==opt.id||!idMap[opt.id]||idMap[opt.id]===item,"id duplicates: "+(opt&&opt.id)),opt&&null!=opt.id&&(idMap[opt.id]=item),isObject(opt)){var subType=determineSubType(mainType,opt,item.exist);item.keyInfo={mainType:mainType,subType:subType}}}),
// Make name and id.
each(mapResult,function(item,index){var existCpt=item.exist,opt=item.option,keyInfo=item.keyInfo;if(isObject(opt)){if(
// name can be overwitten. Consider case: axis.name = '20km'.
// But id generated by name will not be changed, which affect
// only in that case: setOption with 'not merge mode' and view
// instance will be recreated, which can be accepted.
keyInfo.name=null!=opt.name?opt.name+"":existCpt?existCpt.name:"\x00-",existCpt)keyInfo.id=existCpt.id;else if(null!=opt.id)keyInfo.id=opt.id+"";else{
// Consider this situatoin:
//  optionA: [{name: 'a'}, {name: 'a'}, {..}]
//  optionB [{..}, {name: 'a'}, {name: 'a'}]
// Series with the same name between optionA and optionB
// should be mapped.
var idNum=0;do keyInfo.id="\x00"+keyInfo.name+"\x00"+idNum++;while(idMap[keyInfo.id])}idMap[keyInfo.id]=item}})}/**
	     * @inner
	     */
function determineSubType(mainType,newCptOption,existComponent){var subType=newCptOption.type?newCptOption.type:existComponent?existComponent.subType:ComponentModel.determineSubType(mainType,newCptOption);
// tooltip, markline, markpoint may always has no subType
return subType}/**
	     * @inner
	     */
function createSeriesIndices(seriesModels){return map(seriesModels,function(series){return series.componentIndex})||[]}/**
	     * @inner
	     */
function filterBySubType(components,condition){
// Using hasOwnProperty for restrict. Consider
// subType is undefined in user payload.
return condition.hasOwnProperty("subType")?filter(components,function(cpt){return cpt.subType===condition.subType}):components}/**
	     * @inner
	     */
function assertSeriesInitialized(ecModel){
// Components that use _seriesIndices should depends on series component,
// which make sure that their initialization is after series.
if(!ecModel._seriesIndices)throw new Error("Series has not been initialized yet.")}/**
	 * ECharts global model
	 *
	 * @module {echarts/model/Global}
	 *
	 */
var zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),Model=__webpack_require__(8),each=zrUtil.each,filter=zrUtil.filter,map=zrUtil.map,isArray=zrUtil.isArray,indexOf=zrUtil.indexOf,isObject=zrUtil.isObject,ComponentModel=__webpack_require__(19),globalDefault=__webpack_require__(23),OPTION_INNER_KEY="\x00_ec_inner",GlobalModel=Model.extend({constructor:GlobalModel,init:function(option,parentModel,theme,optionManager){theme=theme||{},this.option=null,this._theme=new Model(theme),this._optionManager=optionManager},setOption:function(option,optionPreprocessorFuncs){zrUtil.assert(!(OPTION_INNER_KEY in option),"please use chart.getOption()"),this._optionManager.setOption(option,optionPreprocessorFuncs),this.resetOption()},/**
	         * @param {string} type null/undefined: reset all.
	         *                      'recreate': force recreate all.
	         *                      'timeline': only reset timeline option
	         *                      'media': only reset media query option
	         * @return {boolean} Whether option changed.
	         */
resetOption:function(type){var optionChanged=!1,optionManager=this._optionManager;if(!type||"recreate"===type){var baseOption=optionManager.mountOption("recreate"===type);this.option&&"recreate"!==type?(this.restoreData(),this.mergeOption(baseOption)):initBase.call(this,baseOption),optionChanged=!0}if("timeline"!==type&&"media"!==type||this.restoreData(),!type||"recreate"===type||"timeline"===type){var timelineOption=optionManager.getTimelineOption(this);timelineOption&&(this.mergeOption(timelineOption),optionChanged=!0)}if(!type||"recreate"===type||"media"===type){var mediaOptions=optionManager.getMediaOption(this,this._api);mediaOptions.length&&each(mediaOptions,function(mediaOption){this.mergeOption(mediaOption,optionChanged=!0)},this)}return optionChanged},/**
	         * @protected
	         */
mergeOption:function(newOption){function visitComponent(mainType,dependencies){var newCptOptionList=modelUtil.normalizeToArray(newOption[mainType]),mapResult=modelUtil.mappingToExists(componentsMap[mainType],newCptOptionList);makeKeyInfo(mainType,mapResult);var dependentModels=getComponentsByTypes(componentsMap,dependencies);option[mainType]=[],componentsMap[mainType]=[],each(mapResult,function(resultItem,index){var componentModel=resultItem.exist,newCptOption=resultItem.option;
// Consider where is no new option and should be merged using {},
// see removeEdgeAndAdd in topologicalTravel and
// ComponentModel.getAllClassMainTypes.
if(zrUtil.assert(isObject(newCptOption)||componentModel,"Empty component definition"),newCptOption){var ComponentModelClass=ComponentModel.getClass(mainType,resultItem.keyInfo.subType,!0);componentModel&&componentModel instanceof ComponentModelClass?(componentModel.mergeOption(newCptOption,this),componentModel.optionUpdated(this)):(componentModel=new ComponentModelClass(newCptOption,this,this,zrUtil.extend({dependentModels:dependentModels,componentIndex:index},resultItem.keyInfo)),componentModel.optionUpdated(this))}else componentModel.mergeOption({},this),componentModel.optionUpdated(this);componentsMap[mainType][index]=componentModel,option[mainType][index]=componentModel.option},this),
// Backup series for filtering.
"series"===mainType&&(this._seriesIndices=createSeriesIndices(componentsMap.series))}var option=this.option,componentsMap=this._componentsMap,newCptTypes=[];
// 如果不存在对应的 component model 则直接 merge
each(newOption,function(componentOption,mainType){null!=componentOption&&(ComponentModel.hasClass(mainType)?newCptTypes.push(mainType):option[mainType]=null==option[mainType]?zrUtil.clone(componentOption):zrUtil.merge(option[mainType],componentOption,!0))}),
// FIXME OPTION 同步是否要改回原来的
ComponentModel.topologicalTravel(newCptTypes,ComponentModel.getAllClassMainTypes(),visitComponent,this)},/**
	         * Get option for output (cloned option and inner info removed)
	         * @public
	         * @return {Object}
	         */
getOption:function(){var option=zrUtil.clone(this.option);return each(option,function(opts,mainType){if(ComponentModel.hasClass(mainType)){for(var opts=modelUtil.normalizeToArray(opts),i=opts.length-1;i>=0;i--)
// Remove options with inner id.
modelUtil.isIdInner(opts[i])&&opts.splice(i,1);option[mainType]=opts}}),delete option[OPTION_INNER_KEY],option},/**
	         * @return {module:echarts/model/Model}
	         */
getTheme:function(){return this._theme},/**
	         * @param {string} mainType
	         * @param {number} [idx=0]
	         * @return {module:echarts/model/Component}
	         */
getComponent:function(mainType,idx){var list=this._componentsMap[mainType];return list?list[idx||0]:void 0},/**
	         * @param {Object} condition
	         * @param {string} condition.mainType
	         * @param {string} [condition.subType] If ignore, only query by mainType
	         * @param {number} [condition.index] Either input index or id or name.
	         * @param {string} [condition.id] Either input index or id or name.
	         * @param {string} [condition.name] Either input index or id or name.
	         * @return {Array.<module:echarts/model/Component>}
	         */
queryComponents:function(condition){var mainType=condition.mainType;if(!mainType)return[];var index=condition.index,id=condition.id,name=condition.name,cpts=this._componentsMap[mainType];if(!cpts||!cpts.length)return[];var result;if(null!=index)isArray(index)||(index=[index]),result=filter(map(index,function(idx){return cpts[idx]}),function(val){return!!val});else if(null!=id){var isIdArray=isArray(id);result=filter(cpts,function(cpt){return isIdArray&&indexOf(id,cpt.id)>=0||!isIdArray&&cpt.id===id})}else if(null!=name){var isNameArray=isArray(name);result=filter(cpts,function(cpt){return isNameArray&&indexOf(name,cpt.name)>=0||!isNameArray&&cpt.name===name})}return filterBySubType(result,condition)},/**
	         * The interface is different from queryComponents,
	         * which is convenient for inner usage.
	         *
	         * @usage
	         * var result = findComponents(
	         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
	         * );
	         * var result = findComponents(
	         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
	         * );
	         * var result = findComponents(
	         *     {mainType: 'series'},
	         *     function (model, index) {...}
	         * );
	         * // result like [component0, componnet1, ...]
	         *
	         * @param {Object} condition
	         * @param {string} condition.mainType Mandatory.
	         * @param {string} [condition.subType] Optional.
	         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
	         *        where xxx is mainType.
	         *        If query attribute is null/undefined or has no index/id/name,
	         *        do not filtering by query conditions, which is convenient for
	         *        no-payload situations or when target of action is global.
	         * @param {Function} [condition.filter] parameter: component, return boolean.
	         * @return {Array.<module:echarts/model/Component>}
	         */
findComponents:function(condition){function getQueryCond(q){var indexAttr=mainType+"Index",idAttr=mainType+"Id",nameAttr=mainType+"Name";return q&&(q.hasOwnProperty(indexAttr)||q.hasOwnProperty(idAttr)||q.hasOwnProperty(nameAttr))?{mainType:mainType,
// subType will be filtered finally.
index:q[indexAttr],id:q[idAttr],name:q[nameAttr]}:null}function doFilter(res){return condition.filter?filter(res,condition.filter):res}var query=condition.query,mainType=condition.mainType,queryCond=getQueryCond(query),result=queryCond?this.queryComponents(queryCond):this._componentsMap[mainType];return doFilter(filterBySubType(result,condition))},/**
	         * @usage
	         * eachComponent('legend', function (legendModel, index) {
	         *     ...
	         * });
	         * eachComponent(function (componentType, model, index) {
	         *     // componentType does not include subType
	         *     // (componentType is 'xxx' but not 'xxx.aa')
	         * });
	         * eachComponent(
	         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
	         *     function (model, index) {...}
	         * );
	         * eachComponent(
	         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
	         *     function (model, index) {...}
	         * );
	         *
	         * @param {string|Object=} mainType When mainType is object, the definition
	         *                                  is the same as the method 'findComponents'.
	         * @param {Function} cb
	         * @param {*} context
	         */
eachComponent:function(mainType,cb,context){var componentsMap=this._componentsMap;if("function"==typeof mainType)context=cb,cb=mainType,each(componentsMap,function(components,componentType){each(components,function(component,index){cb.call(context,componentType,component,index)})});else if(zrUtil.isString(mainType))each(componentsMap[mainType],cb,context);else if(isObject(mainType)){var queryResult=this.findComponents(mainType);each(queryResult,cb,context)}},/**
	         * @param {string} name
	         * @return {Array.<module:echarts/model/Series>}
	         */
getSeriesByName:function(name){var series=this._componentsMap.series;return filter(series,function(oneSeries){return oneSeries.name===name})},/**
	         * @param {number} seriesIndex
	         * @return {module:echarts/model/Series}
	         */
getSeriesByIndex:function(seriesIndex){return this._componentsMap.series[seriesIndex]},/**
	         * @param {string} subType
	         * @return {Array.<module:echarts/model/Series>}
	         */
getSeriesByType:function(subType){var series=this._componentsMap.series;return filter(series,function(oneSeries){return oneSeries.subType===subType})},/**
	         * @return {Array.<module:echarts/model/Series>}
	         */
getSeries:function(){return this._componentsMap.series.slice()},/**
	         * After filtering, series may be different
	         * frome raw series.
	         *
	         * @param {Function} cb
	         * @param {*} context
	         */
eachSeries:function(cb,context){assertSeriesInitialized(this),each(this._seriesIndices,function(rawSeriesIndex){var series=this._componentsMap.series[rawSeriesIndex];cb.call(context,series,rawSeriesIndex)},this)},/**
	         * Iterate raw series before filtered.
	         *
	         * @param {Function} cb
	         * @param {*} context
	         */
eachRawSeries:function(cb,context){each(this._componentsMap.series,cb,context)},/**
	         * After filtering, series may be different.
	         * frome raw series.
	         *
	         * @parma {string} subType
	         * @param {Function} cb
	         * @param {*} context
	         */
eachSeriesByType:function(subType,cb,context){assertSeriesInitialized(this),each(this._seriesIndices,function(rawSeriesIndex){var series=this._componentsMap.series[rawSeriesIndex];series.subType===subType&&cb.call(context,series,rawSeriesIndex)},this)},/**
	         * Iterate raw series before filtered of given type.
	         *
	         * @parma {string} subType
	         * @param {Function} cb
	         * @param {*} context
	         */
eachRawSeriesByType:function(subType,cb,context){return each(this.getSeriesByType(subType),cb,context)},/**
	         * @param {module:echarts/model/Series} seriesModel
	         */
isSeriesFiltered:function(seriesModel){return assertSeriesInitialized(this),zrUtil.indexOf(this._seriesIndices,seriesModel.componentIndex)<0},/**
	         * @param {Function} cb
	         * @param {*} context
	         */
filterSeries:function(cb,context){assertSeriesInitialized(this);var filteredSeries=filter(this._componentsMap.series,cb,context);this._seriesIndices=createSeriesIndices(filteredSeries)},restoreData:function(){var componentsMap=this._componentsMap;this._seriesIndices=createSeriesIndices(componentsMap.series);var componentTypes=[];each(componentsMap,function(components,componentType){componentTypes.push(componentType)}),ComponentModel.topologicalTravel(componentTypes,ComponentModel.getAllClassMainTypes(),function(componentType,dependencies){each(componentsMap[componentType],function(component){component.restoreData()})})}});module.exports=GlobalModel},/* 3 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
function clone(source){if("object"==typeof source&&null!==source){var result=source;if(source instanceof Array){result=[];for(var i=0,len=source.length;len>i;i++)result[i]=clone(source[i])}else if(!isBuildInObject(source)&&!isDom(source)){result={};for(var key in source)source.hasOwnProperty(key)&&(result[key]=clone(source[key]))}return result}return source}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
function merge(target,source,overwrite){
// We should escapse that source is string
// and enter for ... in ...
if(!isObject(source)||!isObject(target))return overwrite?clone(source):target;for(var key in source)if(source.hasOwnProperty(key)){var targetProp=target[key],sourceProp=source[key];!isObject(sourceProp)||!isObject(targetProp)||isArray(sourceProp)||isArray(targetProp)||isDom(sourceProp)||isDom(targetProp)||isBuildInObject(sourceProp)||isBuildInObject(targetProp)?!overwrite&&key in target||(
// 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
// NOTE，在 target[key] 不存在的时候也是直接覆盖
target[key]=clone(source[key],!0)):
// 如果需要递归覆盖，就递归调用merge
merge(targetProp,sourceProp,overwrite)}return target}/**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
function mergeAll(targetAndSources,overwrite){for(var result=targetAndSources[0],i=1,len=targetAndSources.length;len>i;i++)result=merge(result,targetAndSources[i],overwrite);return result}/**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
function extend(target,source){for(var key in source)source.hasOwnProperty(key)&&(target[key]=source[key]);return target}/**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
function defaults(target,source,overlay){for(var key in source)source.hasOwnProperty(key)&&(overlay?null!=source[key]:null==target[key])&&(target[key]=source[key]);return target}function createCanvas(){return document.createElement("canvas")}function getContext(){
// Use util.createCanvas instead of createCanvas
// because createCanvas may be overwritten in different environment
return _ctx||(_ctx=util.createCanvas().getContext("2d")),_ctx}/**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
function indexOf(array,value){if(array){if(array.indexOf)return array.indexOf(value);for(var i=0,len=array.length;len>i;i++)if(array[i]===value)return i}return-1}/**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
function inherits(clazz,baseClazz){function F(){}var clazzPrototype=clazz.prototype;F.prototype=baseClazz.prototype,clazz.prototype=new F;for(var prop in clazzPrototype)clazz.prototype[prop]=clazzPrototype[prop];clazz.prototype.constructor=clazz,clazz.superClass=baseClazz}/**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
function mixin(target,source,overlay){target="prototype"in target?target.prototype:target,source="prototype"in source?source.prototype:source,defaults(target,source,overlay)}/**
	     * @param {Array|TypedArray} data
	     */
function isArrayLike(data){return data?"string"==typeof data?!1:"number"==typeof data.length:void 0}/**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
function each(obj,cb,context){if(obj&&cb)if(obj.forEach&&obj.forEach===nativeForEach)obj.forEach(cb,context);else if(obj.length===+obj.length)for(var i=0,len=obj.length;len>i;i++)cb.call(context,obj[i],i,obj);else for(var key in obj)obj.hasOwnProperty(key)&&cb.call(context,obj[key],key,obj)}/**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
function map(obj,cb,context){if(obj&&cb){if(obj.map&&obj.map===nativeMap)return obj.map(cb,context);for(var result=[],i=0,len=obj.length;len>i;i++)result.push(cb.call(context,obj[i],i,obj));return result}}/**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
function reduce(obj,cb,memo,context){if(obj&&cb){if(obj.reduce&&obj.reduce===nativeReduce)return obj.reduce(cb,memo,context);for(var i=0,len=obj.length;len>i;i++)memo=cb.call(context,memo,obj[i],i,obj);return memo}}/**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
function filter(obj,cb,context){if(obj&&cb){if(obj.filter&&obj.filter===nativeFilter)return obj.filter(cb,context);for(var result=[],i=0,len=obj.length;len>i;i++)cb.call(context,obj[i],i,obj)&&result.push(obj[i]);return result}}/**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
function find(obj,cb,context){if(obj&&cb)for(var i=0,len=obj.length;len>i;i++)if(cb.call(context,obj[i],i,obj))return obj[i]}/**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
function bind(func,context){var args=nativeSlice.call(arguments,2);return function(){return func.apply(context,args.concat(nativeSlice.call(arguments)))}}/**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
function curry(func){var args=nativeSlice.call(arguments,1);return function(){return func.apply(this,args.concat(nativeSlice.call(arguments)))}}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isArray(value){return"[object Array]"===objToString.call(value)}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isFunction(value){return"function"==typeof value}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isString(value){return"[object String]"===objToString.call(value)}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isObject(value){
// Avoid a V8 JIT bug in Chrome 19-20.
// See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
var type=typeof value;return"function"===type||!!value&&"object"==type}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isBuildInObject(value){return!!BUILTIN_OBJECT[objToString.call(value)]||value instanceof Gradient}/**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
function isDom(value){return value&&1===value.nodeType&&"string"==typeof value.nodeName}/**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
function retrieve(values){for(var i=0,len=arguments.length;len>i;i++)if(null!=arguments[i])return arguments[i]}/**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
function slice(){return Function.call.apply(nativeSlice,arguments)}/**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
function assert(condition,message){if(!condition)throw new Error(message)}/**
	 * @module zrender/core/util
	 */
var _ctx,Gradient=__webpack_require__(4),BUILTIN_OBJECT={"[object Function]":1,"[object RegExp]":1,"[object Date]":1,"[object Error]":1,"[object CanvasGradient]":1},objToString=Object.prototype.toString,arrayProto=Array.prototype,nativeForEach=arrayProto.forEach,nativeFilter=arrayProto.filter,nativeSlice=arrayProto.slice,nativeMap=arrayProto.map,nativeReduce=arrayProto.reduce,util={inherits:inherits,mixin:mixin,clone:clone,merge:merge,mergeAll:mergeAll,extend:extend,defaults:defaults,getContext:getContext,createCanvas:createCanvas,indexOf:indexOf,slice:slice,find:find,isArrayLike:isArrayLike,each:each,map:map,reduce:reduce,filter:filter,bind:bind,curry:curry,isArray:isArray,isString:isString,isObject:isObject,isFunction:isFunction,isBuildInObject:isBuildInObject,isDom:isDom,retrieve:retrieve,assert:assert,noop:function(){}};module.exports=util},/* 4 */
/***/
function(module,exports){/**
	     * @param {Array.<Object>} colorStops
	     */
var Gradient=function(colorStops){this.colorStops=colorStops||[]};Gradient.prototype={constructor:Gradient,addColorStop:function(offset,color){this.colorStops.push({offset:offset,color:color})}},module.exports=Gradient},/* 5 */
/***/
function(module,exports,__webpack_require__){var formatUtil=__webpack_require__(6),nubmerUtil=__webpack_require__(7),zrUtil=__webpack_require__(3),Model=__webpack_require__(8),AXIS_DIMS=["x","y","z","radius","angle"],modelUtil={};/**
	     * Create "each" method to iterate names.
	     *
	     * @pubilc
	     * @param  {Array.<string>} names
	     * @param  {Array.<string>=} attrs
	     * @return {Function}
	     */
modelUtil.createNameEach=function(names,attrs){names=names.slice();var capitalNames=zrUtil.map(names,modelUtil.capitalFirst);attrs=(attrs||[]).slice();var capitalAttrs=zrUtil.map(attrs,modelUtil.capitalFirst);return function(callback,context){zrUtil.each(names,function(name,index){for(var nameObj={name:name,capital:capitalNames[index]},j=0;j<attrs.length;j++)nameObj[attrs[j]]=name+capitalAttrs[j];callback.call(context,nameObj)})}},/**
	     * @public
	     */
modelUtil.capitalFirst=function(str){return str?str.charAt(0).toUpperCase()+str.substr(1):str},/**
	     * Iterate each dimension name.
	     *
	     * @public
	     * @param {Function} callback The parameter is like:
	     *                            {
	     *                                name: 'angle',
	     *                                capital: 'Angle',
	     *                                axis: 'angleAxis',
	     *                                axisIndex: 'angleAixs',
	     *                                index: 'angleIndex'
	     *                            }
	     * @param {Object} context
	     */
modelUtil.eachAxisDim=modelUtil.createNameEach(AXIS_DIMS,["axisIndex","axis","index"]),/**
	     * If value is not array, then translate it to array.
	     * @param  {*} value
	     * @return {Array} [value] or value
	     */
modelUtil.normalizeToArray=function(value){return zrUtil.isArray(value)?value:null==value?[]:[value]},/**
	     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.
	     * dataZoomModels and 'links' make up one or more graphics.
	     * This function finds the graphic where the source dataZoomModel is in.
	     *
	     * @public
	     * @param {Function} forEachNode Node iterator.
	     * @param {Function} forEachEdgeType edgeType iterator
	     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.
	     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}
	     */
modelUtil.createLinkedNodesFinder=function(forEachNode,forEachEdgeType,edgeIdGetter){function isNodeAbsorded(node,result){return zrUtil.indexOf(result.nodes,node)>=0}function isLinked(node,result){var hasLink=!1;return forEachEdgeType(function(edgeType){zrUtil.each(edgeIdGetter(node,edgeType)||[],function(edgeId){result.records[edgeType.name][edgeId]&&(hasLink=!0)})}),hasLink}function absorb(node,result){result.nodes.push(node),forEachEdgeType(function(edgeType){zrUtil.each(edgeIdGetter(node,edgeType)||[],function(edgeId){result.records[edgeType.name][edgeId]=!0})})}return function(sourceNode){function processSingleNode(node){!isNodeAbsorded(node,result)&&isLinked(node,result)&&(absorb(node,result),existsLink=!0)}var result={nodes:[],records:{}};if(forEachEdgeType(function(edgeType){result.records[edgeType.name]={}}),!sourceNode)return result;absorb(sourceNode,result);var existsLink;do existsLink=!1,forEachNode(processSingleNode);while(existsLink);return result}},/**
	     * Sync default option between normal and emphasis like `position` and `show`
	     * In case some one will write code like
	     *     label: {
	     *         normal: {
	     *             show: false,
	     *             position: 'outside',
	     *             textStyle: {
	     *                 fontSize: 18
	     *             }
	     *         },
	     *         emphasis: {
	     *             show: true
	     *         }
	     *     }
	     * @param {Object} opt
	     * @param {Array.<string>} subOpts
	     */
modelUtil.defaultEmphasis=function(opt,subOpts){if(opt){var emphasisOpt=opt.emphasis=opt.emphasis||{},normalOpt=opt.normal=opt.normal||{};
// Default emphasis option from normal
zrUtil.each(subOpts,function(subOptName){var val=zrUtil.retrieve(emphasisOpt[subOptName],normalOpt[subOptName]);null!=val&&(emphasisOpt[subOptName]=val)})}},/**
	     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
	     * @param {Object} opt
	     * @param {string} [opt.seriesIndex]
	     * @param {Object} [opt.name]
	     * @param {module:echarts/data/List} data
	     * @param {Array.<Object>} rawData
	     */
modelUtil.createDataFormatModel=function(opt,data,rawData){var model=new Model;return zrUtil.mixin(model,modelUtil.dataFormatMixin),model.seriesIndex=opt.seriesIndex,model.name=opt.name||"",model.getData=function(){return data},model.getRawDataArray=function(){return rawData},model},/**
	     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
	     * This helper method retieves value from data.
	     * @param {string|number|Date|Array|Object} dataItem
	     * @return {number|string|Date|Array.<number|string|Date>}
	     */
modelUtil.getDataItemValue=function(dataItem){
// Performance sensitive.
return dataItem&&(null==dataItem.value?dataItem:dataItem.value)},/**
	     * This helper method convert value in data.
	     * @param {string|number|Date} value
	     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
	     */
modelUtil.converDataValue=function(value,dimInfo){
// Performance sensitive.
var dimType=dimInfo&&dimInfo.type;return"ordinal"===dimType?value:("time"!==dimType||isFinite(value)||null==value||"-"===value||(value=+nubmerUtil.parseDate(value)),null==value||""===value?NaN:+value)},modelUtil.dataFormatMixin={/**
	         * Get params for formatter
	         * @param {number} dataIndex
	         * @return {Object}
	         */
getDataParams:function(dataIndex){var data=this.getData(),seriesIndex=this.seriesIndex,seriesName=this.name,rawValue=this.getRawValue(dataIndex),rawDataIndex=data.getRawIndex(dataIndex),name=data.getName(dataIndex,!0),rawDataArray=this.getRawDataArray(),itemOpt=rawDataArray&&rawDataArray[rawDataIndex];return{componentType:"series",seriesType:this.subType,seriesIndex:seriesIndex,seriesName:seriesName,name:name,dataIndex:rawDataIndex,data:itemOpt,value:rawValue,color:data.getItemVisual(dataIndex,"color"),
// Param name list for mapping `a`, `b`, `c`, `d`, `e`
$vars:["seriesName","name","value"]}},/**
	         * Format label
	         * @param {number} dataIndex
	         * @param {string} [status='normal'] 'normal' or 'emphasis'
	         * @param {Function|string} [formatter] Default use the `itemStyle[status].label.formatter`
	         * @return {string}
	         */
getFormattedLabel:function(dataIndex,status,formatter){status=status||"normal";var data=this.getData(),itemModel=data.getItemModel(dataIndex),params=this.getDataParams(dataIndex);return null==formatter&&(formatter=itemModel.get(["label",status,"formatter"])),"function"==typeof formatter?(params.status=status,formatter(params)):"string"==typeof formatter?formatUtil.formatTpl(formatter,params):void 0},/**
	         * Get raw value in option
	         * @param {number} idx
	         * @return {Object}
	         */
getRawValue:function(idx){var itemModel=this.getData().getItemModel(idx);if(itemModel&&null!=itemModel.option){var dataItem=itemModel.option;return zrUtil.isObject(dataItem)&&!zrUtil.isArray(dataItem)?dataItem.value:dataItem}}},/**
	     * Mapping to exists for merge.
	     *
	     * @public
	     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
	     * @param {Object|Array.<Object>} newCptOptions
	     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
	     *                          which order is the same as exists.
	     */
modelUtil.mappingToExists=function(exists,newCptOptions){
// Mapping by the order by original option (but not order of
// new option) in merge mode. Because we should ensure
// some specified index (like xAxisIndex) is consistent with
// original option, which is easy to understand, espatially in
// media query. And in most case, merge option is used to
// update partial option but not be expected to change order.
newCptOptions=(newCptOptions||[]).slice();var result=zrUtil.map(exists||[],function(obj,index){return{exist:obj}});
// Mapping by id or name if specified.
// Otherwise mapping by index.
return zrUtil.each(newCptOptions,function(cptOption,index){if(zrUtil.isObject(cptOption))for(var i=0;i<result.length;i++){var exist=result[i].exist;if(!result[i].option&&(null!=cptOption.id&&exist.id===cptOption.id+""||null!=cptOption.name&&!modelUtil.isIdInner(cptOption)&&!modelUtil.isIdInner(exist)&&exist.name===cptOption.name+"")){result[i].option=cptOption,newCptOptions[index]=null;break}}}),zrUtil.each(newCptOptions,function(cptOption,index){if(zrUtil.isObject(cptOption)){for(var i=0;i<result.length;i++){var exist=result[i].exist;if(!result[i].option&&!modelUtil.isIdInner(exist)&&null==cptOption.id){result[i].option=cptOption;break}}i>=result.length&&result.push({option:cptOption})}}),result},/**
	     * @public
	     * @param {Object} cptOption
	     * @return {boolean}
	     */
modelUtil.isIdInner=function(cptOption){return zrUtil.isObject(cptOption)&&cptOption.id&&0===(cptOption.id+"").indexOf("\x00_ec_\x00")},module.exports=modelUtil},/* 6 */
/***/
function(module,exports,__webpack_require__){/**
	     * 每三位默认加,格式化
	     * @type {string|number} x
	     */
function addCommas(x){return isNaN(x)?"-":(x=(x+"").split("."),x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,"$1,")+(x.length>1?"."+x[1]:""))}/**
	     * @param {string} str
	     * @return {string} str
	     */
function toCamelCase(str){return str.toLowerCase().replace(/-(.)/g,function(match,group1){return group1.toUpperCase()})}/**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     */
function normalizeCssArray(val){var len=val.length;return"number"==typeof val?[val,val,val,val]:2===len?[val[0],val[1],val[0],val[1]]:3===len?[val[0],val[1],val[2],val[1]]:val}function encodeHTML(source){return String(source).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function wrapVar(varName,seriesIdx){return"{"+varName+(null==seriesIdx?"":seriesIdx)+"}"}/**
	     * Template formatter
	     * @param  {string} tpl
	     * @param  {Array.<Object>|Object} paramsList
	     * @return {string}
	     */
function formatTpl(tpl,paramsList){zrUtil.isArray(paramsList)||(paramsList=[paramsList]);var seriesLen=paramsList.length;if(!seriesLen)return"";for(var $vars=paramsList[0].$vars,i=0;i<$vars.length;i++){var alias=TPL_VAR_ALIAS[i];tpl=tpl.replace(wrapVar(alias),wrapVar(alias,0))}for(var seriesIdx=0;seriesLen>seriesIdx;seriesIdx++)for(var k=0;k<$vars.length;k++)tpl=tpl.replace(wrapVar(TPL_VAR_ALIAS[k],seriesIdx),paramsList[seriesIdx][$vars[k]]);return tpl}/**
	     * ISO Date format
	     * @param {string} tpl
	     * @param {number} value
	     * @inner
	     */
function formatTime(tpl,value){"week"!==tpl&&"month"!==tpl&&"quarter"!==tpl&&"half-year"!==tpl&&"year"!==tpl||(tpl="MM-dd\nyyyy");var date=numberUtil.parseDate(value),y=date.getFullYear(),M=date.getMonth()+1,d=date.getDate(),h=date.getHours(),m=date.getMinutes(),s=date.getSeconds();return tpl=tpl.replace("MM",s2d(M)).toLowerCase().replace("yyyy",y).replace("yy",y%100).replace("dd",s2d(d)).replace("d",d).replace("hh",s2d(h)).replace("h",h).replace("mm",s2d(m)).replace("m",m).replace("ss",s2d(s)).replace("s",s)}/**
	     * @param {string} str
	     * @return {string}
	     * @inner
	     */
function s2d(str){return 10>str?"0"+str:str}var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),TPL_VAR_ALIAS=["a","b","c","d","e","f","g"];module.exports={normalizeCssArray:normalizeCssArray,addCommas:addCommas,toCamelCase:toCamelCase,encodeHTML:encodeHTML,formatTpl:formatTpl,formatTime:formatTime}},/* 7 */
/***/
function(module,exports){function _trim(str){return str.replace(/^\s+/,"").replace(/\s+$/,"")}/**
	 * 数值处理模块
	 * @module echarts/util/number
	 */
var number={},RADIAN_EPSILON=1e-4;/**
	     * Linear mapping a value from domain to range
	     * @memberOf module:echarts/util/number
	     * @param  {(number|Array.<number>)} val
	     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
	     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
	     * @param  {boolean} clamp
	     * @return {(number|Array.<number>}
	     */
number.linearMap=function(val,domain,range,clamp){var sub=domain[1]-domain[0];if(0===sub)return(range[0]+range[1])/2;var t=(val-domain[0])/sub;return clamp&&(t=Math.min(Math.max(t,0),1)),t*(range[1]-range[0])+range[0]},/**
	     * Convert a percent string to absolute number.
	     * Returns NaN if percent is not a valid string or number
	     * @memberOf module:echarts/util/number
	     * @param {string|number} percent
	     * @param {number} all
	     * @return {number}
	     */
number.parsePercent=function(percent,all){switch(percent){case"center":case"middle":percent="50%";break;case"left":case"top":percent="0%";break;case"right":case"bottom":percent="100%"}return"string"==typeof percent?_trim(percent).match(/%$/)?parseFloat(percent)/100*all:parseFloat(percent):null==percent?NaN:+percent},/**
	     * Fix rounding error of float numbers
	     * @param {number} x
	     * @return {number}
	     */
number.round=function(x){
// PENDING
return+(+x).toFixed(10)},number.asc=function(arr){return arr.sort(function(a,b){return a-b}),arr},/**
	     * Get precision
	     * @param {number} val
	     */
number.getPrecision=function(val){if(isNaN(val))return 0;for(
// It is much faster than methods converting number to string as follows
//      var tmp = val.toString();
//      return tmp.length - 1 - tmp.indexOf('.');
// especially when precision is low
var e=1,count=0;Math.round(val*e)/e!==val;)e*=10,count++;return count},/**
	     * @param {Array.<number>} dataExtent
	     * @param {Array.<number>} pixelExtent
	     * @return {number}  precision
	     */
number.getPixelPrecision=function(dataExtent,pixelExtent){var log=Math.log,LN10=Math.LN10,dataQuantity=Math.floor(log(dataExtent[1]-dataExtent[0])/LN10),sizeQuantity=Math.round(log(Math.abs(pixelExtent[1]-pixelExtent[0]))/LN10);return Math.max(-dataQuantity+sizeQuantity,0)},
// Number.MAX_SAFE_INTEGER, ie do not support.
number.MAX_SAFE_INTEGER=9007199254740991,/**
	     * To 0 - 2 * PI, considering negative radian.
	     * @param {number} radian
	     * @return {number}
	     */
number.remRadian=function(radian){var pi2=2*Math.PI;return(radian%pi2+pi2)%pi2},/**
	     * @param {type} radian
	     * @return {boolean}
	     */
number.isRadianAroundZero=function(val){return val>-RADIAN_EPSILON&&RADIAN_EPSILON>val},/**
	     * @param {string|Date|number} value
	     * @return {number} timestamp
	     */
number.parseDate=function(value){return value instanceof Date?value:new Date("string"==typeof value?value.replace(/-/g,"/"):Math.round(value))},
// "Nice Numbers for Graph Labels" of Graphic Gems
/**
	     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false
	     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
	     * @param  {number} val
	     * @param  {boolean} round
	     * @return {number}
	     */
number.nice=function(val,round){var nf,exp=Math.floor(Math.log(val)/Math.LN10),exp10=Math.pow(10,exp),f=val/exp10;return nf=round?1.5>f?1:2.5>f?2:4>f?3:7>f?5:10:1>f?1:2>f?2:3>f?3:5>f?5:10,nf*exp10},module.exports=number},/* 8 */
/***/
function(module,exports,__webpack_require__){/**
	     * @alias module:echarts/model/Model
	     * @constructor
	     * @param {Object} option
	     * @param {module:echarts/model/Model} parentModel
	     * @param {module:echarts/model/Global} ecModel
	     * @param {Object} extraOpt
	     */
function Model(option,parentModel,ecModel,extraOpt){/**
	         * @type {module:echarts/model/Model}
	         * @readOnly
	         */
this.parentModel=parentModel,/**
	         * @type {module:echarts/model/Global}
	         * @readOnly
	         */
this.ecModel=ecModel,/**
	         * @type {Object}
	         * @protected
	         */
this.option=option,
// Simple optimization
this.init&&(arguments.length<=4?this.init(option,parentModel,ecModel,extraOpt):this.init.apply(this,arguments))}/**
	 * @module echarts/model/Model
	 */
var zrUtil=__webpack_require__(3),clazzUtil=__webpack_require__(9);Model.prototype={constructor:Model,/**
	         * Model 的初始化函数
	         * @param {Object} option
	         */
init:null,/**
	         * 从新的 Option merge
	         */
mergeOption:function(option){zrUtil.merge(this.option,option,!0)},/**
	         * @param {string} path
	         * @param {boolean} [ignoreParent=false]
	         * @return {*}
	         */
get:function(path,ignoreParent){if(!path)return this.option;"string"==typeof path&&(path=path.split("."));for(var obj=this.option,parentModel=this.parentModel,i=0;i<path.length&&(obj=obj&&"object"==typeof obj?obj[path[i]]:null,null!=obj);i++);return null==obj&&parentModel&&!ignoreParent&&(obj=parentModel.get(path)),obj},/**
	         * @param {string} key
	         * @param {boolean} [ignoreParent=false]
	         * @return {*}
	         */
getShallow:function(key,ignoreParent){var option=this.option,val=option&&option[key],parentModel=this.parentModel;return null==val&&parentModel&&!ignoreParent&&(val=parentModel.getShallow(key)),val},/**
	         * @param {string} path
	         * @param {module:echarts/model/Model} [parentModel]
	         * @return {module:echarts/model/Model}
	         */
getModel:function(path,parentModel){var obj=this.get(path,!0),thisParentModel=this.parentModel,model=new Model(obj,parentModel||thisParentModel&&thisParentModel.getModel(path),this.ecModel);return model},/**
	         * If model has option
	         */
isEmpty:function(){return null==this.option},restoreData:function(){},
// Pending
clone:function(){var Ctor=this.constructor;return new Ctor(zrUtil.clone(this.option))},setReadOnly:function(properties){clazzUtil.setReadOnly(this,properties)}},
// Enable Model.extend.
clazzUtil.enableClassExtend(Model);var mixin=zrUtil.mixin;mixin(Model,__webpack_require__(10)),mixin(Model,__webpack_require__(12)),mixin(Model,__webpack_require__(13)),mixin(Model,__webpack_require__(18)),module.exports=Model},/* 9 */
/***/
function(module,exports,__webpack_require__){
// superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.
function superCall(context,methodName){var args=zrUtil.slice(arguments,2);return this.superClass.prototype[methodName].apply(context,args)}function superApply(context,methodName,args){return this.superClass.prototype[methodName].apply(context,args)}var zrUtil=__webpack_require__(3),clazz={},TYPE_DELIMITER=".",IS_CONTAINER="___EC__COMPONENT__CONTAINER___",parseClassType=clazz.parseClassType=function(componentType){var ret={main:"",sub:""};return componentType&&(componentType=componentType.split(TYPE_DELIMITER),ret.main=componentType[0]||"",ret.sub=componentType[1]||""),ret};/**
	     * @public
	     */
clazz.enableClassExtend=function(RootClass,preConstruct){RootClass.extend=function(proto){var ExtendedClass=function(){preConstruct&&preConstruct.apply(this,arguments),RootClass.apply(this,arguments)};return zrUtil.extend(ExtendedClass.prototype,proto),ExtendedClass.extend=this.extend,ExtendedClass.superCall=superCall,ExtendedClass.superApply=superApply,zrUtil.inherits(ExtendedClass,this),ExtendedClass.superClass=this,ExtendedClass}},/**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
clazz.enableClassManagement=function(entity,options){function makeContainer(componentType){var container=storage[componentType.main];return container&&container[IS_CONTAINER]||(container=storage[componentType.main]={},container[IS_CONTAINER]=!0),container}options=options||{};/**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
var storage={};if(entity.registerClass=function(Clazz,componentType){if(componentType)if(componentType=parseClassType(componentType),componentType.sub){if(componentType.sub!==IS_CONTAINER){var container=makeContainer(componentType);container[componentType.sub]=Clazz}}else{if(storage[componentType.main])throw new Error(componentType.main+"exists.");storage[componentType.main]=Clazz}return Clazz},entity.getClass=function(componentTypeMain,subType,throwWhenNotFound){var Clazz=storage[componentTypeMain];if(Clazz&&Clazz[IS_CONTAINER]&&(Clazz=subType?Clazz[subType]:null),throwWhenNotFound&&!Clazz)throw new Error("Component "+componentTypeMain+"."+(subType||"")+" not exists. Load it first.");return Clazz},entity.getClassesByMainType=function(componentType){componentType=parseClassType(componentType);var result=[],obj=storage[componentType.main];return obj&&obj[IS_CONTAINER]?zrUtil.each(obj,function(o,type){type!==IS_CONTAINER&&result.push(o)}):result.push(obj),result},entity.hasClass=function(componentType){
// Just consider componentType.main.
return componentType=parseClassType(componentType),!!storage[componentType.main]},/**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
entity.getAllClassMainTypes=function(){var types=[];return zrUtil.each(storage,function(obj,type){types.push(type)}),types},/**
	         * If a main type is container and has sub types
	         * @param  {string}  mainType
	         * @return {boolean}
	         */
entity.hasSubTypes=function(componentType){componentType=parseClassType(componentType);var obj=storage[componentType.main];return obj&&obj[IS_CONTAINER]},entity.parseClassType=parseClassType,options.registerWhenExtend){var originalExtend=entity.extend;originalExtend&&(entity.extend=function(proto){var ExtendedClass=originalExtend.call(this,proto);return entity.registerClass(ExtendedClass,proto.type)})}return entity},/**
	     * @param {string|Array.<string>} properties
	     */
clazz.setReadOnly=function(obj,properties){},module.exports=clazz},/* 10 */
/***/
function(module,exports,__webpack_require__){var getLineStyle=__webpack_require__(11)([["lineWidth","width"],["stroke","color"],["opacity"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"]]);module.exports={getLineStyle:function(excludes){var style=getLineStyle.call(this,excludes),lineDash=this.getLineDash();return lineDash&&(style.lineDash=lineDash),style},getLineDash:function(){var lineType=this.get("type");return"solid"===lineType||null==lineType?null:"dashed"===lineType?[5,5]:[1,1]}}},/* 11 */
/***/
function(module,exports,__webpack_require__){
// TODO Parse shadow style
// TODO Only shallow path support
var zrUtil=__webpack_require__(3);module.exports=function(properties){
// Normalize
for(var i=0;i<properties.length;i++)properties[i][1]||(properties[i][1]=properties[i][0]);return function(excludes){for(var style={},i=0;i<properties.length;i++){var propName=properties[i][1];if(!(excludes&&zrUtil.indexOf(excludes,propName)>=0)){var val=this.getShallow(propName);null!=val&&(style[properties[i][0]]=val)}}return style}}},/* 12 */
/***/
function(module,exports,__webpack_require__){module.exports={getAreaStyle:__webpack_require__(11)([["fill","color"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["opacity"],["shadowColor"]])}},/* 13 */
/***/
function(module,exports,__webpack_require__){function getShallow(model,path){return model&&model.getShallow(path)}var textContain=__webpack_require__(14);module.exports={/**
	         * Get color property or get color from option.textStyle.color
	         * @return {string}
	         */
getTextColor:function(){var ecModel=this.ecModel;return this.getShallow("color")||ecModel&&ecModel.get("textStyle.color")},/**
	         * Create font string from fontStyle, fontWeight, fontSize, fontFamily
	         * @return {string}
	         */
getFont:function(){var ecModel=this.ecModel,gTextStyleModel=ecModel&&ecModel.getModel("textStyle");return[
// FIXME in node-canvas fontWeight is before fontStyle
this.getShallow("fontStyle")||getShallow(gTextStyleModel,"fontStyle"),this.getShallow("fontWeight")||getShallow(gTextStyleModel,"fontWeight"),(this.getShallow("fontSize")||getShallow(gTextStyleModel,"fontSize")||12)+"px",this.getShallow("fontFamily")||getShallow(gTextStyleModel,"fontFamily")||"sans-serif"].join(" ")},getTextRect:function(text){var textStyle=this.get("textStyle")||{};return textContain.getBoundingRect(text,this.getFont(),textStyle.align,textStyle.baseline)},ellipsis:function(text,containerWidth,options){return textContain.ellipsis(text,this.getFont(),containerWidth,options)}}},/* 14 */
/***/
function(module,exports,__webpack_require__){function getTextWidth(text,textFont){var key=text+":"+textFont;if(textWidthCache[key])return textWidthCache[key];for(var textLines=(text+"").split("\n"),width=0,i=0,l=textLines.length;l>i;i++)
// measureText 可以被覆盖以兼容不支持 Canvas 的环境
width=Math.max(textContain.measureText(textLines[i],textFont).width,width);return textWidthCacheCounter>TEXT_CACHE_MAX&&(textWidthCacheCounter=0,textWidthCache={}),textWidthCacheCounter++,textWidthCache[key]=width,width}function getTextRect(text,textFont,textAlign,textBaseline){var textLineLen=((text||"")+"").split("\n").length,width=getTextWidth(text,textFont),lineHeight=getTextWidth("国",textFont),height=textLineLen*lineHeight,rect=new BoundingRect(0,0,width,height);switch(
// Text has a special line height property
rect.lineHeight=lineHeight,textBaseline){case"bottom":case"alphabetic":rect.y-=lineHeight;break;case"middle":rect.y-=lineHeight/2}
// FIXME Right to left language
switch(textAlign){case"end":case"right":rect.x-=rect.width;break;case"center":rect.x-=rect.width/2}return rect}function adjustTextPositionOnRect(textPosition,rect,textRect,distance){var x=rect.x,y=rect.y,height=rect.height,width=rect.width,textHeight=textRect.height,halfHeight=height/2-textHeight/2,textAlign="left";switch(textPosition){case"left":x-=distance,y+=halfHeight,textAlign="right";break;case"right":x+=distance+width,y+=halfHeight,textAlign="left";break;case"top":x+=width/2,y-=distance+textHeight,textAlign="center";break;case"bottom":x+=width/2,y+=height+distance,textAlign="center";break;case"inside":x+=width/2,y+=halfHeight,textAlign="center";break;case"insideLeft":x+=distance,y+=halfHeight,textAlign="left";break;case"insideRight":x+=width-distance,y+=halfHeight,textAlign="right";break;case"insideTop":x+=width/2,y+=distance,textAlign="center";break;case"insideBottom":x+=width/2,y+=height-textHeight-distance,textAlign="center";break;case"insideTopLeft":x+=distance,y+=distance,textAlign="left";break;case"insideTopRight":x+=width-distance,y+=distance,textAlign="right";break;case"insideBottomLeft":x+=distance,y+=height-textHeight-distance;break;case"insideBottomRight":x+=width-distance,y+=height-textHeight-distance,textAlign="right"}return{x:x,y:y,textAlign:textAlign,textBaseline:"top"}}/**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} textFont
	     * @param  {string} containerWidth
	     * @param  {Object} [options]
	     * @param  {number} [options.ellipsis='...']
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minCharacters=3]
	     * @return {string}
	     */
function textEllipsis(text,textFont,containerWidth,options){if(!containerWidth)return"";options=util.defaults({ellipsis:"...",minCharacters:3,maxIterations:3,cnCharWidth:getTextWidth("国",textFont),
// FIXME
// 未考虑非等宽字体
ascCharWidth:getTextWidth("a",textFont)},options,!0),containerWidth-=getTextWidth(options.ellipsis);for(var textLines=(text+"").split("\n"),i=0,len=textLines.length;len>i;i++)textLines[i]=textLineTruncate(textLines[i],textFont,containerWidth,options);return textLines.join("\n")}function textLineTruncate(text,textFont,containerWidth,options){
// FIXME
// 粗糙得写的，尚未考虑性能和各种语言、字体的效果。
for(var i=0;;i++){var lineWidth=getTextWidth(text,textFont);if(containerWidth>lineWidth||i>=options.maxIterations){text+=options.ellipsis;break}var subLength=0===i?estimateLength(text,containerWidth,options):Math.floor(text.length*containerWidth/lineWidth);if(subLength<options.minCharacters){text="";break}text=text.substr(0,subLength)}return text}function estimateLength(text,containerWidth,options){for(var width=0,i=0,len=text.length;len>i&&containerWidth>width;i++){var charCode=text.charCodeAt(i);width+=charCode>=0&&127>=charCode?options.ascCharWidth:options.cnCharWidth}return i}var textWidthCache={},textWidthCacheCounter=0,TEXT_CACHE_MAX=5e3,util=__webpack_require__(3),BoundingRect=__webpack_require__(15),textContain={getWidth:getTextWidth,getBoundingRect:getTextRect,adjustTextPositionOnRect:adjustTextPositionOnRect,ellipsis:textEllipsis,measureText:function(text,textFont){var ctx=util.getContext();return ctx.font=textFont,ctx.measureText(text)}};module.exports=textContain},/* 15 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	     * @alias module:echarts/core/BoundingRect
	     */
function BoundingRect(x,y,width,height){/**
	         * @type {number}
	         */
this.x=x,/**
	         * @type {number}
	         */
this.y=y,/**
	         * @type {number}
	         */
this.width=width,/**
	         * @type {number}
	         */
this.height=height}/**
	 * @module echarts/core/BoundingRect
	 */
var vec2=__webpack_require__(16),matrix=__webpack_require__(17),v2ApplyTransform=vec2.applyTransform,mathMin=Math.min,mathAbs=Math.abs,mathMax=Math.max;BoundingRect.prototype={constructor:BoundingRect,/**
	         * @param {module:echarts/core/BoundingRect} other
	         */
union:function(other){var x=mathMin(other.x,this.x),y=mathMin(other.y,this.y);this.width=mathMax(other.x+other.width,this.x+this.width)-x,this.height=mathMax(other.y+other.height,this.y+this.height)-y,this.x=x,this.y=y},/**
	         * @param {Array.<number>} m
	         * @methods
	         */
applyTransform:function(){var min=[],max=[];return function(m){
// In case usage like this
// el.getBoundingRect().applyTransform(el.transform)
// And element has no transform
m&&(min[0]=this.x,min[1]=this.y,max[0]=this.x+this.width,max[1]=this.y+this.height,v2ApplyTransform(min,min,m),v2ApplyTransform(max,max,m),this.x=mathMin(min[0],max[0]),this.y=mathMin(min[1],max[1]),this.width=mathAbs(max[0]-min[0]),this.height=mathAbs(max[1]-min[1]))}}(),/**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
calculateTransform:function(b){var a=this,sx=b.width/a.width,sy=b.height/a.height,m=matrix.create();
// 矩阵右乘
return matrix.translate(m,m,[-a.x,-a.y]),matrix.scale(m,m,[sx,sy]),matrix.translate(m,m,[b.x,b.y]),m},/**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
intersect:function(b){var a=this,ax0=a.x,ax1=a.x+a.width,ay0=a.y,ay1=a.y+a.height,bx0=b.x,bx1=b.x+b.width,by0=b.y,by1=b.y+b.height;return!(bx0>ax1||ax0>bx1||by0>ay1||ay0>by1)},contain:function(x,y){var rect=this;return x>=rect.x&&x<=rect.x+rect.width&&y>=rect.y&&y<=rect.y+rect.height},/**
	         * @return {module:echarts/core/BoundingRect}
	         */
clone:function(){return new BoundingRect(this.x,this.y,this.width,this.height)},/**
	         * Copy from another rect
	         */
copy:function(other){this.x=other.x,this.y=other.y,this.width=other.width,this.height=other.height}},module.exports=BoundingRect},/* 16 */
/***/
function(module,exports){var ArrayCtor="undefined"==typeof Float32Array?Array:Float32Array,vector={/**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
create:function(x,y){var out=new ArrayCtor(2);return out[0]=x||0,out[1]=y||0,out},/**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
copy:function(out,v){return out[0]=v[0],out[1]=v[1],out},/**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
clone:function(v){var out=new ArrayCtor(2);return out[0]=v[0],out[1]=v[1],out},/**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
set:function(out,a,b){return out[0]=a,out[1]=b,out},/**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
add:function(out,v1,v2){return out[0]=v1[0]+v2[0],out[1]=v1[1]+v2[1],out},/**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
scaleAndAdd:function(out,v1,v2,a){return out[0]=v1[0]+v2[0]*a,out[1]=v1[1]+v2[1]*a,out},/**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
sub:function(out,v1,v2){return out[0]=v1[0]-v2[0],out[1]=v1[1]-v2[1],out},/**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
len:function(v){return Math.sqrt(this.lenSquare(v))},/**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
lenSquare:function(v){return v[0]*v[0]+v[1]*v[1]},/**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
mul:function(out,v1,v2){return out[0]=v1[0]*v2[0],out[1]=v1[1]*v2[1],out},/**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
div:function(out,v1,v2){return out[0]=v1[0]/v2[0],out[1]=v1[1]/v2[1],out},/**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
dot:function(v1,v2){return v1[0]*v2[0]+v1[1]*v2[1]},/**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
scale:function(out,v,s){return out[0]=v[0]*s,out[1]=v[1]*s,out},/**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
normalize:function(out,v){var d=vector.len(v);return 0===d?(out[0]=0,out[1]=0):(out[0]=v[0]/d,out[1]=v[1]/d),out},/**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
distance:function(v1,v2){return Math.sqrt((v1[0]-v2[0])*(v1[0]-v2[0])+(v1[1]-v2[1])*(v1[1]-v2[1]))},/**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
distanceSquare:function(v1,v2){return(v1[0]-v2[0])*(v1[0]-v2[0])+(v1[1]-v2[1])*(v1[1]-v2[1])},/**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
negate:function(out,v){return out[0]=-v[0],out[1]=-v[1],out},/**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
lerp:function(out,v1,v2,t){return out[0]=v1[0]+t*(v2[0]-v1[0]),out[1]=v1[1]+t*(v2[1]-v1[1]),out},/**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
applyTransform:function(out,v,m){var x=v[0],y=v[1];return out[0]=m[0]*x+m[2]*y+m[4],out[1]=m[1]*x+m[3]*y+m[5],out},/**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
min:function(out,v1,v2){return out[0]=Math.min(v1[0],v2[0]),out[1]=Math.min(v1[1],v2[1]),out},/**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
max:function(out,v1,v2){return out[0]=Math.max(v1[0],v2[0]),out[1]=Math.max(v1[1],v2[1]),out}};vector.length=vector.len,vector.lengthSquare=vector.lenSquare,vector.dist=vector.distance,vector.distSquare=vector.distanceSquare,module.exports=vector},/* 17 */
/***/
function(module,exports){var ArrayCtor="undefined"==typeof Float32Array?Array:Float32Array,matrix={/**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
create:function(){var out=new ArrayCtor(6);return matrix.identity(out),out},/**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
identity:function(out){return out[0]=1,out[1]=0,out[2]=0,out[3]=1,out[4]=0,out[5]=0,out},/**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
copy:function(out,m){return out[0]=m[0],out[1]=m[1],out[2]=m[2],out[3]=m[3],out[4]=m[4],out[5]=m[5],out},/**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
mul:function(out,m1,m2){
// Consider matrix.mul(m, m2, m);
// where out is the same as m2.
// So use temp variable to escape error.
var out0=m1[0]*m2[0]+m1[2]*m2[1],out1=m1[1]*m2[0]+m1[3]*m2[1],out2=m1[0]*m2[2]+m1[2]*m2[3],out3=m1[1]*m2[2]+m1[3]*m2[3],out4=m1[0]*m2[4]+m1[2]*m2[5]+m1[4],out5=m1[1]*m2[4]+m1[3]*m2[5]+m1[5];return out[0]=out0,out[1]=out1,out[2]=out2,out[3]=out3,out[4]=out4,out[5]=out5,out},/**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
translate:function(out,a,v){return out[0]=a[0],out[1]=a[1],out[2]=a[2],out[3]=a[3],out[4]=a[4]+v[0],out[5]=a[5]+v[1],out},/**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
rotate:function(out,a,rad){var aa=a[0],ac=a[2],atx=a[4],ab=a[1],ad=a[3],aty=a[5],st=Math.sin(rad),ct=Math.cos(rad);return out[0]=aa*ct+ab*st,out[1]=-aa*st+ab*ct,out[2]=ac*ct+ad*st,out[3]=-ac*st+ct*ad,out[4]=ct*atx+st*aty,out[5]=ct*aty-st*atx,out},/**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
scale:function(out,a,v){var vx=v[0],vy=v[1];return out[0]=a[0]*vx,out[1]=a[1]*vy,out[2]=a[2]*vx,out[3]=a[3]*vy,out[4]=a[4]*vx,out[5]=a[5]*vy,out},/**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
invert:function(out,a){var aa=a[0],ac=a[2],atx=a[4],ab=a[1],ad=a[3],aty=a[5],det=aa*ad-ab*ac;return det?(det=1/det,out[0]=ad*det,out[1]=-ab*det,out[2]=-ac*det,out[3]=aa*det,out[4]=(ac*aty-ad*atx)*det,out[5]=(ab*atx-aa*aty)*det,out):null}};module.exports=matrix},/* 18 */
/***/
function(module,exports,__webpack_require__){module.exports={getItemStyle:__webpack_require__(11)([["fill","color"],["stroke","borderColor"],["lineWidth","borderWidth"],["opacity"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"]])}},/* 19 */
/***/
function(module,exports,__webpack_require__){function getDependencies(componentType){var deps=[];
// Ensure main type
return zrUtil.each(ComponentModel.getClassesByMainType(componentType),function(Clazz){arrayPush.apply(deps,Clazz.prototype.dependencies||[])}),zrUtil.map(deps,function(type){return clazzUtil.parseClassType(type).main})}/**
	 * Component model
	 *
	 * @module echarts/model/Component
	 */
var Model=__webpack_require__(8),zrUtil=__webpack_require__(3),arrayPush=Array.prototype.push,componentUtil=__webpack_require__(20),clazzUtil=__webpack_require__(9),layout=__webpack_require__(21),ComponentModel=Model.extend({type:"component",/**
	         * @readOnly
	         * @type {string}
	         */
id:"",/**
	         * @readOnly
	         */
name:"",/**
	         * @readOnly
	         * @type {string}
	         */
mainType:"",/**
	         * @readOnly
	         * @type {string}
	         */
subType:"",/**
	         * @readOnly
	         * @type {number}
	         */
componentIndex:0,/**
	         * @type {Object}
	         * @protected
	         */
defaultOption:null,/**
	         * @type {module:echarts/model/Global}
	         * @readOnly
	         */
ecModel:null,/**
	         * key: componentType
	         * value:  Component model list, can not be null.
	         * @type {Object.<string, Array.<module:echarts/model/Model>>}
	         * @readOnly
	         */
dependentModels:[],/**
	         * @type {string}
	         * @readOnly
	         */
uid:null,/**
	         * Support merge layout params.
	         * Only support 'box' now (left/right/top/bottom/width/height).
	         * @type {string|Object} Object can be {ignoreSize: true}
	         * @readOnly
	         */
layoutMode:null,init:function(option,parentModel,ecModel,extraOpt){this.mergeDefaultAndTheme(this.option,this.ecModel)},mergeDefaultAndTheme:function(option,ecModel){var layoutMode=this.layoutMode,inputPositionParams=layoutMode?layout.getLayoutParams(option):{},themeModel=ecModel.getTheme();zrUtil.merge(option,themeModel.get(this.mainType)),zrUtil.merge(option,this.getDefaultOption()),layoutMode&&layout.mergeLayoutParam(option,inputPositionParams,layoutMode)},mergeOption:function(option){zrUtil.merge(this.option,option,!0);var layoutMode=this.layoutMode;layoutMode&&layout.mergeLayoutParam(this.option,option,layoutMode)},
// Hooker after init or mergeOption
optionUpdated:function(ecModel){},getDefaultOption:function(){if(!this.hasOwnProperty("__defaultOption")){for(var optList=[],Class=this.constructor;Class;){var opt=Class.prototype.defaultOption;opt&&optList.push(opt),Class=Class.superClass}for(var defaultOption={},i=optList.length-1;i>=0;i--)defaultOption=zrUtil.merge(defaultOption,optList[i],!0);this.__defaultOption=defaultOption}return this.__defaultOption}});
// Reset ComponentModel.extend, add preConstruct.
clazzUtil.enableClassExtend(ComponentModel,function(option,parentModel,ecModel,extraOpt){
// Set dependentModels, componentIndex, name, id, mainType, subType.
zrUtil.extend(this,extraOpt),this.uid=componentUtil.getUID("componentModel")}),
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
clazzUtil.enableClassManagement(ComponentModel,{registerWhenExtend:!0}),componentUtil.enableSubTypeDefaulter(ComponentModel),
// Add capability of ComponentModel.topologicalTravel.
componentUtil.enableTopologicalTravel(ComponentModel,getDependencies),zrUtil.mixin(ComponentModel,__webpack_require__(22)),module.exports=ComponentModel},/* 20 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),clazz=__webpack_require__(9),parseClassType=clazz.parseClassType,base=0,componentUtil={},DELIMITER="_";/**
	     * @public
	     * @param {string} type
	     * @return {string}
	     */
componentUtil.getUID=function(type){
// Considering the case of crossing js context,
// use Math.random to make id as unique as possible.
return[type||"",base++,Math.random()].join(DELIMITER)},/**
	     * @inner
	     */
componentUtil.enableSubTypeDefaulter=function(entity){var subTypeDefaulters={};return entity.registerSubTypeDefaulter=function(componentType,defaulter){componentType=parseClassType(componentType),subTypeDefaulters[componentType.main]=defaulter},entity.determineSubType=function(componentType,option){var type=option.type;if(!type){var componentTypeMain=parseClassType(componentType).main;entity.hasSubTypes(componentType)&&subTypeDefaulters[componentTypeMain]&&(type=subTypeDefaulters[componentTypeMain](option))}return type},entity},/**
	     * Topological travel on Activity Network (Activity On Vertices).
	     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
	     *
	     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
	     *
	     * If there is circle dependencey, Error will be thrown.
	     *
	     */
componentUtil.enableTopologicalTravel=function(entity,dependencyGetter){/**
	         * DepndencyGraph: {Object}
	         * key: conponentType,
	         * value: {
	         *     successor: [conponentTypes...],
	         *     originalDeps: [conponentTypes...],
	         *     entryCount: {number}
	         * }
	         */
function makeDepndencyGraph(fullNameList){var graph={},noEntryList=[];return zrUtil.each(fullNameList,function(name){var thisItem=createDependencyGraphItem(graph,name),originalDeps=thisItem.originalDeps=dependencyGetter(name),availableDeps=getAvailableDependencies(originalDeps,fullNameList);thisItem.entryCount=availableDeps.length,0===thisItem.entryCount&&noEntryList.push(name),zrUtil.each(availableDeps,function(dependentName){zrUtil.indexOf(thisItem.predecessor,dependentName)<0&&thisItem.predecessor.push(dependentName);var thatItem=createDependencyGraphItem(graph,dependentName);zrUtil.indexOf(thatItem.successor,dependentName)<0&&thatItem.successor.push(name)})}),{graph:graph,noEntryList:noEntryList}}function createDependencyGraphItem(graph,name){return graph[name]||(graph[name]={predecessor:[],successor:[]}),graph[name]}function getAvailableDependencies(originalDeps,fullNameList){var availableDeps=[];return zrUtil.each(originalDeps,function(dep){zrUtil.indexOf(fullNameList,dep)>=0&&availableDeps.push(dep)}),availableDeps}/**
	         * @public
	         * @param {Array.<string>} targetNameList Target Component type list.
	         *                                           Can be ['aa', 'bb', 'aa.xx']
	         * @param {Array.<string>} fullNameList By which we can build dependency graph.
	         * @param {Function} callback Params: componentType, dependencies.
	         * @param {Object} context Scope of callback.
	         */
entity.topologicalTravel=function(targetNameList,fullNameList,callback,context){function removeEdge(succComponentType){graph[succComponentType].entryCount--,0===graph[succComponentType].entryCount&&stack.push(succComponentType)}
// Consider this case: legend depends on series, and we call
// chart.setOption({series: [...]}), where only series is in option.
// If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
// not be called, but only sereis.mergeOption is called. Thus legend
// have no chance to update its local record about series (like which
// name of series is available in legend).
function removeEdgeAndAdd(succComponentType){targetNameSet[succComponentType]=!0,removeEdge(succComponentType)}if(targetNameList.length){var result=makeDepndencyGraph(fullNameList),graph=result.graph,stack=result.noEntryList,targetNameSet={};for(zrUtil.each(targetNameList,function(name){targetNameSet[name]=!0});stack.length;){var currComponentType=stack.pop(),currVertex=graph[currComponentType],isInTargetNameSet=!!targetNameSet[currComponentType];isInTargetNameSet&&(callback.call(context,currComponentType,currVertex.originalDeps.slice()),delete targetNameSet[currComponentType]),zrUtil.each(currVertex.successor,isInTargetNameSet?removeEdgeAndAdd:removeEdge)}zrUtil.each(targetNameSet,function(){throw new Error("Circle dependency may exists")})}}},module.exports=componentUtil},/* 21 */
/***/
function(module,exports,__webpack_require__){"use strict";function boxLayout(orient,group,gap,maxWidth,maxHeight){var x=0,y=0;null==maxWidth&&(maxWidth=1/0),null==maxHeight&&(maxHeight=1/0);var currentLineMaxSize=0;group.eachChild(function(child,idx){var nextX,nextY,position=child.position,rect=child.getBoundingRect(),nextChild=group.childAt(idx+1),nextChildRect=nextChild&&nextChild.getBoundingRect();if("horizontal"===orient){var moveX=rect.width+(nextChildRect?-nextChildRect.x+rect.x:0);nextX=x+moveX,
// Wrap when width exceeds maxWidth or meet a `newline` group
nextX>maxWidth||child.newline?(x=0,nextX=moveX,y+=currentLineMaxSize+gap,currentLineMaxSize=rect.height):currentLineMaxSize=Math.max(currentLineMaxSize,rect.height)}else{var moveY=rect.height+(nextChildRect?-nextChildRect.y+rect.y:0);nextY=y+moveY,
// Wrap when width exceeds maxHeight or meet a `newline` group
nextY>maxHeight||child.newline?(x+=currentLineMaxSize+gap,y=0,nextY=moveY,currentLineMaxSize=rect.width):currentLineMaxSize=Math.max(currentLineMaxSize,rect.width)}child.newline||(position[0]=x,position[1]=y,"horizontal"===orient?x=nextX+gap:y=nextY+gap)})}
// Layout helpers for each component positioning
var zrUtil=__webpack_require__(3),BoundingRect=__webpack_require__(15),numberUtil=__webpack_require__(7),formatUtil=__webpack_require__(6),parsePercent=numberUtil.parsePercent,each=zrUtil.each,layout={},LOCATION_PARAMS=["left","right","top","bottom","width","height"];/**
	     * VBox or HBox layouting
	     * @param {string} orient
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
layout.box=boxLayout,/**
	     * VBox layouting
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
layout.vbox=zrUtil.curry(boxLayout,"vertical"),/**
	     * HBox layouting
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
layout.hbox=zrUtil.curry(boxLayout,"horizontal"),/**
	     * If x or x2 is not specified or 'center' 'left' 'right',
	     * the width would be as long as possible.
	     * If y or y2 is not specified or 'middle' 'top' 'bottom',
	     * the height would be as long as possible.
	     *
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.x]
	     * @param {number|string} [positionInfo.y]
	     * @param {number|string} [positionInfo.x2]
	     * @param {number|string} [positionInfo.y2]
	     * @param {Object} containerRect
	     * @param {string|number} margin
	     * @return {Object} {width, height}
	     */
layout.getAvailableSize=function(positionInfo,containerRect,margin){var containerWidth=containerRect.width,containerHeight=containerRect.height,x=parsePercent(positionInfo.x,containerWidth),y=parsePercent(positionInfo.y,containerHeight),x2=parsePercent(positionInfo.x2,containerWidth),y2=parsePercent(positionInfo.y2,containerHeight);return(isNaN(x)||isNaN(parseFloat(positionInfo.x)))&&(x=0),(isNaN(x2)||isNaN(parseFloat(positionInfo.x2)))&&(x2=containerWidth),(isNaN(y)||isNaN(parseFloat(positionInfo.y)))&&(y=0),(isNaN(y2)||isNaN(parseFloat(positionInfo.y2)))&&(y2=containerHeight),margin=formatUtil.normalizeCssArray(margin||0),{width:Math.max(x2-x-margin[1]-margin[3],0),height:Math.max(y2-y-margin[0]-margin[2],0)}},/**
	     * Parse position info.
	     *
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.left]
	     * @param {number|string} [positionInfo.top]
	     * @param {number|string} [positionInfo.right]
	     * @param {number|string} [positionInfo.bottom]
	     * @param {number|string} [positionInfo.width]
	     * @param {number|string} [positionInfo.height]
	     * @param {number|string} [positionInfo.aspect] Aspect is width / height
	     * @param {Object} containerRect
	     * @param {string|number} [margin]
	     *
	     * @return {module:zrender/core/BoundingRect}
	     */
layout.getLayoutRect=function(positionInfo,containerRect,margin){margin=formatUtil.normalizeCssArray(margin||0);var containerWidth=containerRect.width,containerHeight=containerRect.height,left=parsePercent(positionInfo.left,containerWidth),top=parsePercent(positionInfo.top,containerHeight),right=parsePercent(positionInfo.right,containerWidth),bottom=parsePercent(positionInfo.bottom,containerHeight),width=parsePercent(positionInfo.width,containerWidth),height=parsePercent(positionInfo.height,containerHeight),verticalMargin=margin[2]+margin[0],horizontalMargin=margin[1]+margin[3],aspect=positionInfo.aspect;
// Align left and top
switch(
// If width is not specified, calculate width from left and right
isNaN(width)&&(width=containerWidth-right-horizontalMargin-left),isNaN(height)&&(height=containerHeight-bottom-verticalMargin-top),
// If width and height are not given
// 1. Graph should not exceeds the container
// 2. Aspect must be keeped
// 3. Graph should take the space as more as possible
isNaN(width)&&isNaN(height)&&(aspect>containerWidth/containerHeight?width=.8*containerWidth:height=.8*containerHeight),null!=aspect&&(
// Calculate width or height with given aspect
isNaN(width)&&(width=aspect*height),isNaN(height)&&(height=width/aspect)),
// If left is not specified, calculate left from right and width
isNaN(left)&&(left=containerWidth-right-width-horizontalMargin),isNaN(top)&&(top=containerHeight-bottom-height-verticalMargin),positionInfo.left||positionInfo.right){case"center":left=containerWidth/2-width/2-margin[3];break;case"right":left=containerWidth-width-horizontalMargin}switch(positionInfo.top||positionInfo.bottom){case"middle":case"center":top=containerHeight/2-height/2-margin[0];break;case"bottom":top=containerHeight-height-verticalMargin}left=left||0,top=top||0,isNaN(width)&&(width=containerWidth-left-(right||0)),isNaN(height)&&(height=containerHeight-top-(bottom||0));var rect=new BoundingRect(left+margin[3],top+margin[0],width,height);return rect.margin=margin,rect},/**
	     * Position group of component in viewport
	     *  Group position is specified by either
	     *  {left, top}, {right, bottom}
	     *  If all properties exists, right and bottom will be igonred.
	     *
	     * @param {module:zrender/container/Group} group
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.left]
	     * @param {number|string} [positionInfo.top]
	     * @param {number|string} [positionInfo.right]
	     * @param {number|string} [positionInfo.bottom]
	     * @param {Object} containerRect
	     * @param {string|number} margin
	     */
layout.positionGroup=function(group,positionInfo,containerRect,margin){var groupRect=group.getBoundingRect();positionInfo=zrUtil.extend(zrUtil.clone(positionInfo),{width:groupRect.width,height:groupRect.height}),positionInfo=layout.getLayoutRect(positionInfo,containerRect,margin),group.position=[positionInfo.x-groupRect.x,positionInfo.y-groupRect.y]},/**
	     * Consider Case:
	     * When defulat option has {left: 0, width: 100}, and we set {right: 0}
	     * through setOption or media query, using normal zrUtil.merge will cause
	     * {right: 0} does not take effect.
	     *
	     * @example
	     * ComponentModel.extend({
	     *     init: function () {
	     *         ...
	     *         var inputPositionParams = layout.getLayoutParams(option);
	     *         this.mergeOption(inputPositionParams);
	     *     },
	     *     mergeOption: function (newOption) {
	     *         newOption && zrUtil.merge(thisOption, newOption, true);
	     *         layout.mergeLayoutParam(thisOption, newOption);
	     *     }
	     * });
	     *
	     * @param {Object} targetOption
	     * @param {Object} newOption
	     * @param {Object|string} [opt]
	     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.
	     */
layout.mergeLayoutParam=function(targetOption,newOption,opt){function merge(names){var newParams={},newValueCount=0,merged={},mergedValueCount=0,enoughParamNumber=opt.ignoreSize?1:2;
// Case: newOption: {width: ..., right: ...},
// or targetOption: {right: ...} and newOption: {width: ...},
// There is no conflict when merged only has params count
// little than enoughParamNumber.
if(each(names,function(name){merged[name]=targetOption[name]}),each(names,function(name){
// Consider case: newOption.width is null, which is
// set by user for removing width setting.
hasProp(newOption,name)&&(newParams[name]=merged[name]=newOption[name]),hasValue(newParams,name)&&newValueCount++,hasValue(merged,name)&&mergedValueCount++}),mergedValueCount!==enoughParamNumber&&newValueCount){if(newValueCount>=enoughParamNumber)return newParams;
// Chose another param from targetOption by priority.
// When 'ignoreSize', enoughParamNumber is 1 and those will not happen.
for(var i=0;i<names.length;i++){var name=names[i];if(!hasProp(newParams,name)&&hasProp(targetOption,name)){newParams[name]=targetOption[name];break}}return newParams}return merged}function hasProp(obj,name){return obj.hasOwnProperty(name)}function hasValue(obj,name){return null!=obj[name]&&"auto"!==obj[name]}function copy(names,target,source){each(names,function(name){target[name]=source[name]})}!zrUtil.isObject(opt)&&(opt={});var hNames=["width","left","right"],vNames=["height","top","bottom"],hResult=merge(hNames),vResult=merge(vNames);copy(hNames,targetOption,hResult),copy(vNames,targetOption,vResult)},/**
	     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
	     * @param {Object} source
	     * @return {Object} Result contains those props.
	     */
layout.getLayoutParams=function(source){return layout.copyLayoutParams({},source)},/**
	     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
	     * @param {Object} source
	     * @return {Object} Result contains those props.
	     */
layout.copyLayoutParams=function(target,source){return source&&target&&each(LOCATION_PARAMS,function(name){source.hasOwnProperty(name)&&(target[name]=source[name])}),target},module.exports=layout},/* 22 */
/***/
function(module,exports){module.exports={getBoxLayoutParams:function(){return{left:this.get("left"),top:this.get("top"),right:this.get("right"),bottom:this.get("bottom"),width:this.get("width"),height:this.get("height")}}}},/* 23 */
/***/
function(module,exports){var platform="";
// Navigator not exists in node
"undefined"!=typeof navigator&&(platform=navigator.platform||""),module.exports={
// 全图默认背景
// backgroundColor: 'rgba(0,0,0,0)',
// https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
// color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
// 浅色
// color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
// color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
// 深色
color:["#c23531","#2f4554","#61a0a8","#d48265","#91c7ae","#749f83","#ca8622","#bda29a","#6e7074","#546570","#c4ccd3"],
// 默认需要 Grid 配置项
grid:{},
// 主题，主题
textStyle:{
// color: '#000',
// decoration: 'none',
// PENDING
fontFamily:platform.match(/^Win/)?"Microsoft YaHei":"sans-serif",
// fontFamily: 'Arial, Verdana, sans-serif',
fontSize:12,fontStyle:"normal",fontWeight:"normal"},
// 主题，默认标志图形类型列表
// symbolList: [
//     'circle', 'rectangle', 'triangle', 'diamond',
//     'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'
// ],
animation:!0,// 过渡动画是否开启
animationThreshold:2e3,// 动画元素阀值，产生的图形原素超过2000不出动画
animationDuration:1e3,// 过渡动画参数：进入
animationDurationUpdate:300,// 过渡动画参数：更新
animationEasing:"exponentialOut",//BounceOut
animationEasingUpdate:"cubicOut"}},/* 24 */
/***/
function(module,exports,__webpack_require__){"use strict";function ExtensionAPI(chartInstance){zrUtil.each(echartsAPIList,function(name){this[name]=zrUtil.bind(chartInstance[name],chartInstance)},this)}var zrUtil=__webpack_require__(3),echartsAPIList=["getDom","getZr","getWidth","getHeight","dispatchAction","on","off","getDataURL","getConnectedDataURL","getModel","getOption"];module.exports=ExtensionAPI},/* 25 */
/***/
function(module,exports){"use strict";function CoordinateSystemManager(){this._coordinateSystems=[]}
// var zrUtil = require('zrender/lib/core/util');
var coordinateSystemCreators={};CoordinateSystemManager.prototype={constructor:CoordinateSystemManager,create:function(ecModel,api){var coordinateSystems=[];for(var type in coordinateSystemCreators){var list=coordinateSystemCreators[type].create(ecModel,api);list&&(coordinateSystems=coordinateSystems.concat(list))}this._coordinateSystems=coordinateSystems},update:function(ecModel,api){for(var coordinateSystems=this._coordinateSystems,i=0;i<coordinateSystems.length;i++)
// FIXME MUST have
coordinateSystems[i].update&&coordinateSystems[i].update(ecModel,api)}},CoordinateSystemManager.register=function(type,coordinateSystemCreator){coordinateSystemCreators[type]=coordinateSystemCreator},CoordinateSystemManager.get=function(type){return coordinateSystemCreators[type]},module.exports=CoordinateSystemManager},/* 26 */
/***/
function(module,exports,__webpack_require__){/**
	     * TERM EXPLANATIONS:
	     *
	     * [option]:
	     *
	     *     An object that contains definitions of components. For example:
	     *     var option = {
	     *         title: {...},
	     *         legend: {...},
	     *         visualMap: {...},
	     *         series: [
	     *             {data: [...]},
	     *             {data: [...]},
	     *             ...
	     *         ]
	     *     };
	     *
	     * [rawOption]:
	     *
	     *     An object input to echarts.setOption. 'rawOption' may be an
	     *     'option', or may be an object contains multi-options. For example:
	     *     var option = {
	     *         baseOption: {
	     *             title: {...},
	     *             legend: {...},
	     *             series: [
	     *                 {data: [...]},
	     *                 {data: [...]},
	     *                 ...
	     *             ]
	     *         },
	     *         timeline: {...},
	     *         options: [
	     *             {title: {...}, series: {data: [...]}},
	     *             {title: {...}, series: {data: [...]}},
	     *             ...
	     *         ],
	     *         media: [
	     *             {
	     *                 query: {maxWidth: 320},
	     *                 option: {series: {x: 20}, visualMap: {show: false}}
	     *             },
	     *             {
	     *                 query: {minWidth: 320, maxWidth: 720},
	     *                 option: {series: {x: 500}, visualMap: {show: true}}
	     *             },
	     *             {
	     *                 option: {series: {x: 1200}, visualMap: {show: true}}
	     *             }
	     *         ]
	     *     };
	     *
	     * @alias module:echarts/model/OptionManager
	     * @param {module:echarts/ExtensionAPI} api
	     */
function OptionManager(api){/**
	         * @private
	         * @type {module:echarts/ExtensionAPI}
	         */
this._api=api,/**
	         * @private
	         * @type {Array.<number>}
	         */
this._timelineOptions=[],/**
	         * @private
	         * @type {Array.<Object>}
	         */
this._mediaList=[],/**
	         * @private
	         * @type {Object}
	         */
this._mediaDefault,/**
	         * -1, means default.
	         * empty means no media.
	         * @private
	         * @type {Array.<number>}
	         */
this._currentMediaIndices=[],/**
	         * @private
	         * @type {Object}
	         */
this._optionBackup,/**
	         * @private
	         * @type {Object}
	         */
this._newOptionBackup}function parseRawOption(rawOption,optionPreprocessorFuncs){var mediaDefault,baseOption,timelineOptions=[],mediaList=[],timelineOpt=rawOption.timeline;
// For media query
if(rawOption.baseOption&&(baseOption=rawOption.baseOption),
// For timeline
(timelineOpt||rawOption.options)&&(baseOption=baseOption||{},timelineOptions=(rawOption.options||[]).slice()),rawOption.media){baseOption=baseOption||{};var media=rawOption.media;each(media,function(singleMedia){singleMedia&&singleMedia.option&&(singleMedia.query?mediaList.push(singleMedia):mediaDefault||(
// Use the first media default.
mediaDefault=singleMedia))})}
// For normal option
// Set timelineOpt to baseOption in ec3,
// which is convenient for merge option.
// Preprocess.
return baseOption||(baseOption=rawOption),baseOption.timeline||(baseOption.timeline=timelineOpt),each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList,function(media){return media.option})),function(option){each(optionPreprocessorFuncs,function(preProcess){preProcess(option)})}),{baseOption:baseOption,timelineOptions:timelineOptions,mediaDefault:mediaDefault,mediaList:mediaList}}/**
	     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
	     * Support: width, height, aspectRatio
	     * Can use max or min as prefix.
	     */
function applyMediaQuery(query,ecWidth,ecHeight){var realMap={width:ecWidth,height:ecHeight,aspectratio:ecWidth/ecHeight},applicatable=!0;return zrUtil.each(query,function(value,attr){var matched=attr.match(QUERY_REG);if(matched&&matched[1]&&matched[2]){var operator=matched[1],realAttr=matched[2].toLowerCase();compare(realMap[realAttr],value,operator)||(applicatable=!1)}}),applicatable}function compare(real,expect,operator){return"min"===operator?real>=expect:"max"===operator?expect>=real:real===expect}function indicesEquals(indices1,indices2){
// indices is always order by asc and has only finite number.
return indices1.join(",")===indices2.join(",")}/**
	     * Consider case:
	     * `chart.setOption(opt1);`
	     * Then user do some interaction like dataZoom, dataView changing.
	     * `chart.setOption(opt2);`
	     * Then user press 'reset button' in toolbox.
	     *
	     * After doing that all of the interaction effects should be reset, the
	     * chart should be the same as the result of invoke
	     * `chart.setOption(opt1); chart.setOption(opt2);`.
	     *
	     * Although it is not able ensure that
	     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
	     * `chart.setOption(merge(opt1, opt2));` exactly,
	     * this might be the only simple way to implement that feature.
	     *
	     * MEMO: We've considered some other approaches:
	     * 1. Each model handle its self restoration but not uniform treatment.
	     *     (Too complex in logic and error-prone)
	     * 2. Use a shadow ecModel. (Performace expensive)
	     */
function mergeOption(oldOption,newOption){newOption=newOption||{},each(newOption,function(newCptOpt,mainType){if(null!=newCptOpt){var oldCptOpt=oldOption[mainType];if(ComponentModel.hasClass(mainType)){newCptOpt=modelUtil.normalizeToArray(newCptOpt),oldCptOpt=modelUtil.normalizeToArray(oldCptOpt);var mapResult=modelUtil.mappingToExists(oldCptOpt,newCptOpt);oldOption[mainType]=map(mapResult,function(item){return item.option&&item.exist?merge(item.exist,item.option,!0):item.exist||item.option})}else oldOption[mainType]=merge(oldCptOpt,newCptOpt,!0)}})}/**
	 * ECharts option manager
	 *
	 * @module {echarts/model/OptionManager}
	 */
var zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),ComponentModel=__webpack_require__(19),each=zrUtil.each,clone=zrUtil.clone,map=zrUtil.map,merge=zrUtil.merge,QUERY_REG=/^(min|max)?(.+)$/;
// timeline.notMerge is not supported in ec3. Firstly there is rearly
// case that notMerge is needed. Secondly supporting 'notMerge' requires
// rawOption cloned and backuped when timeline changed, which does no
// good to performance. What's more, that both timeline and setOption
// method supply 'notMerge' brings complex and some problems.
// Consider this case:
// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
OptionManager.prototype={constructor:OptionManager,/**
	         * @public
	         * @param {Object} rawOption Raw option.
	         * @param {module:echarts/model/Global} ecModel
	         * @param {Array.<Function>} optionPreprocessorFuncs
	         * @return {Object} Init option
	         */
setOption:function(rawOption,optionPreprocessorFuncs){rawOption=clone(rawOption,!0);
// FIXME
// 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。
var oldOptionBackup=this._optionBackup,newOptionBackup=this._newOptionBackup=parseRawOption.call(this,rawOption,optionPreprocessorFuncs);
// For setOption at second time (using merge mode);
oldOptionBackup?(
// Only baseOption can be merged.
mergeOption(oldOptionBackup.baseOption,newOptionBackup.baseOption),newOptionBackup.timelineOptions.length&&(oldOptionBackup.timelineOptions=newOptionBackup.timelineOptions),newOptionBackup.mediaList.length&&(oldOptionBackup.mediaList=newOptionBackup.mediaList),newOptionBackup.mediaDefault&&(oldOptionBackup.mediaDefault=newOptionBackup.mediaDefault)):this._optionBackup=newOptionBackup},/**
	         * @param {boolean} isRecreate
	         * @return {Object}
	         */
mountOption:function(isRecreate){var optionBackup=isRecreate?this._optionBackup:this._newOptionBackup;
// FIXME
// 如果没有reset功能则不clone。
return this._timelineOptions=map(optionBackup.timelineOptions,clone),this._mediaList=map(optionBackup.mediaList,clone),this._mediaDefault=clone(optionBackup.mediaDefault),this._currentMediaIndices=[],clone(optionBackup.baseOption)},/**
	         * @param {module:echarts/model/Global} ecModel
	         * @return {Object}
	         */
getTimelineOption:function(ecModel){var option,timelineOptions=this._timelineOptions;if(timelineOptions.length){
// getTimelineOption can only be called after ecModel inited,
// so we can get currentIndex from timelineModel.
var timelineModel=ecModel.getComponent("timeline");timelineModel&&(option=clone(timelineOptions[timelineModel.getCurrentIndex()],!0))}return option},/**
	         * @param {module:echarts/model/Global} ecModel
	         * @return {Array.<Object>}
	         */
getMediaOption:function(ecModel){var ecWidth=this._api.getWidth(),ecHeight=this._api.getHeight(),mediaList=this._mediaList,mediaDefault=this._mediaDefault,indices=[],result=[];
// No media defined.
if(!mediaList.length&&!mediaDefault)return result;
// Multi media may be applied, the latter defined media has higher priority.
for(var i=0,len=mediaList.length;len>i;i++)applyMediaQuery(mediaList[i].query,ecWidth,ecHeight)&&indices.push(i);
// FIXME
// 是否mediaDefault应该强制用户设置，否则可能修改不能回归。
// Otherwise return nothing.
return!indices.length&&mediaDefault&&(indices=[-1]),indices.length&&!indicesEquals(indices,this._currentMediaIndices)&&(result=map(indices,function(index){return clone(-1===index?mediaDefault.option:mediaList[index].option)})),this._currentMediaIndices=indices,result}},module.exports=OptionManager},/* 27 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),formatUtil=__webpack_require__(6),modelUtil=__webpack_require__(5),ComponentModel=__webpack_require__(19),encodeHTML=formatUtil.encodeHTML,addCommas=formatUtil.addCommas,SeriesModel=ComponentModel.extend({type:"series.__base__",/**
	         * @readOnly
	         */
seriesIndex:0,
// coodinateSystem will be injected in the echarts/CoordinateSystem
coordinateSystem:null,/**
	         * @type {Object}
	         * @protected
	         */
defaultOption:null,/**
	         * Data provided for legend
	         * @type {Function}
	         */
// PENDING
legendDataProvider:null,init:function(option,parentModel,ecModel,extraOpt){/**
	             * @type {number}
	             * @readOnly
	             */
this.seriesIndex=this.componentIndex,this.mergeDefaultAndTheme(option,ecModel),/**
	             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
	             * @private
	             */
this._dataBeforeProcessed=this.getInitialData(option,ecModel),
// When using module:echarts/data/Tree or module:echarts/data/Graph,
// cloneShallow will cause this._data.graph.data pointing to new data list.
// Wo we make this._dataBeforeProcessed first, and then make this._data.
this._data=this._dataBeforeProcessed.cloneShallow()},/**
	         * Util for merge default and theme to option
	         * @param  {Object} option
	         * @param  {module:echarts/model/Global} ecModel
	         */
mergeDefaultAndTheme:function(option,ecModel){zrUtil.merge(option,ecModel.getTheme().get(this.subType)),zrUtil.merge(option,this.getDefaultOption()),
// Default label emphasis `position` and `show`
modelUtil.defaultEmphasis(option.label,["position","show","textStyle","distance","formatter"]);for(var data=option.data||[],i=0;i<data.length;i++)data[i]&&data[i].label&&modelUtil.defaultEmphasis(data[i].label,["position","show","textStyle","distance","formatter"])},mergeOption:function(newSeriesOption,ecModel){newSeriesOption=zrUtil.merge(this.option,newSeriesOption,!0);var data=this.getInitialData(newSeriesOption,ecModel);
// TODO Merge data?
data&&(this._data=data,this._dataBeforeProcessed=data.cloneShallow())},/**
	         * Init a data structure from data related option in series
	         * Must be overwritten
	         */
getInitialData:function(){},/**
	         * @return {module:echarts/data/List}
	         */
getData:function(){return this._data},/**
	         * @param {module:echarts/data/List} data
	         */
setData:function(data){this._data=data},/**
	         * Get data before processed
	         * @return {module:echarts/data/List}
	         */
getRawData:function(){return this._dataBeforeProcessed},/**
	         * Get raw data array given by user
	         * @return {Array.<Object>}
	         */
getRawDataArray:function(){return this.option.data},/**
	         * Coord dimension to data dimension.
	         *
	         * By default the result is the same as dimensions of series data.
	         * But some series dimensions are different from coord dimensions (i.e.
	         * candlestick and boxplot). Override this method to handle those cases.
	         *
	         * Coord dimension to data dimension can be one-to-many
	         *
	         * @param {string} coordDim
	         * @return {Array.<string>} dimensions on the axis.
	         */
coordDimToDataDim:function(coordDim){return[coordDim]},/**
	         * Convert data dimension to coord dimension.
	         *
	         * @param {string|number} dataDim
	         * @return {string}
	         */
dataDimToCoordDim:function(dataDim){return dataDim},/**
	         * Get base axis if has coordinate system and has axis.
	         * By default use coordSys.getBaseAxis();
	         * Can be overrided for some chart.
	         * @return {type} description
	         */
getBaseAxis:function(){var coordSys=this.coordinateSystem;return coordSys&&coordSys.getBaseAxis&&coordSys.getBaseAxis()},
// FIXME
/**
	         * Default tooltip formatter
	         *
	         * @param {number} dataIndex
	         * @param {boolean} [multipleSeries=false]
	         */
formatTooltip:function(dataIndex,multipleSeries){var data=this._data,value=this.getRawValue(dataIndex),formattedValue=zrUtil.isArray(value)?zrUtil.map(value,addCommas).join(", "):addCommas(value),name=data.getName(dataIndex),color=data.getItemVisual(dataIndex,"color"),colorEl='<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:'+color+'"></span>';return multipleSeries?colorEl+encodeHTML(this.name)+" : "+formattedValue:encodeHTML(this.name)+"<br />"+colorEl+(name?encodeHTML(name)+" : "+formattedValue:formattedValue)},restoreData:function(){this._data=this._dataBeforeProcessed.cloneShallow()}});zrUtil.mixin(SeriesModel,modelUtil.dataFormatMixin),module.exports=SeriesModel},/* 28 */
/***/
function(module,exports,__webpack_require__){var Group=__webpack_require__(29),componentUtil=__webpack_require__(20),clazzUtil=__webpack_require__(9),Component=function(){/**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
this.group=new Group,/**
	         * @type {string}
	         * @readOnly
	         */
this.uid=componentUtil.getUID("viewComponent")};Component.prototype={constructor:Component,init:function(ecModel,api){},render:function(componentModel,ecModel,api,payload){},dispose:function(){}};var componentProto=Component.prototype;componentProto.updateView=componentProto.updateLayout=componentProto.updateVisual=function(seriesModel,ecModel,api,payload){},
// Enable Component.extend.
clazzUtil.enableClassExtend(Component),
// Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
clazzUtil.enableClassManagement(Component,{registerWhenExtend:!0}),module.exports=Component},/* 29 */
/***/
function(module,exports,__webpack_require__){/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
var zrUtil=__webpack_require__(3),Element=__webpack_require__(30),BoundingRect=__webpack_require__(15),Group=function(opts){opts=opts||{},Element.call(this,opts);for(var key in opts)this[key]=opts[key];this._children=[],this.__storage=null,this.__dirty=!0};Group.prototype={constructor:Group,/**
	         * @type {string}
	         */
type:"group",/**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
silent:!1,/**
	         * @return {Array.<module:zrender/Element>}
	         */
children:function(){return this._children.slice()},/**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
childAt:function(idx){return this._children[idx]},/**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
childOfName:function(name){for(var children=this._children,i=0;i<children.length;i++)if(children[i].name===name)return children[i]},/**
	         * @return {number}
	         */
childCount:function(){return this._children.length},/**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
add:function(child){return child&&child!==this&&child.parent!==this&&(this._children.push(child),this._doAdd(child)),this},/**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
addBefore:function(child,nextSibling){if(child&&child!==this&&child.parent!==this&&nextSibling&&nextSibling.parent===this){var children=this._children,idx=children.indexOf(nextSibling);idx>=0&&(children.splice(idx,0,child),this._doAdd(child))}return this},_doAdd:function(child){child.parent&&child.parent.remove(child),child.parent=this;var storage=this.__storage,zr=this.__zr;storage&&storage!==child.__storage&&(storage.addToMap(child),child instanceof Group&&child.addChildrenToStorage(storage)),zr&&zr.refresh()},/**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
remove:function(child){var zr=this.__zr,storage=this.__storage,children=this._children,idx=zrUtil.indexOf(children,child);return 0>idx?this:(children.splice(idx,1),child.parent=null,storage&&(storage.delFromMap(child.id),child instanceof Group&&child.delChildrenFromStorage(storage)),zr&&zr.refresh(),this)},/**
	         * 移除所有子节点
	         */
removeAll:function(){var child,i,children=this._children,storage=this.__storage;for(i=0;i<children.length;i++)child=children[i],storage&&(storage.delFromMap(child.id),child instanceof Group&&child.delChildrenFromStorage(storage)),child.parent=null;return children.length=0,this},/**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
eachChild:function(cb,context){for(var children=this._children,i=0;i<children.length;i++){var child=children[i];cb.call(context,child,i)}return this},/**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
traverse:function(cb,context){for(var i=0;i<this._children.length;i++){var child=this._children[i];cb.call(context,child),"group"===child.type&&child.traverse(cb,context)}return this},addChildrenToStorage:function(storage){for(var i=0;i<this._children.length;i++){var child=this._children[i];storage.addToMap(child),child instanceof Group&&child.addChildrenToStorage(storage)}},delChildrenFromStorage:function(storage){for(var i=0;i<this._children.length;i++){var child=this._children[i];storage.delFromMap(child.id),child instanceof Group&&child.delChildrenFromStorage(storage)}},dirty:function(){return this.__dirty=!0,this.__zr&&this.__zr.refresh(),this},/**
	         * @return {module:zrender/core/BoundingRect}
	         */
getBoundingRect:function(includeChildren){for(var rect=null,tmpRect=new BoundingRect(0,0,0,0),children=includeChildren||this._children,tmpMat=[],i=0;i<children.length;i++){var child=children[i];if(!child.ignore&&!child.invisible){var childRect=child.getBoundingRect(),transform=child.getLocalTransform(tmpMat);transform?(tmpRect.copy(childRect),tmpRect.applyTransform(transform),rect=rect||tmpRect.clone(),rect.union(tmpRect)):(rect=rect||childRect.clone(),rect.union(childRect))}}return rect||tmpRect}},zrUtil.inherits(Group,Element),module.exports=Group},/* 30 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * @module zrender/Element
	 */
var guid=__webpack_require__(31),Eventful=__webpack_require__(32),Transformable=__webpack_require__(33),Animatable=__webpack_require__(34),zrUtil=__webpack_require__(3),Element=function(opts){Transformable.call(this,opts),Eventful.call(this,opts),Animatable.call(this,opts),/**
	         * 画布元素ID
	         * @type {string}
	         */
this.id=opts.id||guid()};Element.prototype={/**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
type:"element",/**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
name:"",/**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
__zr:null,/**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
ignore:!1,/**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
clipPath:null,/**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
drift:function(dx,dy){switch(this.draggable){case"horizontal":dy=0;break;case"vertical":dx=0}var m=this.transform;m||(m=this.transform=[1,0,0,1,0,0]),m[4]+=dx,m[5]+=dy,this.decomposeTransform(),this.dirty()},/**
	         * Hook before update
	         */
beforeUpdate:function(){},/**
	         * Hook after update
	         */
afterUpdate:function(){},/**
	         * Update each frame
	         */
update:function(){this.updateTransform()},/**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
traverse:function(cb,context){},/**
	         * @protected
	         */
attrKV:function(key,value){if("position"===key||"scale"===key||"origin"===key){
// Copy the array
if(value){var target=this[key];target||(target=this[key]=[]),target[0]=value[0],target[1]=value[1]}}else this[key]=value},/**
	         * Hide the element
	         */
hide:function(){this.ignore=!0,this.__zr&&this.__zr.refresh()},/**
	         * Show the element
	         */
show:function(){this.ignore=!1,this.__zr&&this.__zr.refresh()},/**
	         * @param {string|Object} key
	         * @param {*} value
	         */
attr:function(key,value){if("string"==typeof key)this.attrKV(key,value);else if(zrUtil.isObject(key))for(var name in key)key.hasOwnProperty(name)&&this.attrKV(name,key[name]);return this.dirty(),this},/**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
setClipPath:function(clipPath){var zr=this.__zr;zr&&clipPath.addSelfToZr(zr),
// Remove previous clip path
this.clipPath&&this.clipPath!==clipPath&&this.removeClipPath(),this.clipPath=clipPath,clipPath.__zr=zr,clipPath.__clipTarget=this,this.dirty()},/**
	         */
removeClipPath:function(){var clipPath=this.clipPath;clipPath&&(clipPath.__zr&&clipPath.removeSelfFromZr(clipPath.__zr),clipPath.__zr=null,clipPath.__clipTarget=null,this.clipPath=null,this.dirty())},/**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
addSelfToZr:function(zr){this.__zr=zr;
// 添加动画
var animators=this.animators;if(animators)for(var i=0;i<animators.length;i++)zr.animation.addAnimator(animators[i]);this.clipPath&&this.clipPath.addSelfToZr(zr)},/**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
removeSelfFromZr:function(zr){this.__zr=null;
// 移除动画
var animators=this.animators;if(animators)for(var i=0;i<animators.length;i++)zr.animation.removeAnimator(animators[i]);this.clipPath&&this.clipPath.removeSelfFromZr(zr)}},zrUtil.mixin(Element,Animatable),zrUtil.mixin(Element,Transformable),zrUtil.mixin(Element,Eventful),module.exports=Element},/* 31 */
/***/
function(module,exports){/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
var idStart=2311;module.exports=function(){return"zr_"+idStart++}},/* 32 */
/***/
function(module,exports,__webpack_require__){/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
var arrySlice=Array.prototype.slice,zrUtil=__webpack_require__(3),indexOf=zrUtil.indexOf,Eventful=function(){this._$handlers={}};Eventful.prototype={constructor:Eventful,/**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
one:function(event,handler,context){var _h=this._$handlers;return handler&&event?(_h[event]||(_h[event]=[]),indexOf(_h[event],event)>=0?this:(_h[event].push({h:handler,one:!0,ctx:context||this}),this)):this},/**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
on:function(event,handler,context){var _h=this._$handlers;return handler&&event?(_h[event]||(_h[event]=[]),_h[event].push({h:handler,one:!1,ctx:context||this}),this):this},/**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
isSilent:function(event){var _h=this._$handlers;return _h[event]&&_h[event].length},/**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
off:function(event,handler){var _h=this._$handlers;if(!event)return this._$handlers={},this;if(handler){if(_h[event]){for(var newList=[],i=0,l=_h[event].length;l>i;i++)_h[event][i].h!=handler&&newList.push(_h[event][i]);_h[event]=newList}_h[event]&&0===_h[event].length&&delete _h[event]}else delete _h[event];return this},/**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
trigger:function(type){if(this._$handlers[type]){var args=arguments,argLen=args.length;argLen>3&&(args=arrySlice.call(args,1));for(var _h=this._$handlers[type],len=_h.length,i=0;len>i;){
// Optimize advise from backbone
switch(argLen){case 1:_h[i].h.call(_h[i].ctx);break;case 2:_h[i].h.call(_h[i].ctx,args[1]);break;case 3:_h[i].h.call(_h[i].ctx,args[1],args[2]);break;default:
// have more than 2 given arguments
_h[i].h.apply(_h[i].ctx,args)}_h[i].one?(_h.splice(i,1),len--):i++}}return this},/**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
triggerWithContext:function(type){if(this._$handlers[type]){var args=arguments,argLen=args.length;argLen>4&&(args=arrySlice.call(args,1,args.length-1));for(var ctx=args[args.length-1],_h=this._$handlers[type],len=_h.length,i=0;len>i;){
// Optimize advise from backbone
switch(argLen){case 1:_h[i].h.call(ctx);break;case 2:_h[i].h.call(ctx,args[1]);break;case 3:_h[i].h.call(ctx,args[1],args[2]);break;default:
// have more than 2 given arguments
_h[i].h.apply(ctx,args)}_h[i].one?(_h.splice(i,1),len--):i++}}return this}},
// 对象可以通过 onxxxx 绑定事件
/**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
/**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
module.exports=Eventful},/* 33 */
/***/
function(module,exports,__webpack_require__){"use strict";function isNotAroundZero(val){return val>EPSILON||-EPSILON>val}/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
var matrix=__webpack_require__(17),vector=__webpack_require__(16),mIdentity=matrix.identity,EPSILON=5e-5,Transformable=function(opts){opts=opts||{},opts.position||(this.position=[0,0]),null==opts.rotation&&(this.rotation=0),opts.scale||(this.scale=[1,1]),this.origin=this.origin||null},transformableProto=Transformable.prototype;transformableProto.transform=null,/**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
transformableProto.needLocalTransform=function(){return isNotAroundZero(this.rotation)||isNotAroundZero(this.position[0])||isNotAroundZero(this.position[1])||isNotAroundZero(this.scale[0]-1)||isNotAroundZero(this.scale[1]-1)},transformableProto.updateTransform=function(){var parent=this.parent,parentHasTransform=parent&&parent.transform,needLocalTransform=this.needLocalTransform(),m=this.transform;
// 应用父节点变换
// 保存这个变换矩阵
return needLocalTransform||parentHasTransform?(m=m||matrix.create(),needLocalTransform?this.getLocalTransform(m):mIdentity(m),parentHasTransform&&(needLocalTransform?matrix.mul(m,parent.transform,m):matrix.copy(m,parent.transform)),this.transform=m,this.invTransform=this.invTransform||matrix.create(),void matrix.invert(this.invTransform,m)):void(m&&mIdentity(m))},transformableProto.getLocalTransform=function(m){m=m||[],mIdentity(m);var origin=this.origin,scale=this.scale,rotation=this.rotation,position=this.position;
// Translate to origin
// Translate back from origin
return origin&&(m[4]-=origin[0],m[5]-=origin[1]),matrix.scale(m,m,scale),rotation&&matrix.rotate(m,m,rotation),origin&&(m[4]+=origin[0],m[5]+=origin[1]),m[4]+=position[0],m[5]+=position[1],m},/**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
transformableProto.setTransform=function(ctx){var m=this.transform;m&&ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5])};var tmpTransform=[];/**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
transformableProto.decomposeTransform=function(){if(this.transform){var parent=this.parent,m=this.transform;parent&&parent.transform&&(
// Get local transform and decompose them to position, scale, rotation
matrix.mul(tmpTransform,parent.invTransform,m),m=tmpTransform);var sx=m[0]*m[0]+m[1]*m[1],sy=m[2]*m[2]+m[3]*m[3],position=this.position,scale=this.scale;isNotAroundZero(sx-1)&&(sx=Math.sqrt(sx)),isNotAroundZero(sy-1)&&(sy=Math.sqrt(sy)),m[0]<0&&(sx=-sx),m[3]<0&&(sy=-sy),position[0]=m[4],position[1]=m[5],scale[0]=sx,scale[1]=sy,this.rotation=Math.atan2(-m[1]/sy,m[0]/sx)}},/**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
transformableProto.transformCoordToLocal=function(x,y){var v2=[x,y],invTransform=this.invTransform;return invTransform&&vector.applyTransform(v2,v2,invTransform),v2},/**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
transformableProto.transformCoordToGlobal=function(x,y){var v2=[x,y],transform=this.transform;return transform&&vector.applyTransform(v2,v2,transform),v2},module.exports=Transformable},/* 34 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * @module zrender/mixin/Animatable
	 */
var Animator=__webpack_require__(35),util=__webpack_require__(3),isString=util.isString,isFunction=util.isFunction,isObject=util.isObject,log=__webpack_require__(39),Animatable=function(){/**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
this.animators=[]};Animatable.prototype={constructor:Animatable,/**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
animate:function(path,loop){var target,animatingShape=!1,el=this,zr=this.__zr;if(path){var pathSplitted=path.split("."),prop=el;
// If animating shape
animatingShape="shape"===pathSplitted[0];for(var i=0,l=pathSplitted.length;l>i;i++)prop&&(prop=prop[pathSplitted[i]]);prop&&(target=prop)}else target=el;if(!target)return void log('Property "'+path+'" is not existed in element '+el.id);var animators=el.animators,animator=new Animator(target,loop);
// If animate after added to the zrender
return animator.during(function(target){el.dirty(animatingShape)}).done(function(){
// FIXME Animator will not be removed if use `Animator#stop` to stop animation
animators.splice(util.indexOf(animators,animator),1)}),animators.push(animator),zr&&zr.animation.addAnimator(animator),animator},/**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
stopAnimation:function(forwardToLast){for(var animators=this.animators,len=animators.length,i=0;len>i;i++)animators[i].stop(forwardToLast);return animators.length=0,this},/**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
// TODO Return animation key
animateTo:function(target,time,delay,easing,callback){function done(){count--,count||callback&&callback()}
// animateTo(target, time, easing, callback);
isString(delay)?(callback=easing,easing=delay,delay=0):isFunction(easing)?(callback=easing,easing="linear",delay=0):isFunction(delay)?(callback=delay,delay=0):isFunction(time)?(callback=time,time=500):time||(time=500),
// Stop all previous animations
this.stopAnimation(),this._animateToShallow("",this,target,time,delay,easing,callback);
// Animators may be removed immediately after start
// if there is nothing to animate
var animators=this.animators.slice(),count=animators.length;
// No animators. This should be checked before animators[i].start(),
// because 'done' may be executed immediately if no need to animate.
count||callback&&callback();
// Start after all animators created
// Incase any animator is done immediately when all animation properties are not changed
for(var i=0;i<animators.length;i++)animators[i].done(done).start(easing)},/**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
_animateToShallow:function(path,source,target,time,delay){var objShallow={},propertyCount=0;for(var name in target)if(null!=source[name])isObject(target[name])&&!util.isArrayLike(target[name])?this._animateToShallow(path?path+"."+name:name,source[name],target[name],time,delay):(objShallow[name]=target[name],propertyCount++);else if(null!=target[name])
// Attr directly if not has property
// FIXME, if some property not needed for element ?
if(path){// Shape or style
var props={};props[path]={},props[path][name]=target[name],this.attr(props)}else this.attr(name,target[name]);return propertyCount>0&&this.animate(path,!1).when(null==time?500:time,objShallow).delay(delay||0),this}},module.exports=Animatable},/* 35 */
/***/
function(module,exports,__webpack_require__){function defaultGetter(target,key){return target[key]}function defaultSetter(target,key,value){target[key]=value}/**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
function interpolateNumber(p0,p1,percent){return(p1-p0)*percent+p0}/**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
function interpolateString(p0,p1,percent){return percent>.5?p1:p0}/**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
function interpolateArray(p0,p1,percent,out,arrDim){var len=p0.length;if(1==arrDim)for(var i=0;len>i;i++)out[i]=interpolateNumber(p0[i],p1[i],percent);else for(var len2=p0[0].length,i=0;len>i;i++)for(var j=0;len2>j;j++)out[i][j]=interpolateNumber(p0[i][j],p1[i][j],percent)}function fillArr(arr0,arr1,arrDim){var arr0Len=arr0.length,arr1Len=arr1.length;if(arr0Len!==arr1Len){
// FIXME Not work for TypedArray
var isPreviousLarger=arr0Len>arr1Len;if(isPreviousLarger)
// Cut the previous
arr0.length=arr1Len;else
// Fill the previous
for(var i=arr0Len;arr1Len>i;i++)arr0.push(1===arrDim?arr1[i]:arraySlice.call(arr1[i]))}}/**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
function isArraySame(arr0,arr1,arrDim){if(arr0===arr1)return!0;var len=arr0.length;if(len!==arr1.length)return!1;if(1===arrDim){for(var i=0;len>i;i++)if(arr0[i]!==arr1[i])return!1}else for(var len2=arr0[0].length,i=0;len>i;i++)for(var j=0;len2>j;j++)if(arr0[i][j]!==arr1[i][j])return!1;return!0}/**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
function catmullRomInterpolateArray(p0,p1,p2,p3,t,t2,t3,out,arrDim){var len=p0.length;if(1==arrDim)for(var i=0;len>i;i++)out[i]=catmullRomInterpolate(p0[i],p1[i],p2[i],p3[i],t,t2,t3);else for(var len2=p0[0].length,i=0;len>i;i++)for(var j=0;len2>j;j++)out[i][j]=catmullRomInterpolate(p0[i][j],p1[i][j],p2[i][j],p3[i][j],t,t2,t3)}/**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
function catmullRomInterpolate(p0,p1,p2,p3,t,t2,t3){var v0=.5*(p2-p0),v1=.5*(p3-p1);return(2*(p1-p2)+v0+v1)*t3+(-3*(p1-p2)-2*v0-v1)*t2+v0*t+p1}function cloneValue(value){if(isArrayLike(value)){var len=value.length;if(isArrayLike(value[0])){for(var ret=[],i=0;len>i;i++)ret.push(arraySlice.call(value[i]));return ret}return arraySlice.call(value)}return value}function rgba2String(rgba){return rgba[0]=Math.floor(rgba[0]),rgba[1]=Math.floor(rgba[1]),rgba[2]=Math.floor(rgba[2]),"rgba("+rgba.join(",")+")"}function createTrackClip(animator,easing,oneTrackDone,keyframes,propName){var getter=animator._getter,setter=animator._setter,useSpline="spline"===easing,trackLen=keyframes.length;if(trackLen){
// Guess data type
var trackMaxTime,firstVal=keyframes[0].value,isValueArray=isArrayLike(firstVal),isValueColor=!1,isValueString=!1,arrDim=isValueArray&&isArrayLike(firstVal[0])?2:1;
// Sort keyframe as ascending
keyframes.sort(function(a,b){return a.time-b.time}),trackMaxTime=keyframes[trackLen-1].time;for(var kfPercents=[],kfValues=[],prevValue=keyframes[0].value,isAllValueEqual=!0,i=0;trackLen>i;i++){kfPercents.push(keyframes[i].time/trackMaxTime);
// Assume value is a color when it is a string
var value=keyframes[i].value;
// Try converting a string to a color array
if(
// Check if value is equal, deep check if value is array
isValueArray&&isArraySame(value,prevValue,arrDim)||!isValueArray&&value===prevValue||(isAllValueEqual=!1),prevValue=value,"string"==typeof value){var colorArray=color.parse(value);colorArray?(value=colorArray,isValueColor=!0):isValueString=!0}kfValues.push(value)}if(!isAllValueEqual){if(isValueArray){
// Polyfill array
for(var lastValue=kfValues[trackLen-1],i=0;trackLen-1>i;i++)fillArr(kfValues[i],lastValue,arrDim);fillArr(getter(animator._target,propName),lastValue,arrDim)}
// Cache the key of last frame to speed up when
// animation playback is sequency
var start,w,p0,p1,p2,p3,lastFrame=0,lastFramePercent=0;if(isValueColor)var rgba=[0,0,0,0];var onframe=function(target,percent){
// Find the range keyframes
// kf1-----kf2---------current--------kf3
// find kf2 and kf3 and do interpolation
var frame;if(lastFramePercent>percent){for(start=Math.min(lastFrame+1,trackLen-1),frame=start;frame>=0&&!(kfPercents[frame]<=percent);frame--);frame=Math.min(frame,trackLen-2)}else{for(frame=lastFrame;trackLen>frame&&!(kfPercents[frame]>percent);frame++);frame=Math.min(frame-1,trackLen-2)}lastFrame=frame,lastFramePercent=percent;var range=kfPercents[frame+1]-kfPercents[frame];if(0!==range)if(w=(percent-kfPercents[frame])/range,useSpline)if(p1=kfValues[frame],p0=kfValues[0===frame?frame:frame-1],p2=kfValues[frame>trackLen-2?trackLen-1:frame+1],p3=kfValues[frame>trackLen-3?trackLen-1:frame+2],isValueArray)catmullRomInterpolateArray(p0,p1,p2,p3,w,w*w,w*w*w,getter(target,propName),arrDim);else{var value;if(isValueColor)value=catmullRomInterpolateArray(p0,p1,p2,p3,w,w*w,w*w*w,rgba,1),value=rgba2String(rgba);else{if(isValueString)
// String is step(0.5)
return interpolateString(p1,p2,w);value=catmullRomInterpolate(p0,p1,p2,p3,w,w*w,w*w*w)}setter(target,propName,value)}else if(isValueArray)interpolateArray(kfValues[frame],kfValues[frame+1],w,getter(target,propName),arrDim);else{var value;if(isValueColor)interpolateArray(kfValues[frame],kfValues[frame+1],w,rgba,1),value=rgba2String(rgba);else{if(isValueString)
// String is step(0.5)
return interpolateString(kfValues[frame],kfValues[frame+1],w);value=interpolateNumber(kfValues[frame],kfValues[frame+1],w)}setter(target,propName,value)}},clip=new Clip({target:animator._target,life:trackMaxTime,loop:animator._loop,delay:animator._delay,onframe:onframe,ondestroy:oneTrackDone});return easing&&"spline"!==easing&&(clip.easing=easing),clip}}}/**
	 * @module echarts/animation/Animator
	 */
var Clip=__webpack_require__(36),color=__webpack_require__(38),util=__webpack_require__(3),isArrayLike=util.isArrayLike,arraySlice=Array.prototype.slice,Animator=function(target,loop,getter,setter){this._tracks={},this._target=target,this._loop=loop||!1,this._getter=getter||defaultGetter,this._setter=setter||defaultSetter,this._clipCount=0,this._delay=0,this._doneList=[],this._onframeList=[],this._clipList=[]};Animator.prototype={/**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
when:function(time,props){var tracks=this._tracks;for(var propName in props){if(!tracks[propName]){tracks[propName]=[];
// Invalid value
var value=this._getter(this._target,propName);if(null==value)
// zrLog('Invalid property ' + propName);
continue;
// If time is 0
//  Then props is given initialize value
// Else
//  Initialize value from current prop value
0!==time&&tracks[propName].push({time:0,value:cloneValue(value)})}tracks[propName].push({time:time,value:props[propName]})}return this},/**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
during:function(callback){return this._onframeList.push(callback),this},_doneCallback:function(){
// Clear all tracks
this._tracks={},
// Clear all clips
this._clipList.length=0;for(var doneList=this._doneList,len=doneList.length,i=0;len>i;i++)doneList[i].call(this)},/**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
start:function(easing){var lastClip,self=this,clipCount=0,oneTrackDone=function(){clipCount--,clipCount||self._doneCallback()};for(var propName in this._tracks){var clip=createTrackClip(this,easing,oneTrackDone,this._tracks[propName],propName);clip&&(this._clipList.push(clip),clipCount++,
// If start after added to animation
this.animation&&this.animation.addClip(clip),lastClip=clip)}
// Add during callback on the last clip
if(lastClip){var oldOnFrame=lastClip.onframe;lastClip.onframe=function(target,percent){oldOnFrame(target,percent);for(var i=0;i<self._onframeList.length;i++)self._onframeList[i](target,percent)}}return clipCount||this._doneCallback(),this},/**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
stop:function(forwardToLast){for(var clipList=this._clipList,animation=this.animation,i=0;i<clipList.length;i++){var clip=clipList[i];forwardToLast&&
// Move to last frame before stop
clip.onframe(this._target,1),animation&&animation.removeClip(clip)}clipList.length=0},/**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
delay:function(time){return this._delay=time,this},/**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
done:function(cb){return cb&&this._doneList.push(cb),this},/**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
getClips:function(){return this._clipList}},module.exports=Animator},/* 36 */
/***/
function(module,exports,__webpack_require__){function Clip(options){this._target=options.target,
// 生命周期
this._life=options.life||1e3,
// 延时
this._delay=options.delay||0,
// 开始时间
// this._startTime = new Date().getTime() + this._delay;// 单位毫秒
this._initialized=!1,
// 是否循环
this.loop=null==options.loop?!1:options.loop,this.gap=options.gap||0,this.easing=options.easing||"Linear",this.onframe=options.onframe,this.ondestroy=options.ondestroy,this.onrestart=options.onrestart}/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
var easingFuncs=__webpack_require__(37);Clip.prototype={constructor:Clip,step:function(time){
// Set startTime on first step, or _startTime may has milleseconds different between clips
// PENDING
this._initialized||(this._startTime=(new Date).getTime()+this._delay,this._initialized=!0);var percent=(time-this._startTime)/this._life;
// 还没开始
if(!(0>percent)){percent=Math.min(percent,1);var easing=this.easing,easingFunc="string"==typeof easing?easingFuncs[easing]:easing,schedule="function"==typeof easingFunc?easingFunc(percent):percent;
// 结束
// 结束
// 动画完成将这个控制器标识为待删除
// 在Animation.update中进行批量删除
return this.fire("frame",schedule),1==percent?this.loop?(this.restart(),"restart"):(this._needsRemove=!0,"destroy"):null}},restart:function(){var time=(new Date).getTime(),remainder=(time-this._startTime)%this._life;this._startTime=(new Date).getTime()-remainder+this.gap,this._needsRemove=!1},fire:function(eventType,arg){eventType="on"+eventType,this[eventType]&&this[eventType](this._target,arg)}},module.exports=Clip},/* 37 */
/***/
function(module,exports){/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
var easing={/**
	        * @param {number} k
	        * @return {number}
	        */
linear:function(k){return k},/**
	        * @param {number} k
	        * @return {number}
	        */
quadraticIn:function(k){return k*k},/**
	        * @param {number} k
	        * @return {number}
	        */
quadraticOut:function(k){return k*(2-k)},/**
	        * @param {number} k
	        * @return {number}
	        */
quadraticInOut:function(k){return(k*=2)<1?.5*k*k:-.5*(--k*(k-2)-1)},
// 三次方的缓动（t^3）
/**
	        * @param {number} k
	        * @return {number}
	        */
cubicIn:function(k){return k*k*k},/**
	        * @param {number} k
	        * @return {number}
	        */
cubicOut:function(k){return--k*k*k+1},/**
	        * @param {number} k
	        * @return {number}
	        */
cubicInOut:function(k){return(k*=2)<1?.5*k*k*k:.5*((k-=2)*k*k+2)},
// 四次方的缓动（t^4）
/**
	        * @param {number} k
	        * @return {number}
	        */
quarticIn:function(k){return k*k*k*k},/**
	        * @param {number} k
	        * @return {number}
	        */
quarticOut:function(k){return 1- --k*k*k*k},/**
	        * @param {number} k
	        * @return {number}
	        */
quarticInOut:function(k){return(k*=2)<1?.5*k*k*k*k:-.5*((k-=2)*k*k*k-2)},
// 五次方的缓动（t^5）
/**
	        * @param {number} k
	        * @return {number}
	        */
quinticIn:function(k){return k*k*k*k*k},/**
	        * @param {number} k
	        * @return {number}
	        */
quinticOut:function(k){return--k*k*k*k*k+1},/**
	        * @param {number} k
	        * @return {number}
	        */
quinticInOut:function(k){return(k*=2)<1?.5*k*k*k*k*k:.5*((k-=2)*k*k*k*k+2)},
// 正弦曲线的缓动（sin(t)）
/**
	        * @param {number} k
	        * @return {number}
	        */
sinusoidalIn:function(k){return 1-Math.cos(k*Math.PI/2)},/**
	        * @param {number} k
	        * @return {number}
	        */
sinusoidalOut:function(k){return Math.sin(k*Math.PI/2)},/**
	        * @param {number} k
	        * @return {number}
	        */
sinusoidalInOut:function(k){return.5*(1-Math.cos(Math.PI*k))},
// 指数曲线的缓动（2^t）
/**
	        * @param {number} k
	        * @return {number}
	        */
exponentialIn:function(k){return 0===k?0:Math.pow(1024,k-1)},/**
	        * @param {number} k
	        * @return {number}
	        */
exponentialOut:function(k){return 1===k?1:1-Math.pow(2,-10*k)},/**
	        * @param {number} k
	        * @return {number}
	        */
exponentialInOut:function(k){return 0===k?0:1===k?1:(k*=2)<1?.5*Math.pow(1024,k-1):.5*(-Math.pow(2,-10*(k-1))+2)},
// 圆形曲线的缓动（sqrt(1-t^2)）
/**
	        * @param {number} k
	        * @return {number}
	        */
circularIn:function(k){return 1-Math.sqrt(1-k*k)},/**
	        * @param {number} k
	        * @return {number}
	        */
circularOut:function(k){return Math.sqrt(1- --k*k)},/**
	        * @param {number} k
	        * @return {number}
	        */
circularInOut:function(k){return(k*=2)<1?-.5*(Math.sqrt(1-k*k)-1):.5*(Math.sqrt(1-(k-=2)*k)+1)},
// 创建类似于弹簧在停止前来回振荡的动画
/**
	        * @param {number} k
	        * @return {number}
	        */
elasticIn:function(k){var s,a=.1,p=.4;return 0===k?0:1===k?1:(!a||1>a?(a=1,s=p/4):s=p*Math.asin(1/a)/(2*Math.PI),-(a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p)))},/**
	        * @param {number} k
	        * @return {number}
	        */
elasticOut:function(k){var s,a=.1,p=.4;return 0===k?0:1===k?1:(!a||1>a?(a=1,s=p/4):s=p*Math.asin(1/a)/(2*Math.PI),a*Math.pow(2,-10*k)*Math.sin((k-s)*(2*Math.PI)/p)+1)},/**
	        * @param {number} k
	        * @return {number}
	        */
elasticInOut:function(k){var s,a=.1,p=.4;return 0===k?0:1===k?1:(!a||1>a?(a=1,s=p/4):s=p*Math.asin(1/a)/(2*Math.PI),(k*=2)<1?-.5*(a*Math.pow(2,10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p)):a*Math.pow(2,-10*(k-=1))*Math.sin((k-s)*(2*Math.PI)/p)*.5+1)},
// 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
/**
	        * @param {number} k
	        * @return {number}
	        */
backIn:function(k){var s=1.70158;return k*k*((s+1)*k-s)},/**
	        * @param {number} k
	        * @return {number}
	        */
backOut:function(k){var s=1.70158;return--k*k*((s+1)*k+s)+1},/**
	        * @param {number} k
	        * @return {number}
	        */
backInOut:function(k){var s=2.5949095;return(k*=2)<1?.5*(k*k*((s+1)*k-s)):.5*((k-=2)*k*((s+1)*k+s)+2)},
// 创建弹跳效果
/**
	        * @param {number} k
	        * @return {number}
	        */
bounceIn:function(k){return 1-easing.bounceOut(1-k)},/**
	        * @param {number} k
	        * @return {number}
	        */
bounceOut:function(k){return 1/2.75>k?7.5625*k*k:2/2.75>k?7.5625*(k-=1.5/2.75)*k+.75:2.5/2.75>k?7.5625*(k-=2.25/2.75)*k+.9375:7.5625*(k-=2.625/2.75)*k+.984375},/**
	        * @param {number} k
	        * @return {number}
	        */
bounceInOut:function(k){return.5>k?.5*easing.bounceIn(2*k):.5*easing.bounceOut(2*k-1)+.5}};module.exports=easing},/* 38 */
/***/
function(module,exports){function clampCssByte(i){// Seems to be what Chrome does (vs truncation).
// Clamp to integer 0 .. 255.
return i=Math.round(i),0>i?0:i>255?255:i}function clampCssAngle(i){// Seems to be what Chrome does (vs truncation).
// Clamp to integer 0 .. 360.
return i=Math.round(i),0>i?0:i>360?360:i}function clampCssFloat(f){// Clamp to float 0.0 .. 1.0.
return 0>f?0:f>1?1:f}function parseCssInt(str){// int or percentage.
// int or percentage.
return clampCssByte(str.length&&"%"===str.charAt(str.length-1)?parseFloat(str)/100*255:parseInt(str,10))}function parseCssFloat(str){// float or percentage.
// float or percentage.
return clampCssFloat(str.length&&"%"===str.charAt(str.length-1)?parseFloat(str)/100:parseFloat(str))}function cssHueToRgb(m1,m2,h){return 0>h?h+=1:h>1&&(h-=1),1>6*h?m1+(m2-m1)*h*6:1>2*h?m2:2>3*h?m1+(m2-m1)*(2/3-h)*6:m1}function lerp(a,b,p){return a+(b-a)*p}/**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
function parse(colorStr){if(colorStr){
// colorStr may be not string
colorStr+="";
// Remove all whitespace, not compliant, but should just be more accepting.
var str=colorStr.replace(/ /g,"").toLowerCase();
// Color keywords (and transparent) lookup.
if(str in kCSSColorTable)return kCSSColorTable[str].slice();
// #abc and #abc123 syntax.
if("#"!==str.charAt(0)){var op=str.indexOf("("),ep=str.indexOf(")");if(-1!==op&&ep+1===str.length){var fname=str.substr(0,op),params=str.substr(op+1,ep-(op+1)).split(","),alpha=1;// To allow case fallthrough.
switch(fname){case"rgba":if(4!==params.length)return;alpha=parseCssFloat(params.pop());// jshint ignore:line
// Fall through.
case"rgb":if(3!==params.length)return;return[parseCssInt(params[0]),parseCssInt(params[1]),parseCssInt(params[2]),alpha];case"hsla":if(4!==params.length)return;return params[3]=parseCssFloat(params[3]),hsla2rgba(params);case"hsl":if(3!==params.length)return;return hsla2rgba(params);default:return}}}else{if(4===str.length){var iv=parseInt(str.substr(1),16);// TODO(deanm): Stricter parsing.
if(!(iv>=0&&4095>=iv))return;return[(3840&iv)>>4|(3840&iv)>>8,240&iv|(240&iv)>>4,15&iv|(15&iv)<<4,1]}if(7===str.length){var iv=parseInt(str.substr(1),16);// TODO(deanm): Stricter parsing.
if(!(iv>=0&&16777215>=iv))return;return[(16711680&iv)>>16,(65280&iv)>>8,255&iv,1]}}}}/**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
function hsla2rgba(hsla){var h=(parseFloat(hsla[0])%360+360)%360/360,s=parseCssFloat(hsla[1]),l=parseCssFloat(hsla[2]),m2=.5>=l?l*(s+1):l+s-l*s,m1=2*l-m2,rgba=[clampCssByte(255*cssHueToRgb(m1,m2,h+1/3)),clampCssByte(255*cssHueToRgb(m1,m2,h)),clampCssByte(255*cssHueToRgb(m1,m2,h-1/3))];return 4===hsla.length&&(rgba[3]=hsla[3]),rgba}/**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
function rgba2hsla(rgba){if(rgba){
// RGB from 0 to 255
var H,S,R=rgba[0]/255,G=rgba[1]/255,B=rgba[2]/255,vMin=Math.min(R,G,B),vMax=Math.max(R,G,B),delta=vMax-vMin,L=(vMax+vMin)/2;
// HSL results from 0 to 1
if(0===delta)H=0,S=0;else{S=.5>L?delta/(vMax+vMin):delta/(2-vMax-vMin);var deltaR=((vMax-R)/6+delta/2)/delta,deltaG=((vMax-G)/6+delta/2)/delta,deltaB=((vMax-B)/6+delta/2)/delta;R===vMax?H=deltaB-deltaG:G===vMax?H=1/3+deltaR-deltaB:B===vMax&&(H=2/3+deltaG-deltaR),0>H&&(H+=1),H>1&&(H-=1)}var hsla=[360*H,S,L];return null!=rgba[3]&&hsla.push(rgba[3]),hsla}}/**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
function lift(color,level){var colorArr=parse(color);if(colorArr){for(var i=0;3>i;i++)0>level?colorArr[i]=colorArr[i]*(1-level)|0:colorArr[i]=(255-colorArr[i])*level+colorArr[i]|0;return stringify(colorArr,4===colorArr.length?"rgba":"rgb")}}/**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
function toHex(color,level){var colorArr=parse(color);return colorArr?((1<<24)+(colorArr[0]<<16)+(colorArr[1]<<8)+ +colorArr[2]).toString(16).slice(1):void 0}/**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
function fastMapToColor(normalizedValue,colors,out){if(colors&&colors.length&&normalizedValue>=0&&1>=normalizedValue){out=out||[0,0,0,0];var value=normalizedValue*(colors.length-1),leftIndex=Math.floor(value),rightIndex=Math.ceil(value),leftColor=colors[leftIndex],rightColor=colors[rightIndex],dv=value-leftIndex;return out[0]=clampCssByte(lerp(leftColor[0],rightColor[0],dv)),out[1]=clampCssByte(lerp(leftColor[1],rightColor[1],dv)),out[2]=clampCssByte(lerp(leftColor[2],rightColor[2],dv)),out[3]=clampCssByte(lerp(leftColor[3],rightColor[3],dv)),out}}/**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
function mapToColor(normalizedValue,colors,fullOutput){if(colors&&colors.length&&normalizedValue>=0&&1>=normalizedValue){var value=normalizedValue*(colors.length-1),leftIndex=Math.floor(value),rightIndex=Math.ceil(value),leftColor=parse(colors[leftIndex]),rightColor=parse(colors[rightIndex]),dv=value-leftIndex,color=stringify([clampCssByte(lerp(leftColor[0],rightColor[0],dv)),clampCssByte(lerp(leftColor[1],rightColor[1],dv)),clampCssByte(lerp(leftColor[2],rightColor[2],dv)),clampCssFloat(lerp(leftColor[3],rightColor[3],dv))],"rgba");return fullOutput?{color:color,leftIndex:leftIndex,rightIndex:rightIndex,value:value}:color}}/**
	     * @param {Array<number>} interval  Array length === 2,
	     *                                  each item is normalized value ([0, 1]).
	     * @param {Array.<string>} colors Color list.
	     * @return {Array.<Object>} colors corresponding to the interval,
	     *                          each item is {color: 'xxx', offset: ...}
	     *                          where offset is between 0 and 1.
	     * @memberOf module:zrender/util/color
	     */
function mapIntervalToColor(interval,colors){if(!(2!==interval.length||interval[1]<interval[0])){for(var info0=mapToColor(interval[0],colors,!0),info1=mapToColor(interval[1],colors,!0),result=[{color:info0.color,offset:0}],during=info1.value-info0.value,start=Math.max(info0.value,info0.rightIndex),end=Math.min(info1.value,info1.leftIndex),i=start;during>0&&end>=i;i++)result.push({color:colors[i],offset:(i-info0.value)/during});return result.push({color:info1.color,offset:1}),result}}/**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
function modifyHSL(color,h,s,l){return color=parse(color),color?(color=rgba2hsla(color),null!=h&&(color[0]=clampCssAngle(h)),null!=s&&(color[1]=parseCssFloat(s)),null!=l&&(color[2]=parseCssFloat(l)),stringify(hsla2rgba(color),"rgba")):void 0}/**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
function modifyAlpha(color,alpha){return color=parse(color),color&&null!=alpha?(color[3]=clampCssFloat(alpha),stringify(color,"rgba")):void 0}/**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
function stringify(arrColor,type){return"rgb"!==type&&"hsv"!==type&&"hsl"!==type||(arrColor=arrColor.slice(0,3)),type+"("+arrColor.join(",")+")"}/**
	 * @module zrender/tool/color
	 */
var kCSSColorTable={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};module.exports={parse:parse,lift:lift,toHex:toHex,fastMapToColor:fastMapToColor,mapToColor:mapToColor,mapIntervalToColor:mapIntervalToColor,modifyHSL:modifyHSL,modifyAlpha:modifyAlpha,stringify:stringify}},/* 39 */
/***/
function(module,exports,__webpack_require__){var config=__webpack_require__(40);/**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
module.exports=function(){if(0!==config.debugMode)if(1==config.debugMode)for(var k in arguments)throw new Error(arguments[k]);else if(config.debugMode>1)for(var k in arguments)console.log(arguments[k])}},/* 40 */
/***/
function(module,exports){var dpr=1;
// If in browser environment
"undefined"!=typeof window&&(dpr=Math.max(window.devicePixelRatio||1,1));/**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
var config={/**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
debugMode:0,
// retina 屏幕优化
devicePixelRatio:dpr};module.exports=config},/* 41 */
/***/
function(module,exports,__webpack_require__){function Chart(){/**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
this.group=new Group,/**
	         * @type {string}
	         * @readOnly
	         */
this.uid=componentUtil.getUID("viewChart")}/**
	     * Set state of single element
	     * @param  {module:zrender/Element} el
	     * @param  {string} state
	     */
function elSetState(el,state){if(el&&(el.trigger(state),"group"===el.type))for(var i=0;i<el.childCount();i++)elSetState(el.childAt(i),state)}/**
	     * @param  {module:echarts/data/List} data
	     * @param  {Object} payload
	     * @param  {string} state 'normal'|'emphasis'
	     * @inner
	     */
function toggleHighlight(data,payload,state){if(null!=payload.dataIndex){var el=data.getItemGraphicEl(payload.dataIndex);elSetState(el,state)}else if(payload.name){var dataIndex=data.indexOfName(payload.name),el=data.getItemGraphicEl(dataIndex);elSetState(el,state)}else data.eachItemGraphicEl(function(el){elSetState(el,state)})}var Group=__webpack_require__(29),componentUtil=__webpack_require__(20),clazzUtil=__webpack_require__(9);Chart.prototype={type:"chart",/**
	         * Init the chart
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
init:function(ecModel,api){},/**
	         * Render the chart
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
render:function(seriesModel,ecModel,api,payload){},/**
	         * Highlight series or specified data item
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
highlight:function(seriesModel,ecModel,api,payload){toggleHighlight(seriesModel.getData(),payload,"emphasis")},/**
	         * Downplay series or specified data item
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
downplay:function(seriesModel,ecModel,api,payload){toggleHighlight(seriesModel.getData(),payload,"normal")},/**
	         * Remove self
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
remove:function(ecModel,api){this.group.removeAll()},/**
	         * Dispose self
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
dispose:function(){}};var chartProto=Chart.prototype;chartProto.updateView=chartProto.updateLayout=chartProto.updateVisual=function(seriesModel,ecModel,api,payload){this.render(seriesModel,ecModel,api,payload)},
// Enable Chart.extend.
clazzUtil.enableClassExtend(Chart),
// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
clazzUtil.enableClassManagement(Chart,{registerWhenExtend:!0}),module.exports=Chart},/* 42 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	     * @private
	     */
function doSingleEnterHover(el){if(!el.__isHover){if(el.__hoverStlDirty){var stroke=el.style.stroke,fill=el.style.fill,hoverStyle=el.__hoverStl,lift=colorTool.lift;hoverStyle.fill=hoverStyle.fill||fill&&(fill instanceof Gradient?fill:lift(fill,-.1)),hoverStyle.stroke=hoverStyle.stroke||stroke&&(stroke instanceof Gradient?stroke:lift(stroke,-.1));var normalStyle={};for(var name in hoverStyle)hoverStyle.hasOwnProperty(name)&&(normalStyle[name]=el.style[name]);el.__normalStl=normalStyle,el.__hoverStlDirty=!1}el.setStyle(el.__hoverStl),el.z2+=1,el.__isHover=!0}}/**
	     * @inner
	     */
function doSingleLeaveHover(el){if(el.__isHover){var normalStl=el.__normalStl;normalStl&&el.setStyle(normalStl),el.z2-=1,el.__isHover=!1}}/**
	     * @inner
	     */
function doEnterHover(el){"group"===el.type?el.traverse(function(child){"group"!==child.type&&doSingleEnterHover(child)}):doSingleEnterHover(el)}function doLeaveHover(el){"group"===el.type?el.traverse(function(child){"group"!==child.type&&doSingleLeaveHover(child)}):doSingleLeaveHover(el)}/**
	     * @inner
	     */
function setElementHoverStl(el,hoverStl){
// If element has sepcified hoverStyle, then use it instead of given hoverStyle
// Often used when item group has a label element and it's hoverStyle is different
el.__hoverStl=el.hoverStyle||hoverStl||{},el.__hoverStlDirty=!0}/**
	     * @inner
	     */
function onElementMouseOver(){
// Only if element is not in emphasis status
!this.__isEmphasis&&doEnterHover(this)}/**
	     * @inner
	     */
function onElementMouseOut(){
// Only if element is not in emphasis status
!this.__isEmphasis&&doLeaveHover(this)}/**
	     * @inner
	     */
function enterEmphasis(){this.__isEmphasis=!0,doEnterHover(this)}/**
	     * @inner
	     */
function leaveEmphasis(){this.__isEmphasis=!1,doLeaveHover(this)}function animateOrSetProps(isUpdate,el,props,animatableModel,cb){var postfix=isUpdate?"Update":"",duration=animatableModel&&animatableModel.getShallow("animationDuration"+postfix),animationEasing=animatableModel&&animatableModel.getShallow("animationEasing"+postfix);animatableModel&&animatableModel.getShallow("animation")?el.animateTo(props,duration,animationEasing,cb):(el.attr(props),cb&&cb())}var zrUtil=__webpack_require__(3),pathTool=__webpack_require__(43),round=Math.round,Path=__webpack_require__(44),colorTool=__webpack_require__(38),matrix=__webpack_require__(17),vector=__webpack_require__(16),Gradient=__webpack_require__(4),graphic={};graphic.Group=__webpack_require__(29),graphic.Image=__webpack_require__(59),graphic.Text=__webpack_require__(62),graphic.Circle=__webpack_require__(63),graphic.Sector=__webpack_require__(64),graphic.Ring=__webpack_require__(65),graphic.Polygon=__webpack_require__(66),graphic.Polyline=__webpack_require__(70),graphic.Rect=__webpack_require__(71),graphic.Line=__webpack_require__(72),graphic.BezierCurve=__webpack_require__(73),graphic.Arc=__webpack_require__(74),graphic.LinearGradient=__webpack_require__(75),graphic.RadialGradient=__webpack_require__(76),graphic.BoundingRect=__webpack_require__(15),/**
	     * Extend shape with parameters
	     */
graphic.extendShape=function(opts){return Path.extend(opts)},/**
	     * Extend path
	     */
graphic.extendPath=function(pathData,opts){return pathTool.extendFromString(pathData,opts)},/**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
graphic.makePath=function(pathData,opts,rect,layout){var path=pathTool.createFromString(pathData,opts),boundingRect=path.getBoundingRect();if(rect){var aspect=boundingRect.width/boundingRect.height;if("center"===layout){
// Set rect to center, keep width / height ratio.
var height,width=rect.height*aspect;width<=rect.width?height=rect.height:(width=rect.width,height=width/aspect);var cx=rect.x+rect.width/2,cy=rect.y+rect.height/2;rect.x=cx-width/2,rect.y=cy-height/2,rect.width=width,rect.height=height}this.resizePath(path,rect)}return path},graphic.mergePath=pathTool.mergePath,/**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
graphic.resizePath=function(path,rect){if(path.applyTransform){var pathRect=path.getBoundingRect(),m=pathRect.calculateTransform(rect);path.applyTransform(m)}},/**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
graphic.subPixelOptimizeLine=function(param){var subPixelOptimize=graphic.subPixelOptimize,shape=param.shape,lineWidth=param.style.lineWidth;return round(2*shape.x1)===round(2*shape.x2)&&(shape.x1=shape.x2=subPixelOptimize(shape.x1,lineWidth,!0)),round(2*shape.y1)===round(2*shape.y2)&&(shape.y1=shape.y2=subPixelOptimize(shape.y1,lineWidth,!0)),param},/**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
graphic.subPixelOptimizeRect=function(param){var subPixelOptimize=graphic.subPixelOptimize,shape=param.shape,lineWidth=param.style.lineWidth,originX=shape.x,originY=shape.y,originWidth=shape.width,originHeight=shape.height;return shape.x=subPixelOptimize(shape.x,lineWidth,!0),shape.y=subPixelOptimize(shape.y,lineWidth,!0),shape.width=Math.max(subPixelOptimize(originX+originWidth,lineWidth,!1)-shape.x,0===originWidth?0:1),shape.height=Math.max(subPixelOptimize(originY+originHeight,lineWidth,!1)-shape.y,0===originHeight?0:1),param},/**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
graphic.subPixelOptimize=function(position,lineWidth,positiveOrNegative){
// Assure that (position + lineWidth / 2) is near integer edge,
// otherwise line will be fuzzy in canvas.
var doubledPosition=round(2*position);return(doubledPosition+round(lineWidth))%2===0?doubledPosition/2:(doubledPosition+(positiveOrNegative?1:-1))/2},/**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
graphic.setHoverStyle=function(el,hoverStyle){"group"===el.type?el.traverse(function(child){"group"!==child.type&&setElementHoverStl(child,hoverStyle)}):setElementHoverStl(el,hoverStyle),
// Remove previous bound handlers
el.on("mouseover",onElementMouseOver).on("mouseout",onElementMouseOut),
// Emphasis, normal can be triggered manually
el.on("emphasis",enterEmphasis).on("normal",leaveEmphasis)},/**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
graphic.setText=function(textStyle,labelModel,color){var labelPosition=labelModel.getShallow("position")||"inside",labelColor=labelPosition.indexOf("inside")>=0?"white":color,textStyleModel=labelModel.getModel("textStyle");zrUtil.extend(textStyle,{textDistance:labelModel.getShallow("distance")||5,textFont:textStyleModel.getFont(),textPosition:labelPosition,textFill:textStyleModel.getTextColor()||labelColor})},/**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
graphic.updateProps=zrUtil.curry(animateOrSetProps,!0),/**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
graphic.initProps=zrUtil.curry(animateOrSetProps,!1),/**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
graphic.getTransform=function(target,ancestor){for(var mat=matrix.identity([]);target&&target!==ancestor;)matrix.mul(mat,target.getLocalTransform(),mat),target=target.parent;return mat},/**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
graphic.applyTransform=function(vertex,transform,invert){return invert&&(transform=matrix.invert([],transform)),vector.applyTransform([],vertex,transform)},/**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
graphic.transformDirection=function(direction,transform,invert){
// Pick a base, ensure that transform result will not be (0, 0).
var hBase=0===transform[4]||0===transform[5]||0===transform[0]?1:Math.abs(2*transform[4]/transform[0]),vBase=0===transform[4]||0===transform[5]||0===transform[2]?1:Math.abs(2*transform[4]/transform[2]),vertex=["left"===direction?-hBase:"right"===direction?hBase:0,"top"===direction?-vBase:"bottom"===direction?vBase:0];return vertex=graphic.applyTransform(vertex,transform,invert),Math.abs(vertex[0])>Math.abs(vertex[1])?vertex[0]>0?"right":"left":vertex[1]>0?"bottom":"top"},module.exports=graphic},/* 43 */
/***/
function(module,exports,__webpack_require__){function processArc(x1,y1,x2,y2,fa,fs,rx,ry,psiDeg,cmd,path){var psi=psiDeg*(PI/180),xp=mathCos(psi)*(x1-x2)/2+mathSin(psi)*(y1-y2)/2,yp=-1*mathSin(psi)*(x1-x2)/2+mathCos(psi)*(y1-y2)/2,lambda=xp*xp/(rx*rx)+yp*yp/(ry*ry);lambda>1&&(rx*=mathSqrt(lambda),ry*=mathSqrt(lambda));var f=(fa===fs?-1:1)*mathSqrt((rx*rx*(ry*ry)-rx*rx*(yp*yp)-ry*ry*(xp*xp))/(rx*rx*(yp*yp)+ry*ry*(xp*xp)))||0,cxp=f*rx*yp/ry,cyp=f*-ry*xp/rx,cx=(x1+x2)/2+mathCos(psi)*cxp-mathSin(psi)*cyp,cy=(y1+y2)/2+mathSin(psi)*cxp+mathCos(psi)*cyp,theta=vAngle([1,0],[(xp-cxp)/rx,(yp-cyp)/ry]),u=[(xp-cxp)/rx,(yp-cyp)/ry],v=[(-1*xp-cxp)/rx,(-1*yp-cyp)/ry],dTheta=vAngle(u,v);vRatio(u,v)<=-1&&(dTheta=PI),vRatio(u,v)>=1&&(dTheta=0),0===fs&&dTheta>0&&(dTheta-=2*PI),1===fs&&0>dTheta&&(dTheta+=2*PI),path.addData(cmd,cx,cy,rx,ry,theta,dTheta,psi,fs)}function createPathProxyFromString(data){if(!data)return[];
// command string
var n,cs=data.replace(/-/g," -").replace(/  /g," ").replace(/ /g,",").replace(/,,/g,",");
// create pipes so that we can split the data
for(n=0;n<cc.length;n++)cs=cs.replace(new RegExp(cc[n],"g"),"|"+cc[n]);
// create array
var prevCmd,arr=cs.split("|"),cpx=0,cpy=0,path=new PathProxy,CMD=PathProxy.CMD;for(n=1;n<arr.length;n++){var cmd,str=arr[n],c=str.charAt(0),off=0,p=str.slice(1).replace(/e,-/g,"e-").split(",");p.length>0&&""===p[0]&&p.shift();for(var i=0;i<p.length;i++)p[i]=parseFloat(p[i]);for(;off<p.length&&!isNaN(p[off])&&!isNaN(p[0]);){var ctlPtx,ctlPty,rx,ry,psi,fa,fs,x1=cpx,y1=cpy;
// convert l, H, h, V, and v to L
switch(c){case"l":cpx+=p[off++],cpy+=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"L":cpx=p[off++],cpy=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"m":cpx+=p[off++],cpy+=p[off++],cmd=CMD.M,path.addData(cmd,cpx,cpy),c="l";break;case"M":cpx=p[off++],cpy=p[off++],cmd=CMD.M,path.addData(cmd,cpx,cpy),c="L";break;case"h":cpx+=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"H":cpx=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"v":cpy+=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"V":cpy=p[off++],cmd=CMD.L,path.addData(cmd,cpx,cpy);break;case"C":cmd=CMD.C,path.addData(cmd,p[off++],p[off++],p[off++],p[off++],p[off++],p[off++]),cpx=p[off-2],cpy=p[off-1];break;case"c":cmd=CMD.C,path.addData(cmd,p[off++]+cpx,p[off++]+cpy,p[off++]+cpx,p[off++]+cpy,p[off++]+cpx,p[off++]+cpy),cpx+=p[off-2],cpy+=p[off-1];break;case"S":ctlPtx=cpx,ctlPty=cpy;var len=path.len(),pathData=path.data;prevCmd===CMD.C&&(ctlPtx+=cpx-pathData[len-4],ctlPty+=cpy-pathData[len-3]),cmd=CMD.C,x1=p[off++],y1=p[off++],cpx=p[off++],cpy=p[off++],path.addData(cmd,ctlPtx,ctlPty,x1,y1,cpx,cpy);break;case"s":ctlPtx=cpx,ctlPty=cpy;var len=path.len(),pathData=path.data;prevCmd===CMD.C&&(ctlPtx+=cpx-pathData[len-4],ctlPty+=cpy-pathData[len-3]),cmd=CMD.C,x1=cpx+p[off++],y1=cpy+p[off++],cpx+=p[off++],cpy+=p[off++],path.addData(cmd,ctlPtx,ctlPty,x1,y1,cpx,cpy);break;case"Q":x1=p[off++],y1=p[off++],cpx=p[off++],cpy=p[off++],cmd=CMD.Q,path.addData(cmd,x1,y1,cpx,cpy);break;case"q":x1=p[off++]+cpx,y1=p[off++]+cpy,cpx+=p[off++],cpy+=p[off++],cmd=CMD.Q,path.addData(cmd,x1,y1,cpx,cpy);break;case"T":ctlPtx=cpx,ctlPty=cpy;var len=path.len(),pathData=path.data;prevCmd===CMD.Q&&(ctlPtx+=cpx-pathData[len-4],ctlPty+=cpy-pathData[len-3]),cpx=p[off++],cpy=p[off++],cmd=CMD.Q,path.addData(cmd,ctlPtx,ctlPty,cpx,cpy);break;case"t":ctlPtx=cpx,ctlPty=cpy;var len=path.len(),pathData=path.data;prevCmd===CMD.Q&&(ctlPtx+=cpx-pathData[len-4],ctlPty+=cpy-pathData[len-3]),cpx+=p[off++],cpy+=p[off++],cmd=CMD.Q,path.addData(cmd,ctlPtx,ctlPty,cpx,cpy);break;case"A":rx=p[off++],ry=p[off++],psi=p[off++],fa=p[off++],fs=p[off++],x1=cpx,y1=cpy,cpx=p[off++],cpy=p[off++],cmd=CMD.A,processArc(x1,y1,cpx,cpy,fa,fs,rx,ry,psi,cmd,path);break;case"a":rx=p[off++],ry=p[off++],psi=p[off++],fa=p[off++],fs=p[off++],x1=cpx,y1=cpy,cpx+=p[off++],cpy+=p[off++],cmd=CMD.A,processArc(x1,y1,cpx,cpy,fa,fs,rx,ry,psi,cmd,path)}}"z"!==c&&"Z"!==c||(cmd=CMD.Z,path.addData(cmd)),prevCmd=cmd}return path.toStatic(),path}
// TODO Optimize double memory cost problem
function createPathOptions(str,opts){var transform,pathProxy=createPathProxyFromString(str);return opts=opts||{},opts.buildPath=function(path){path.setData(pathProxy.data),transform&&transformPath(path,transform);var ctx=path.getContext();ctx&&path.rebuildPath(ctx)},opts.applyTransform=function(m){transform||(transform=matrix.create()),matrix.mul(transform,m,transform)},opts}var Path=__webpack_require__(44),PathProxy=__webpack_require__(48),transformPath=__webpack_require__(58),matrix=__webpack_require__(17),cc=["m","M","l","L","v","V","h","H","z","Z","c","C","q","Q","t","T","s","S","a","A"],mathSqrt=Math.sqrt,mathSin=Math.sin,mathCos=Math.cos,PI=Math.PI,vMag=function(v){return Math.sqrt(v[0]*v[0]+v[1]*v[1])},vRatio=function(u,v){return(u[0]*v[0]+u[1]*v[1])/(vMag(u)*vMag(v))},vAngle=function(u,v){return(u[0]*v[1]<u[1]*v[0]?-1:1)*Math.acos(vRatio(u,v))};module.exports={/**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
createFromString:function(str,opts){return new Path(createPathOptions(str,opts))},/**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
extendFromString:function(str,opts){return Path.extend(createPathOptions(str,opts))},/**
	         * Merge multiple paths
	         */
// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem
mergePath:function(pathEls,opts){var pathEl,i,pathList=[],len=pathEls.length;for(i=0;len>i;i++)pathEl=pathEls[i],pathEl.__dirty&&pathEl.buildPath(pathEl.path,pathEl.shape),pathList.push(pathEl.path);var pathBundle=new Path(opts);return pathBundle.buildPath=function(path){path.appendPath(pathList);
// Svg and vml renderer don't have context
var ctx=path.getContext();ctx&&path.rebuildPath(ctx)},pathBundle}}},/* 44 */
/***/
function(module,exports,__webpack_require__){function pathHasFill(style){var fill=style.fill;return null!=fill&&"none"!==fill}function pathHasStroke(style){var stroke=style.stroke;return null!=stroke&&"none"!==stroke&&style.lineWidth>0}/**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
function Path(opts){Displayable.call(this,opts),/**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
this.path=new PathProxy}/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
var Displayable=__webpack_require__(45),zrUtil=__webpack_require__(3),PathProxy=__webpack_require__(48),pathContain=__webpack_require__(51),Gradient=__webpack_require__(4),abs=Math.abs;Path.prototype={constructor:Path,type:"path",__dirtyPath:!0,strokeContainThreshold:5,brush:function(ctx){ctx.save();var style=this.style,path=this.path,hasStroke=pathHasStroke(style),hasFill=pathHasFill(style);this.__dirtyPath&&(
// Update gradient because bounding rect may changed
hasFill&&style.fill instanceof Gradient&&style.fill.updateCanvasGradient(this,ctx),hasStroke&&style.stroke instanceof Gradient&&style.stroke.updateCanvasGradient(this,ctx)),style.bind(ctx,this),this.setTransform(ctx);var lineDash=style.lineDash,lineDashOffset=style.lineDashOffset,ctxLineDash=!!ctx.setLineDash;
// Proxy context
// Rebuild path in following 2 cases
// 1. Path is dirty
// 2. Path needs javascript implemented lineDash stroking.
//    In this case, lineDash information will not be saved in PathProxy
this.__dirtyPath||lineDash&&!ctxLineDash&&hasStroke?(path=this.path.beginPath(ctx),lineDash&&!ctxLineDash&&(path.setLineDash(lineDash),path.setLineDashOffset(lineDashOffset)),this.buildPath(path,this.shape),this.__dirtyPath=!1):(
// Replay path building
ctx.beginPath(),this.path.rebuildPath(ctx)),hasFill&&path.fill(ctx),lineDash&&ctxLineDash&&(ctx.setLineDash(lineDash),ctx.lineDashOffset=lineDashOffset),hasStroke&&path.stroke(ctx),
// Draw rect text
null!=style.text&&
// var rect = this.getBoundingRect();
this.drawRectText(ctx,this.getBoundingRect()),ctx.restore()},buildPath:function(ctx,shapeCfg){},getBoundingRect:function(){var rect=this._rect,style=this.style,needsUpdateRect=!rect;if(needsUpdateRect){var path=this.path;this.__dirtyPath&&(path.beginPath(),this.buildPath(path,this.shape)),rect=path.getBoundingRect()}if(this._rect=rect,pathHasStroke(style)){
// Needs update rect with stroke lineWidth when
// 1. Element changes scale or lineWidth
// 2. Shape is changed
var rectWithStroke=this._rectWithStroke;if(this.__dirty||needsUpdateRect){var rectWithStroke=this._rectWithStroke||(this._rectWithStroke=rect.clone());rectWithStroke.copy(rect);
// FIXME Must after updateTransform
var w=style.lineWidth,lineScale=style.strokeNoScale?this.getLineScale():1;
// Only add extra hover lineWidth when there are no fill
pathHasFill(style)||(w=Math.max(w,this.strokeContainThreshold)),
// Consider line width
// Line scale can't be 0;
lineScale>1e-10&&(rectWithStroke.width+=w/lineScale,rectWithStroke.height+=w/lineScale,rectWithStroke.x-=w/lineScale/2,rectWithStroke.y-=w/lineScale/2)}
// Return rect with stroke
return rectWithStroke}return rect},contain:function(x,y){var localPos=this.transformCoordToLocal(x,y),rect=this.getBoundingRect(),style=this.style;if(x=localPos[0],y=localPos[1],rect.contain(x,y)){var pathData=this.path.data;if(pathHasStroke(style)){var lineWidth=style.lineWidth,lineScale=style.strokeNoScale?this.getLineScale():1;
// Line scale can't be 0;
if(lineScale>1e-10&&(
// Only add extra hover lineWidth when there are no fill
pathHasFill(style)||(lineWidth=Math.max(lineWidth,this.strokeContainThreshold)),pathContain.containStroke(pathData,lineWidth/lineScale,x,y)))return!0}if(pathHasFill(style))return pathContain.contain(pathData,x,y)}return!1},/**
	         * @param  {boolean} dirtyPath
	         */
dirty:function(dirtyPath){0===arguments.length&&(dirtyPath=!0),
// Only mark dirty, not mark clean
dirtyPath&&(this.__dirtyPath=dirtyPath,this._rect=null),this.__dirty=!0,this.__zr&&this.__zr.refresh(),
// Used as a clipping path
this.__clipTarget&&this.__clipTarget.dirty()},/**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
animateShape:function(loop){return this.animate("shape",loop)},
// Overwrite attrKV
attrKV:function(key,value){
// FIXME
"shape"===key?this.setShape(value):Displayable.prototype.attrKV.call(this,key,value)},/**
	         * @param {Object|string} key
	         * @param {*} value
	         */
setShape:function(key,value){var shape=this.shape;
// Path from string may not have shape
if(shape){if(zrUtil.isObject(key))for(var name in key)shape[name]=key[name];else shape[key]=value;this.dirty(!0)}return this},getLineScale:function(){var m=this.transform;
// Get the line scale.
// Determinant of `m` means how much the area is enlarged by the
// transformation. So its square root can be used as a scale factor
// for width.
return m&&abs(m[0]-1)>1e-10&&abs(m[3]-1)>1e-10?Math.sqrt(abs(m[0]*m[3]-m[2]*m[1])):1}},/**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
Path.extend=function(defaults){var Sub=function(opts){Path.call(this,opts),defaults.style&&
// Extend default style
this.style.extendFrom(defaults.style,!1);
// Extend default shape
var defaultShape=defaults.shape;if(defaultShape){this.shape=this.shape||{};var thisShape=this.shape;for(var name in defaultShape)!thisShape.hasOwnProperty(name)&&defaultShape.hasOwnProperty(name)&&(thisShape[name]=defaultShape[name])}defaults.init&&defaults.init.call(this,opts)};zrUtil.inherits(Sub,Path);
// FIXME 不能 extend position, rotation 等引用对象
for(var name in defaults)
// Extending prototype values and methods
"style"!==name&&"shape"!==name&&(Sub.prototype[name]=defaults[name]);return Sub},zrUtil.inherits(Path,Displayable),module.exports=Path},/* 45 */
/***/
function(module,exports,__webpack_require__){
// var Stateful = require('./mixin/Stateful');
/**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
function Displayable(opts){opts=opts||{},Element.call(this,opts);
// Extend properties
for(var name in opts)opts.hasOwnProperty(name)&&"style"!==name&&(this[name]=opts[name]);/**
	         * @type {module:zrender/graphic/Style}
	         */
this.style=new Style(opts.style),this._rect=null,
// Shapes for cascade clipping.
this.__clipPaths=[]}/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
var zrUtil=__webpack_require__(3),Style=__webpack_require__(46),Element=__webpack_require__(30),RectText=__webpack_require__(47);Displayable.prototype={constructor:Displayable,type:"displayable",/**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
__dirty:!0,/**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
invisible:!1,/**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
z:0,/**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
z2:0,/**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
zlevel:0,/**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
draggable:!1,/**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
dragging:!1,/**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
silent:!1,/**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
culling:!1,/**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
cursor:"pointer",/**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
rectHover:!1,beforeBrush:function(ctx){},afterBrush:function(ctx){},/**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
// Interface
brush:function(ctx){},/**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
// Interface
getBoundingRect:function(){},/**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
contain:function(x,y){return this.rectContain(x,y)},/**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
traverse:function(cb,context){cb.call(context,this)},/**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
rectContain:function(x,y){var coord=this.transformCoordToLocal(x,y),rect=this.getBoundingRect();return rect.contain(coord[0],coord[1])},/**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
dirty:function(){this.__dirty=!0,this._rect=null,this.__zr&&this.__zr.refresh()},/**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
// TODO, 通过 bind 绑定的事件
// isSilent: function () {
//     return !(
//         this.hoverable || this.draggable
//         || this.onmousemove || this.onmouseover || this.onmouseout
//         || this.onmousedown || this.onmouseup || this.onclick
//         || this.ondragenter || this.ondragover || this.ondragleave
//         || this.ondrop
//     );
// },
/**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
animateStyle:function(loop){return this.animate("style",loop)},attrKV:function(key,value){"style"!==key?Element.prototype.attrKV.call(this,key,value):this.style.set(value)},/**
	         * @param {Object|string} key
	         * @param {*} value
	         */
setStyle:function(key,value){return this.style.set(key,value),this.dirty(!1),this}},zrUtil.inherits(Displayable,Element),zrUtil.mixin(Displayable,RectText),
// zrUtil.mixin(Displayable, Stateful);
module.exports=Displayable},/* 46 */
/***/
function(module,exports){/**
	 * @module zrender/graphic/Style
	 */
var STYLE_LIST_COMMON=["lineCap","lineJoin","miterLimit","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor"],Style=function(opts){this.extendFrom(opts)};Style.prototype={constructor:Style,/**
	         * @type {string}
	         */
fill:"#000000",/**
	         * @type {string}
	         */
stroke:null,/**
	         * @type {number}
	         */
opacity:1,/**
	         * @type {Array.<number>}
	         */
lineDash:null,/**
	         * @type {number}
	         */
lineDashOffset:0,/**
	         * @type {number}
	         */
shadowBlur:0,/**
	         * @type {number}
	         */
shadowOffsetX:0,/**
	         * @type {number}
	         */
shadowOffsetY:0,/**
	         * @type {number}
	         */
lineWidth:1,/**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
strokeNoScale:!1,
// Bounding rect text configuration
// Not affected by element transform
/**
	         * @type {string}
	         */
text:null,/**
	         * @type {string}
	         */
textFill:"#000",/**
	         * @type {string}
	         */
textStroke:null,/**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
textPosition:"inside",/**
	         * @type {string}
	         */
textBaseline:null,/**
	         * @type {string}
	         */
textAlign:null,/**
	         * @type {string}
	         */
textVerticalAlign:null,/**
	         * @type {number}
	         */
textDistance:5,/**
	         * @type {number}
	         */
textShadowBlur:0,/**
	         * @type {number}
	         */
textShadowOffsetX:0,/**
	         * @type {number}
	         */
textShadowOffsetY:0,/**
	         * @param {CanvasRenderingContext2D} ctx
	         */
bind:function(ctx,el){for(var fill=this.fill,stroke=this.stroke,i=0;i<STYLE_LIST_COMMON.length;i++){var styleName=STYLE_LIST_COMMON[i];null!=this[styleName]&&(ctx[styleName]=this[styleName])}if(null!=stroke){var lineWidth=this.lineWidth;ctx.lineWidth=lineWidth/(this.strokeNoScale&&el&&el.getLineScale?el.getLineScale():1)}null!=fill&&(
// Use canvas gradient if has
ctx.fillStyle=fill.canvasGradient?fill.canvasGradient:fill),null!=stroke&&(
// Use canvas gradient if has
ctx.strokeStyle=stroke.canvasGradient?stroke.canvasGradient:stroke),null!=this.opacity&&(ctx.globalAlpha=this.opacity)},/**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
extendFrom:function(otherStyle,overwrite){if(otherStyle){var target=this;for(var name in otherStyle)!otherStyle.hasOwnProperty(name)||!overwrite&&target.hasOwnProperty(name)||(target[name]=otherStyle[name])}},/**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
set:function(obj,value){"string"==typeof obj?this[obj]=value:this.extendFrom(obj,!0)},/**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
clone:function(){var newStyle=new this.constructor;return newStyle.extendFrom(this,!0),newStyle}};var name,i,styleProto=Style.prototype;for(i=0;i<STYLE_LIST_COMMON.length;i++)name=STYLE_LIST_COMMON[i],name in styleProto||(styleProto[name]=null);module.exports=Style},/* 47 */
/***/
function(module,exports,__webpack_require__){function parsePercent(value,maxValue){return"string"==typeof value?value.lastIndexOf("%")>=0?parseFloat(value)/100*maxValue:parseFloat(value):value}function setTransform(ctx,m){ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5])}/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
var textContain=__webpack_require__(14),BoundingRect=__webpack_require__(15),tmpRect=new BoundingRect,RectText=function(){};RectText.prototype={constructor:RectText,/**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
drawRectText:function(ctx,rect,textRect){var style=this.style,text=style.text;if(
// Convert to string
null!=text&&(text+=""),text){var x,y,textPosition=style.textPosition,distance=style.textDistance,align=style.textAlign,font=style.textFont||style.font,baseline=style.textBaseline,verticalAlign=style.textVerticalAlign;textRect=textRect||textContain.getBoundingRect(text,font,align,baseline);
// Transform rect to view space
var transform=this.transform,invTransform=this.invTransform;
// Text position represented by coord
if(transform&&(tmpRect.copy(rect),tmpRect.applyTransform(transform),rect=tmpRect,setTransform(ctx,invTransform)),textPosition instanceof Array)x=rect.x+parsePercent(textPosition[0],rect.width),y=rect.y+parsePercent(textPosition[1],rect.height),align=align||"left",baseline=baseline||"top";else{var res=textContain.adjustTextPositionOnRect(textPosition,rect,textRect,distance);x=res.x,y=res.y,
// Default align and baseline when has textPosition
align=align||res.textAlign,baseline=baseline||res.textBaseline}if(ctx.textAlign=align,verticalAlign){switch(verticalAlign){case"middle":y-=textRect.height/2;break;case"bottom":y-=textRect.height}
// Ignore baseline
ctx.textBaseline="top"}else ctx.textBaseline=baseline;var textFill=style.textFill,textStroke=style.textStroke;textFill&&(ctx.fillStyle=textFill),textStroke&&(ctx.strokeStyle=textStroke),ctx.font=font,
// Text shadow
ctx.shadowColor=style.textShadowColor,ctx.shadowBlur=style.textShadowBlur,ctx.shadowOffsetX=style.textShadowOffsetX,ctx.shadowOffsetY=style.textShadowOffsetY;for(var textLines=text.split("\n"),i=0;i<textLines.length;i++)textFill&&ctx.fillText(textLines[i],x,y),textStroke&&ctx.strokeText(textLines[i],x,y),y+=textRect.lineHeight;
// Transform again
transform&&setTransform(ctx,transform)}}},module.exports=RectText},/* 48 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
// TODO getTotalLength, getPointAtLength
var curve=__webpack_require__(49),vec2=__webpack_require__(16),bbox=__webpack_require__(50),BoundingRect=__webpack_require__(15),CMD={M:1,L:2,C:3,Q:4,A:5,Z:6,
// Rect
R:7},min=[],max=[],min2=[],max2=[],mathMin=Math.min,mathMax=Math.max,mathCos=Math.cos,mathSin=Math.sin,mathSqrt=Math.sqrt,hasTypedArray="undefined"!=typeof Float32Array,PathProxy=function(){/**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
this.data=[],this._len=0,this._ctx=null,this._xi=0,this._yi=0,this._x0=0,this._y0=0};/**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
PathProxy.prototype={constructor:PathProxy,_lineDash:null,_dashOffset:0,_dashIdx:0,_dashSum:0,getContext:function(){return this._ctx},/**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
beginPath:function(ctx){
// Reset
return this._ctx=ctx,ctx&&ctx.beginPath(),this._len=0,this._lineDash&&(this._lineDash=null,this._dashOffset=0),this},/**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
moveTo:function(x,y){
// x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
// xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
// 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
// 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
return this.addData(CMD.M,x,y),this._ctx&&this._ctx.moveTo(x,y),this._x0=x,this._y0=y,this._xi=x,this._yi=y,this},/**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
lineTo:function(x,y){return this.addData(CMD.L,x,y),this._ctx&&(this._needsDash()?this._dashedLineTo(x,y):this._ctx.lineTo(x,y)),this._xi=x,this._yi=y,this},/**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
bezierCurveTo:function(x1,y1,x2,y2,x3,y3){return this.addData(CMD.C,x1,y1,x2,y2,x3,y3),this._ctx&&(this._needsDash()?this._dashedBezierTo(x1,y1,x2,y2,x3,y3):this._ctx.bezierCurveTo(x1,y1,x2,y2,x3,y3)),this._xi=x3,this._yi=y3,this},/**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
quadraticCurveTo:function(x1,y1,x2,y2){return this.addData(CMD.Q,x1,y1,x2,y2),this._ctx&&(this._needsDash()?this._dashedQuadraticTo(x1,y1,x2,y2):this._ctx.quadraticCurveTo(x1,y1,x2,y2)),this._xi=x2,this._yi=y2,this},/**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
arc:function(cx,cy,r,startAngle,endAngle,anticlockwise){return this.addData(CMD.A,cx,cy,r,r,startAngle,endAngle-startAngle,0,anticlockwise?0:1),this._ctx&&this._ctx.arc(cx,cy,r,startAngle,endAngle,anticlockwise),this._xi=mathCos(endAngle)*r+cx,this._xi=mathSin(endAngle)*r+cx,this},
// TODO
arcTo:function(x1,y1,x2,y2,radius){return this._ctx&&this._ctx.arcTo(x1,y1,x2,y2,radius),this},
// TODO
rect:function(x,y,w,h){return this._ctx&&this._ctx.rect(x,y,w,h),this.addData(CMD.R,x,y,w,h),this},/**
	         * @return {module:zrender/core/PathProxy}
	         */
closePath:function(){this.addData(CMD.Z);var ctx=this._ctx,x0=this._x0,y0=this._y0;return ctx&&(this._needsDash()&&this._dashedLineTo(x0,y0),ctx.closePath()),this._xi=x0,this._yi=y0,this},/**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
fill:function(ctx){ctx&&ctx.fill(),this.toStatic()},/**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
stroke:function(ctx){ctx&&ctx.stroke(),this.toStatic()},/**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
setLineDash:function(lineDash){if(lineDash instanceof Array){this._lineDash=lineDash,this._dashIdx=0;for(var lineDashSum=0,i=0;i<lineDash.length;i++)lineDashSum+=lineDash[i];this._dashSum=lineDashSum}return this},/**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
setLineDashOffset:function(offset){return this._dashOffset=offset,this},/**
	         *
	         * @return {boolean}
	         */
len:function(){return this._len},/**
	         * 直接设置 Path 数据
	         */
setData:function(data){var len=data.length;this.data&&this.data.length==len||!hasTypedArray||(this.data=new Float32Array(len));for(var i=0;len>i;i++)this.data[i]=data[i];this._len=len},/**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
appendPath:function(path){path instanceof Array||(path=[path]);for(var len=path.length,appendSize=0,offset=this._len,i=0;len>i;i++)appendSize+=path[i].len();hasTypedArray&&this.data instanceof Float32Array&&(this.data=new Float32Array(offset+appendSize));for(var i=0;len>i;i++)for(var appendPathData=path[i].data,k=0;k<appendPathData.length;k++)this.data[offset++]=appendPathData[k];this._len=offset},/**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
addData:function(cmd){var data=this.data;this._len+arguments.length>data.length&&(
// 因为之前的数组已经转换成静态的 Float32Array
// 所以不够用时需要扩展一个新的动态数组
this._expandData(),data=this.data);for(var i=0;i<arguments.length;i++)data[this._len++]=arguments[i];this._prevCmd=cmd},_expandData:function(){
// Only if data is Float32Array
if(!(this.data instanceof Array)){for(var newData=[],i=0;i<this._len;i++)newData[i]=this.data[i];this.data=newData}},/**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
_needsDash:function(){return this._lineDash},_dashedLineTo:function(x1,y1){var dash,idx,dashSum=this._dashSum,offset=this._dashOffset,lineDash=this._lineDash,ctx=this._ctx,x0=this._xi,y0=this._yi,dx=x1-x0,dy=y1-y0,dist=mathSqrt(dx*dx+dy*dy),x=x0,y=y0,nDash=lineDash.length;for(dx/=dist,dy/=dist,0>offset&&(
// Convert to positive offset
offset=dashSum+offset),offset%=dashSum,x-=offset*dx,y-=offset*dy;dx>=0&&x1>=x||0>dx&&x>x1;)idx=this._dashIdx,dash=lineDash[idx],x+=dx*dash,y+=dy*dash,this._dashIdx=(idx+1)%nDash,dx>0&&x0>x||0>dx&&x>x0||ctx[idx%2?"moveTo":"lineTo"](dx>=0?mathMin(x,x1):mathMax(x,x1),dy>=0?mathMin(y,y1):mathMax(y,y1));dx=x-x1,dy=y-y1,this._dashOffset=-mathSqrt(dx*dx+dy*dy)},
// Not accurate dashed line to
_dashedBezierTo:function(x1,y1,x2,y2,x3,y3){var t,dx,dy,x,y,dashSum=this._dashSum,offset=this._dashOffset,lineDash=this._lineDash,ctx=this._ctx,x0=this._xi,y0=this._yi,cubicAt=curve.cubicAt,bezierLen=0,idx=this._dashIdx,nDash=lineDash.length,tmpLen=0;
// Bezier approx length
for(0>offset&&(
// Convert to positive offset
offset=dashSum+offset),offset%=dashSum,t=0;1>t;t+=.1)dx=cubicAt(x0,x1,x2,x3,t+.1)-cubicAt(x0,x1,x2,x3,t),dy=cubicAt(y0,y1,y2,y3,t+.1)-cubicAt(y0,y1,y2,y3,t),bezierLen+=mathSqrt(dx*dx+dy*dy);
// Find idx after add offset
for(;nDash>idx&&(tmpLen+=lineDash[idx],!(tmpLen>offset));idx++);for(t=(tmpLen-offset)/bezierLen;1>=t;)x=cubicAt(x0,x1,x2,x3,t),y=cubicAt(y0,y1,y2,y3,t),idx%2?ctx.moveTo(x,y):ctx.lineTo(x,y),t+=lineDash[idx]/bezierLen,idx=(idx+1)%nDash;
// Finish the last segment and calculate the new offset
idx%2!==0&&ctx.lineTo(x3,y3),dx=x3-x,dy=y3-y,this._dashOffset=-mathSqrt(dx*dx+dy*dy)},_dashedQuadraticTo:function(x1,y1,x2,y2){
// Convert quadratic to cubic using degree elevation
var x3=x2,y3=y2;x2=(x2+2*x1)/3,y2=(y2+2*y1)/3,x1=(this._xi+2*x1)/3,y1=(this._yi+2*y1)/3,this._dashedBezierTo(x1,y1,x2,y2,x3,y3)},/**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
toStatic:function(){var data=this.data;data instanceof Array&&(data.length=this._len,hasTypedArray&&(this.data=new Float32Array(data)))},/**
	         * @return {module:zrender/core/BoundingRect}
	         */
getBoundingRect:function(){min[0]=min[1]=min2[0]=min2[1]=Number.MAX_VALUE,max[0]=max[1]=max2[0]=max2[1]=-Number.MAX_VALUE;for(var data=this.data,xi=0,yi=0,x0=0,y0=0,i=0;i<data.length;){var cmd=data[i++];switch(1==i&&(xi=data[i],yi=data[i+1],x0=xi,y0=yi),cmd){case CMD.M:
// moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
// 在 closePath 的时候使用
x0=data[i++],y0=data[i++],xi=x0,yi=y0,min2[0]=x0,min2[1]=y0,max2[0]=x0,max2[1]=y0;break;case CMD.L:bbox.fromLine(xi,yi,data[i],data[i+1],min2,max2),xi=data[i++],yi=data[i++];break;case CMD.C:bbox.fromCubic(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],min2,max2),xi=data[i++],yi=data[i++];break;case CMD.Q:bbox.fromQuadratic(xi,yi,data[i++],data[i++],data[i],data[i+1],min2,max2),xi=data[i++],yi=data[i++];break;case CMD.A:
// TODO Arc 判断的开销比较大
var cx=data[i++],cy=data[i++],rx=data[i++],ry=data[i++],startAngle=data[i++],endAngle=data[i++]+startAngle,anticlockwise=(data[i++],1-data[i++]);1==i&&(x0=mathCos(startAngle)*rx+cx,y0=mathSin(startAngle)*ry+cy),bbox.fromArc(cx,cy,rx,ry,startAngle,endAngle,anticlockwise,min2,max2),xi=mathCos(endAngle)*rx+cx,yi=mathSin(endAngle)*ry+cy;break;case CMD.R:x0=xi=data[i++],y0=yi=data[i++];var width=data[i++],height=data[i++];
// Use fromLine
bbox.fromLine(x0,y0,x0+width,y0+height,min2,max2);break;case CMD.Z:xi=x0,yi=y0}
// Union
vec2.min(min,min,min2),vec2.max(max,max,max2)}
// No data
return 0===i&&(min[0]=min[1]=max[0]=max[1]=0),new BoundingRect(min[0],min[1],max[0]-min[0],max[1]-min[1])},/**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
rebuildPath:function(ctx){for(var d=this.data,i=0;i<this._len;){var cmd=d[i++];switch(cmd){case CMD.M:ctx.moveTo(d[i++],d[i++]);break;case CMD.L:ctx.lineTo(d[i++],d[i++]);break;case CMD.C:ctx.bezierCurveTo(d[i++],d[i++],d[i++],d[i++],d[i++],d[i++]);break;case CMD.Q:ctx.quadraticCurveTo(d[i++],d[i++],d[i++],d[i++]);break;case CMD.A:var cx=d[i++],cy=d[i++],rx=d[i++],ry=d[i++],theta=d[i++],dTheta=d[i++],psi=d[i++],fs=d[i++],r=rx>ry?rx:ry,scaleX=rx>ry?1:rx/ry,scaleY=rx>ry?ry/rx:1,isEllipse=Math.abs(rx-ry)>.001;isEllipse?(ctx.translate(cx,cy),ctx.rotate(psi),ctx.scale(scaleX,scaleY),ctx.arc(0,0,r,theta,theta+dTheta,1-fs),ctx.scale(1/scaleX,1/scaleY),ctx.rotate(-psi),ctx.translate(-cx,-cy)):ctx.arc(cx,cy,r,theta,theta+dTheta,1-fs);break;case CMD.R:ctx.rect(d[i++],d[i++],d[i++],d[i++]);break;case CMD.Z:ctx.closePath()}}}},PathProxy.CMD=CMD,module.exports=PathProxy},/* 49 */
/***/
function(module,exports,__webpack_require__){"use strict";
// var _v3 = vec2.create();
function isAroundZero(val){return val>-EPSILON&&EPSILON>val}function isNotAroundZero(val){return val>EPSILON||-EPSILON>val}/**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
function cubicAt(p0,p1,p2,p3,t){var onet=1-t;return onet*onet*(onet*p0+3*t*p1)+t*t*(t*p3+3*onet*p2)}/**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
function cubicDerivativeAt(p0,p1,p2,p3,t){var onet=1-t;return 3*(((p1-p0)*onet+2*(p2-p1)*t)*onet+(p3-p2)*t*t)}/**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
function cubicRootAt(p0,p1,p2,p3,val,roots){
// Evaluate roots of cubic functions
var a=p3+3*(p1-p2)-p0,b=3*(p2-2*p1+p0),c=3*(p1-p0),d=p0-val,A=b*b-3*a*c,B=b*c-9*a*d,C=c*c-3*b*d,n=0;if(isAroundZero(A)&&isAroundZero(B))if(isAroundZero(b))roots[0]=0;else{var t1=-c/b;//t1, t2, t3, b is not zero
t1>=0&&1>=t1&&(roots[n++]=t1)}else{var disc=B*B-4*A*C;if(isAroundZero(disc)){var K=B/A,t1=-b/a+K,t2=-K/2;// t2, t3
t1>=0&&1>=t1&&(roots[n++]=t1),t2>=0&&1>=t2&&(roots[n++]=t2)}else if(disc>0){var discSqrt=mathSqrt(disc),Y1=A*b+1.5*a*(-B+discSqrt),Y2=A*b+1.5*a*(-B-discSqrt);Y1=0>Y1?-mathPow(-Y1,ONE_THIRD):mathPow(Y1,ONE_THIRD),Y2=0>Y2?-mathPow(-Y2,ONE_THIRD):mathPow(Y2,ONE_THIRD);var t1=(-b-(Y1+Y2))/(3*a);t1>=0&&1>=t1&&(roots[n++]=t1)}else{var T=(2*A*b-3*a*B)/(2*mathSqrt(A*A*A)),theta=Math.acos(T)/3,ASqrt=mathSqrt(A),tmp=Math.cos(theta),t1=(-b-2*ASqrt*tmp)/(3*a),t2=(-b+ASqrt*(tmp+THREE_SQRT*Math.sin(theta)))/(3*a),t3=(-b+ASqrt*(tmp-THREE_SQRT*Math.sin(theta)))/(3*a);t1>=0&&1>=t1&&(roots[n++]=t1),t2>=0&&1>=t2&&(roots[n++]=t2),t3>=0&&1>=t3&&(roots[n++]=t3)}}return n}/**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
function cubicExtrema(p0,p1,p2,p3,extrema){var b=6*p2-12*p1+6*p0,a=9*p1+3*p3-3*p0-9*p2,c=3*p1-3*p0,n=0;if(isAroundZero(a)){if(isNotAroundZero(b)){var t1=-c/b;t1>=0&&1>=t1&&(extrema[n++]=t1)}}else{var disc=b*b-4*a*c;if(isAroundZero(disc))extrema[0]=-b/(2*a);else if(disc>0){var discSqrt=mathSqrt(disc),t1=(-b+discSqrt)/(2*a),t2=(-b-discSqrt)/(2*a);t1>=0&&1>=t1&&(extrema[n++]=t1),t2>=0&&1>=t2&&(extrema[n++]=t2)}}return n}/**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
function cubicSubdivide(p0,p1,p2,p3,t,out){var p01=(p1-p0)*t+p0,p12=(p2-p1)*t+p1,p23=(p3-p2)*t+p2,p012=(p12-p01)*t+p01,p123=(p23-p12)*t+p12,p0123=(p123-p012)*t+p012;
// Seg0
out[0]=p0,out[1]=p01,out[2]=p012,out[3]=p0123,
// Seg1
out[4]=p0123,out[5]=p123,out[6]=p23,out[7]=p3}/**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
function cubicProjectPoint(x0,y0,x1,y1,x2,y2,x3,y3,x,y,out){
// http://pomax.github.io/bezierinfo/#projections
var t,prev,next,d1,d2,interval=.005,d=1/0;_v0[0]=x,_v0[1]=y;
// 先粗略估计一下可能的最小距离的 t 值
// PENDING
for(var _t=0;1>_t;_t+=.05)_v1[0]=cubicAt(x0,x1,x2,x3,_t),_v1[1]=cubicAt(y0,y1,y2,y3,_t),d1=v2DistSquare(_v0,_v1),d>d1&&(t=_t,d=d1);d=1/0;
// At most 32 iteration
for(var i=0;32>i&&!(EPSILON_NUMERIC>interval);i++)prev=t-interval,next=t+interval,_v1[0]=cubicAt(x0,x1,x2,x3,prev),_v1[1]=cubicAt(y0,y1,y2,y3,prev),d1=v2DistSquare(_v1,_v0),prev>=0&&d>d1?(t=prev,d=d1):(_v2[0]=cubicAt(x0,x1,x2,x3,next),_v2[1]=cubicAt(y0,y1,y2,y3,next),d2=v2DistSquare(_v2,_v0),1>=next&&d>d2?(t=next,d=d2):interval*=.5);
// console.log(interval, i);
// t
return out&&(out[0]=cubicAt(x0,x1,x2,x3,t),out[1]=cubicAt(y0,y1,y2,y3,t)),mathSqrt(d)}/**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
function quadraticAt(p0,p1,p2,t){var onet=1-t;return onet*(onet*p0+2*t*p1)+t*t*p2}/**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
function quadraticDerivativeAt(p0,p1,p2,t){return 2*((1-t)*(p1-p0)+t*(p2-p1))}/**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
function quadraticRootAt(p0,p1,p2,val,roots){var a=p0-2*p1+p2,b=2*(p1-p0),c=p0-val,n=0;if(isAroundZero(a)){if(isNotAroundZero(b)){var t1=-c/b;t1>=0&&1>=t1&&(roots[n++]=t1)}}else{var disc=b*b-4*a*c;if(isAroundZero(disc)){var t1=-b/(2*a);t1>=0&&1>=t1&&(roots[n++]=t1)}else if(disc>0){var discSqrt=mathSqrt(disc),t1=(-b+discSqrt)/(2*a),t2=(-b-discSqrt)/(2*a);t1>=0&&1>=t1&&(roots[n++]=t1),t2>=0&&1>=t2&&(roots[n++]=t2)}}return n}/**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
function quadraticExtremum(p0,p1,p2){var divider=p0+p2-2*p1;return 0===divider?.5:(p0-p1)/divider}/**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
function quadraticSubdivide(p0,p1,p2,t,out){var p01=(p1-p0)*t+p0,p12=(p2-p1)*t+p1,p012=(p12-p01)*t+p01;
// Seg0
out[0]=p0,out[1]=p01,out[2]=p012,
// Seg1
out[3]=p012,out[4]=p12,out[5]=p2}/**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
function quadraticProjectPoint(x0,y0,x1,y1,x2,y2,x,y,out){
// http://pomax.github.io/bezierinfo/#projections
var t,interval=.005,d=1/0;_v0[0]=x,_v0[1]=y;
// 先粗略估计一下可能的最小距离的 t 值
// PENDING
for(var _t=0;1>_t;_t+=.05){_v1[0]=quadraticAt(x0,x1,x2,_t),_v1[1]=quadraticAt(y0,y1,y2,_t);var d1=v2DistSquare(_v0,_v1);d>d1&&(t=_t,d=d1)}d=1/0;
// At most 32 iteration
for(var i=0;32>i&&!(EPSILON_NUMERIC>interval);i++){var prev=t-interval,next=t+interval;
// t - interval
_v1[0]=quadraticAt(x0,x1,x2,prev),_v1[1]=quadraticAt(y0,y1,y2,prev);var d1=v2DistSquare(_v1,_v0);if(prev>=0&&d>d1)t=prev,d=d1;else{
// t + interval
_v2[0]=quadraticAt(x0,x1,x2,next),_v2[1]=quadraticAt(y0,y1,y2,next);var d2=v2DistSquare(_v2,_v0);1>=next&&d>d2?(t=next,d=d2):interval*=.5}}
// console.log(interval, i);
// t
return out&&(out[0]=quadraticAt(x0,x1,x2,t),out[1]=quadraticAt(y0,y1,y2,t)),mathSqrt(d)}/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
var vec2=__webpack_require__(16),v2Create=vec2.create,v2DistSquare=vec2.distSquare,mathPow=Math.pow,mathSqrt=Math.sqrt,EPSILON=1e-8,EPSILON_NUMERIC=1e-4,THREE_SQRT=mathSqrt(3),ONE_THIRD=1/3,_v0=v2Create(),_v1=v2Create(),_v2=v2Create();module.exports={cubicAt:cubicAt,cubicDerivativeAt:cubicDerivativeAt,cubicRootAt:cubicRootAt,cubicExtrema:cubicExtrema,cubicSubdivide:cubicSubdivide,cubicProjectPoint:cubicProjectPoint,quadraticAt:quadraticAt,quadraticDerivativeAt:quadraticDerivativeAt,quadraticRootAt:quadraticRootAt,quadraticExtremum:quadraticExtremum,quadraticSubdivide:quadraticSubdivide,quadraticProjectPoint:quadraticProjectPoint}},/* 50 */
/***/
function(module,exports,__webpack_require__){/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
var vec2=__webpack_require__(16),curve=__webpack_require__(49),bbox={},mathMin=Math.min,mathMax=Math.max,mathSin=Math.sin,mathCos=Math.cos,start=vec2.create(),end=vec2.create(),extremity=vec2.create(),PI2=2*Math.PI;/**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
bbox.fromPoints=function(points,min,max){if(0!==points.length){var i,p=points[0],left=p[0],right=p[0],top=p[1],bottom=p[1];for(i=1;i<points.length;i++)p=points[i],left=mathMin(left,p[0]),right=mathMax(right,p[0]),top=mathMin(top,p[1]),bottom=mathMax(bottom,p[1]);min[0]=left,min[1]=top,max[0]=right,max[1]=bottom}},/**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
bbox.fromLine=function(x0,y0,x1,y1,min,max){min[0]=mathMin(x0,x1),min[1]=mathMin(y0,y1),max[0]=mathMax(x0,x1),max[1]=mathMax(y0,y1)};var xDim=[],yDim=[];/**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
bbox.fromCubic=function(x0,y0,x1,y1,x2,y2,x3,y3,min,max){var i,cubicExtrema=curve.cubicExtrema,cubicAt=curve.cubicAt,n=cubicExtrema(x0,x1,x2,x3,xDim);for(min[0]=1/0,min[1]=1/0,max[0]=-(1/0),max[1]=-(1/0),i=0;n>i;i++){var x=cubicAt(x0,x1,x2,x3,xDim[i]);min[0]=mathMin(x,min[0]),max[0]=mathMax(x,max[0])}for(n=cubicExtrema(y0,y1,y2,y3,yDim),i=0;n>i;i++){var y=cubicAt(y0,y1,y2,y3,yDim[i]);min[1]=mathMin(y,min[1]),max[1]=mathMax(y,max[1])}min[0]=mathMin(x0,min[0]),max[0]=mathMax(x0,max[0]),min[0]=mathMin(x3,min[0]),max[0]=mathMax(x3,max[0]),min[1]=mathMin(y0,min[1]),max[1]=mathMax(y0,max[1]),min[1]=mathMin(y3,min[1]),max[1]=mathMax(y3,max[1])},/**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
bbox.fromQuadratic=function(x0,y0,x1,y1,x2,y2,min,max){var quadraticExtremum=curve.quadraticExtremum,quadraticAt=curve.quadraticAt,tx=mathMax(mathMin(quadraticExtremum(x0,x1,x2),1),0),ty=mathMax(mathMin(quadraticExtremum(y0,y1,y2),1),0),x=quadraticAt(x0,x1,x2,tx),y=quadraticAt(y0,y1,y2,ty);min[0]=mathMin(x0,x2,x),min[1]=mathMin(y0,y2,y),max[0]=mathMax(x0,x2,x),max[1]=mathMax(y0,y2,y)},/**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
bbox.fromArc=function(x,y,rx,ry,startAngle,endAngle,anticlockwise,min,max){var vec2Min=vec2.min,vec2Max=vec2.max,diff=Math.abs(startAngle-endAngle);if(1e-4>diff%PI2&&diff>1e-4)
// Is a circle
return min[0]=x-rx,min[1]=y-ry,max[0]=x+rx,void(max[1]=y+ry);if(start[0]=mathCos(startAngle)*rx+x,start[1]=mathSin(startAngle)*ry+y,end[0]=mathCos(endAngle)*rx+x,end[1]=mathSin(endAngle)*ry+y,vec2Min(min,start,end),vec2Max(max,start,end),startAngle%=PI2,0>startAngle&&(startAngle+=PI2),endAngle%=PI2,0>endAngle&&(endAngle+=PI2),startAngle>endAngle&&!anticlockwise?endAngle+=PI2:endAngle>startAngle&&anticlockwise&&(startAngle+=PI2),anticlockwise){var tmp=endAngle;endAngle=startAngle,startAngle=tmp}
// var number = 0;
// var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
for(var angle=0;endAngle>angle;angle+=Math.PI/2)angle>startAngle&&(extremity[0]=mathCos(angle)*rx+x,extremity[1]=mathSin(angle)*ry+y,vec2Min(min,extremity,min),vec2Max(max,extremity,max))},module.exports=bbox},/* 51 */
/***/
function(module,exports,__webpack_require__){"use strict";function isAroundEqual(a,b){return Math.abs(a-b)<EPSILON}function swapExtrema(){var tmp=extrema[0];extrema[0]=extrema[1],extrema[1]=tmp}function windingCubic(x0,y0,x1,y1,x2,y2,x3,y3,x,y){
// Quick reject
if(y>y0&&y>y1&&y>y2&&y>y3||y0>y&&y1>y&&y2>y&&y3>y)return 0;var nRoots=curve.cubicRootAt(y0,y1,y2,y3,y,roots);if(0===nRoots)return 0;for(var y0_,y1_,w=0,nExtrema=-1,i=0;nRoots>i;i++){var t=roots[i],x_=curve.cubicAt(x0,x1,x2,x3,t);x>x_||(0>nExtrema&&(nExtrema=curve.cubicExtrema(y0,y1,y2,y3,extrema),extrema[1]<extrema[0]&&nExtrema>1&&swapExtrema(),y0_=curve.cubicAt(y0,y1,y2,y3,extrema[0]),nExtrema>1&&(y1_=curve.cubicAt(y0,y1,y2,y3,extrema[1]))),w+=2==nExtrema?
// 分成三段单调函数
t<extrema[0]?y0>y0_?1:-1:t<extrema[1]?y0_>y1_?1:-1:y1_>y3?1:-1:t<extrema[0]?y0>y0_?1:-1:y0_>y3?1:-1)}return w}function windingQuadratic(x0,y0,x1,y1,x2,y2,x,y){
// Quick reject
if(y>y0&&y>y1&&y>y2||y0>y&&y1>y&&y2>y)return 0;var nRoots=curve.quadraticRootAt(y0,y1,y2,y,roots);if(0===nRoots)return 0;var t=curve.quadraticExtremum(y0,y1,y2);if(t>=0&&1>=t){for(var w=0,y_=curve.quadraticAt(y0,y1,y2,t),i=0;nRoots>i;i++){var x_=curve.quadraticAt(x0,x1,x2,roots[i]);x>x_||(w+=roots[i]<t?y0>y_?1:-1:y_>y2?1:-1)}return w}var x_=curve.quadraticAt(x0,x1,x2,roots[0]);return x>x_?0:y0>y2?1:-1}
// TODO
// Arc 旋转
function windingArc(cx,cy,r,startAngle,endAngle,anticlockwise,x,y){if(y-=cy,y>r||-r>y)return 0;var tmp=Math.sqrt(r*r-y*y);roots[0]=-tmp,roots[1]=tmp;var diff=Math.abs(startAngle-endAngle);if(1e-4>diff)return 0;if(1e-4>diff%PI2){
// Is a circle
startAngle=0,endAngle=PI2;var dir=anticlockwise?1:-1;return x>=roots[0]+cx&&x<=roots[1]+cx?dir:0}if(anticlockwise){var tmp=startAngle;startAngle=normalizeRadian(endAngle),endAngle=normalizeRadian(tmp)}else startAngle=normalizeRadian(startAngle),endAngle=normalizeRadian(endAngle);startAngle>endAngle&&(endAngle+=PI2);for(var w=0,i=0;2>i;i++){var x_=roots[i];if(x_+cx>x){var angle=Math.atan2(y,x_),dir=anticlockwise?1:-1;0>angle&&(angle=PI2+angle),(angle>=startAngle&&endAngle>=angle||angle+PI2>=startAngle&&endAngle>=angle+PI2)&&(angle>Math.PI/2&&angle<1.5*Math.PI&&(dir=-dir),w+=dir)}}return w}function containPath(data,lineWidth,isStroke,x,y){for(var w=0,xi=0,yi=0,x0=0,y0=0,i=0;i<data.length;){var cmd=data[i++];
// Begin a new subpath
if(cmd===CMD.M&&i>1&&(isStroke||(w+=windingLine(xi,yi,x0,y0,x,y)),0!==w))return!0;switch(1==i&&(xi=data[i],yi=data[i+1],x0=xi,y0=yi),cmd){case CMD.M:
// moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
// 在 closePath 的时候使用
x0=data[i++],y0=data[i++],xi=x0,yi=y0;break;case CMD.L:if(isStroke){if(containStroke(xi,yi,data[i],data[i+1],lineWidth,x,y))return!0}else
// NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
w+=windingLine(xi,yi,data[i],data[i+1],x,y)||0;xi=data[i++],yi=data[i++];break;case CMD.C:if(isStroke){if(cubic.containStroke(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],lineWidth,x,y))return!0}else w+=windingCubic(xi,yi,data[i++],data[i++],data[i++],data[i++],data[i],data[i+1],x,y)||0;xi=data[i++],yi=data[i++];break;case CMD.Q:if(isStroke){if(quadratic.containStroke(xi,yi,data[i++],data[i++],data[i],data[i+1],lineWidth,x,y))return!0}else w+=windingQuadratic(xi,yi,data[i++],data[i++],data[i],data[i+1],x,y)||0;xi=data[i++],yi=data[i++];break;case CMD.A:
// TODO Arc 判断的开销比较大
var cx=data[i++],cy=data[i++],rx=data[i++],ry=data[i++],theta=data[i++],dTheta=data[i++],anticlockwise=(data[i++],1-data[i++]),x1=Math.cos(theta)*rx+cx,y1=Math.sin(theta)*ry+cy;
// 不是直接使用 arc 命令
i>1?w+=windingLine(xi,yi,x1,y1,x,y):(x0=x1,y0=y1);
// zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
var _x=(x-cx)*ry/rx+cx;if(isStroke){if(arc.containStroke(cx,cy,ry,theta,theta+dTheta,anticlockwise,lineWidth,_x,y))return!0}else w+=windingArc(cx,cy,ry,theta,theta+dTheta,anticlockwise,_x,y);xi=Math.cos(theta+dTheta)*rx+cx,yi=Math.sin(theta+dTheta)*ry+cy;break;case CMD.R:x0=xi=data[i++],y0=yi=data[i++];var width=data[i++],height=data[i++],x1=x0+width,y1=y0+height;if(isStroke){if(containStroke(x0,y0,x1,y0,lineWidth,x,y)||containStroke(x1,y0,x1,y1,lineWidth,x,y)||containStroke(x1,y1,x0,y1,lineWidth,x,y)||containStroke(x0,y1,x1,y1,lineWidth,x,y))return!0}else w+=windingLine(x1,y0,x1,y1,x,y),w+=windingLine(x0,y1,x0,y0,x,y);break;case CMD.Z:if(isStroke){if(containStroke(xi,yi,x0,y0,lineWidth,x,y))return!0}else
// 如果被任何一个 subpath 包含
if(w+=windingLine(xi,yi,x0,y0,x,y),0!==w)return!0;xi=x0,yi=y0}}return isStroke||isAroundEqual(yi,y0)||(w+=windingLine(xi,yi,x0,y0,x,y)||0),0!==w}var CMD=__webpack_require__(48).CMD,line=__webpack_require__(52),cubic=__webpack_require__(53),quadratic=__webpack_require__(54),arc=__webpack_require__(55),normalizeRadian=__webpack_require__(56).normalizeRadian,curve=__webpack_require__(49),windingLine=__webpack_require__(57),containStroke=line.containStroke,PI2=2*Math.PI,EPSILON=1e-4,roots=[-1,-1,-1],extrema=[-1,-1];module.exports={contain:function(pathData,x,y){return containPath(pathData,0,!1,x,y)},containStroke:function(pathData,lineWidth,x,y){return containPath(pathData,lineWidth,!0,x,y)}}},/* 52 */
/***/
function(module,exports){module.exports={/**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
containStroke:function(x0,y0,x1,y1,lineWidth,x,y){if(0===lineWidth)return!1;var _l=lineWidth,_a=0,_b=x0;
// Quick reject
if(y>y0+_l&&y>y1+_l||y0-_l>y&&y1-_l>y||x>x0+_l&&x>x1+_l||x0-_l>x&&x1-_l>x)return!1;if(x0===x1)return Math.abs(x-x0)<=_l/2;_a=(y0-y1)/(x0-x1),_b=(x0*y1-x1*y0)/(x0-x1);var tmp=_a*x-y+_b,_s=tmp*tmp/(_a*_a+1);return _l/2*_l/2>=_s}}},/* 53 */
/***/
function(module,exports,__webpack_require__){var curve=__webpack_require__(49);module.exports={/**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
containStroke:function(x0,y0,x1,y1,x2,y2,x3,y3,lineWidth,x,y){if(0===lineWidth)return!1;var _l=lineWidth;
// Quick reject
if(y>y0+_l&&y>y1+_l&&y>y2+_l&&y>y3+_l||y0-_l>y&&y1-_l>y&&y2-_l>y&&y3-_l>y||x>x0+_l&&x>x1+_l&&x>x2+_l&&x>x3+_l||x0-_l>x&&x1-_l>x&&x2-_l>x&&x3-_l>x)return!1;var d=curve.cubicProjectPoint(x0,y0,x1,y1,x2,y2,x3,y3,x,y,null);return _l/2>=d}}},/* 54 */
/***/
function(module,exports,__webpack_require__){var curve=__webpack_require__(49);module.exports={/**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
containStroke:function(x0,y0,x1,y1,x2,y2,lineWidth,x,y){if(0===lineWidth)return!1;var _l=lineWidth;
// Quick reject
if(y>y0+_l&&y>y1+_l&&y>y2+_l||y0-_l>y&&y1-_l>y&&y2-_l>y||x>x0+_l&&x>x1+_l&&x>x2+_l||x0-_l>x&&x1-_l>x&&x2-_l>x)return!1;var d=curve.quadraticProjectPoint(x0,y0,x1,y1,x2,y2,x,y,null);return _l/2>=d}}},/* 55 */
/***/
function(module,exports,__webpack_require__){var normalizeRadian=__webpack_require__(56).normalizeRadian,PI2=2*Math.PI;module.exports={/**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
containStroke:function(cx,cy,r,startAngle,endAngle,anticlockwise,lineWidth,x,y){if(0===lineWidth)return!1;var _l=lineWidth;x-=cx,y-=cy;var d=Math.sqrt(x*x+y*y);if(d-_l>r||r>d+_l)return!1;if(Math.abs(startAngle-endAngle)%PI2<1e-4)
// Is a circle
return!0;if(anticlockwise){var tmp=startAngle;startAngle=normalizeRadian(endAngle),endAngle=normalizeRadian(tmp)}else startAngle=normalizeRadian(startAngle),endAngle=normalizeRadian(endAngle);startAngle>endAngle&&(endAngle+=PI2);var angle=Math.atan2(y,x);return 0>angle&&(angle+=PI2),angle>=startAngle&&endAngle>=angle||angle+PI2>=startAngle&&endAngle>=angle+PI2}}},/* 56 */
/***/
function(module,exports){var PI2=2*Math.PI;module.exports={normalizeRadian:function(angle){return angle%=PI2,0>angle&&(angle+=PI2),angle}}},/* 57 */
/***/
function(module,exports){module.exports=function(x0,y0,x1,y1,x,y){if(y>y0&&y>y1||y0>y&&y1>y)return 0;if(y1===y0)return 0;var dir=y0>y1?1:-1,t=(y-y0)/(y1-y0),x_=t*(x1-x0)+x0;return x_>x?dir:0}},/* 58 */
/***/
function(module,exports,__webpack_require__){function transformPath(path,m){var cmd,nPoint,i,j,k,p,data=path.data,M=CMD.M,C=CMD.C,L=CMD.L,R=CMD.R,A=CMD.A,Q=CMD.Q;for(i=0,j=0;i<data.length;){switch(cmd=data[i++],j=i,nPoint=0,cmd){case M:nPoint=1;break;case L:nPoint=1;break;case C:nPoint=3;break;case Q:nPoint=2;break;case A:var x=m[4],y=m[5],sx=mathSqrt(m[0]*m[0]+m[1]*m[1]),sy=mathSqrt(m[2]*m[2]+m[3]*m[3]),angle=mathAtan2(-m[1]/sy,m[0]/sx);
// cx
data[i++]+=x,
// cy
data[i++]+=y,
// Scale rx and ry
// FIXME Assume psi is 0 here
data[i++]*=sx,data[i++]*=sy,
// Start angle
data[i++]+=angle,
// end angle
data[i++]+=angle,
// FIXME psi
i+=2,j=i;break;case R:
// x0, y0
p[0]=data[i++],p[1]=data[i++],v2ApplyTransform(p,p,m),data[j++]=p[0],data[j++]=p[1],
// x1, y1
p[0]+=data[i++],p[1]+=data[i++],v2ApplyTransform(p,p,m),data[j++]=p[0],data[j++]=p[1]}for(k=0;nPoint>k;k++){var p=points[k];p[0]=data[i++],p[1]=data[i++],v2ApplyTransform(p,p,m),
// Write back
data[j++]=p[0],data[j++]=p[1]}}}var CMD=__webpack_require__(48).CMD,vec2=__webpack_require__(16),v2ApplyTransform=vec2.applyTransform,points=[[],[],[]],mathSqrt=Math.sqrt,mathAtan2=Math.atan2;module.exports=transformPath},/* 59 */
/***/
function(module,exports,__webpack_require__){/**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
function ZImage(opts){Displayable.call(this,opts)}/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
var Displayable=__webpack_require__(45),BoundingRect=__webpack_require__(15),zrUtil=__webpack_require__(3),roundRectHelper=__webpack_require__(60),LRU=__webpack_require__(61),globalImageCache=new LRU(50);ZImage.prototype={constructor:ZImage,type:"image",brush:function(ctx){var image,style=this.style,src=style.image;
// FIXME Case create many images with src
if(
// style.image is a url string
image="string"==typeof src?this._image:src,!image&&src){
// Try get from global image cache
var cachedImgObj=globalImageCache.get(src);if(!cachedImgObj)
// Create a new image
return image=new Image,image.onload=function(){image.onload=null;for(var i=0;i<cachedImgObj.pending.length;i++)cachedImgObj.pending[i].dirty()},cachedImgObj={image:image,pending:[this]},image.src=src,globalImageCache.put(src,cachedImgObj),void(this._image=image);
// Image is not complete finish, add to pending list
if(image=cachedImgObj.image,this._image=image,!image.width||!image.height)return void cachedImgObj.pending.push(this)}if(image){
// 图片已经加载完成
// if (image.nodeName.toUpperCase() == 'IMG') {
//     if (!image.complete) {
//         return;
//     }
// }
// Else is canvas
var width=style.width||image.width,height=style.height||image.height,x=style.x||0,y=style.y||0;
// 图片加载失败
if(!image.width||!image.height)return;if(ctx.save(),style.bind(ctx),
// 设置transform
this.setTransform(ctx),style.r&&(
// Border radius clipping
// FIXME
ctx.beginPath(),roundRectHelper.buildPath(ctx,style),ctx.clip()),style.sWidth&&style.sHeight){var sx=style.sx||0,sy=style.sy||0;ctx.drawImage(image,sx,sy,style.sWidth,style.sHeight,x,y,width,height)}else if(style.sx&&style.sy){var sx=style.sx,sy=style.sy,sWidth=width-sx,sHeight=height-sy;ctx.drawImage(image,sx,sy,sWidth,sHeight,x,y,width,height)}else ctx.drawImage(image,x,y,width,height);
// 如果没设置宽和高的话自动根据图片宽高设置
null==style.width&&(style.width=width),null==style.height&&(style.height=height),
// Draw rect text
null!=style.text&&this.drawRectText(ctx,this.getBoundingRect()),ctx.restore()}},getBoundingRect:function(){var style=this.style;return this._rect||(this._rect=new BoundingRect(style.x||0,style.y||0,style.width||0,style.height||0)),this._rect}},zrUtil.inherits(ZImage,Displayable),module.exports=ZImage},/* 60 */
/***/
function(module,exports){module.exports={buildPath:function(ctx,shape){var r1,r2,r3,r4,x=shape.x,y=shape.y,width=shape.width,height=shape.height,r=shape.r;
// Convert width and height to positive for better borderRadius
0>width&&(x+=width,width=-width),0>height&&(y+=height,height=-height),"number"==typeof r?r1=r2=r3=r4=r:r instanceof Array?1===r.length?r1=r2=r3=r4=r[0]:2===r.length?(r1=r3=r[0],r2=r4=r[1]):3===r.length?(r1=r[0],r2=r4=r[1],r3=r[2]):(r1=r[0],r2=r[1],r3=r[2],r4=r[3]):r1=r2=r3=r4=0;var total;r1+r2>width&&(total=r1+r2,r1*=width/total,r2*=width/total),r3+r4>width&&(total=r3+r4,r3*=width/total,r4*=width/total),r2+r3>height&&(total=r2+r3,r2*=height/total,r3*=height/total),r1+r4>height&&(total=r1+r4,r1*=height/total,r4*=height/total),ctx.moveTo(x+r1,y),ctx.lineTo(x+width-r2,y),0!==r2&&ctx.quadraticCurveTo(x+width,y,x+width,y+r2),ctx.lineTo(x+width,y+height-r3),0!==r3&&ctx.quadraticCurveTo(x+width,y+height,x+width-r3,y+height),ctx.lineTo(x+r4,y+height),0!==r4&&ctx.quadraticCurveTo(x,y+height,x,y+height-r4),ctx.lineTo(x,y+r1),0!==r1&&ctx.quadraticCurveTo(x,y,x+r1,y)}}},/* 61 */
/***/
function(module,exports){
// Simple LRU cache use doubly linked list
// @module zrender/core/LRU
/**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
var LinkedList=function(){/**
	         * @type {module:zrender/core/LRU~Entry}
	         */
this.head=null,/**
	         * @type {module:zrender/core/LRU~Entry}
	         */
this.tail=null,this._len=0},linkedListProto=LinkedList.prototype;/**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
linkedListProto.insert=function(val){var entry=new Entry(val);return this.insertEntry(entry),entry},/**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
linkedListProto.insertEntry=function(entry){this.head?(this.tail.next=entry,entry.prev=this.tail,this.tail=entry):this.head=this.tail=entry,this._len++},/**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
linkedListProto.remove=function(entry){var prev=entry.prev,next=entry.next;prev?prev.next=next:this.head=next,next?next.prev=prev:this.tail=prev,entry.next=entry.prev=null,this._len--},/**
	     * @return {number}
	     */
linkedListProto.len=function(){return this._len};/**
	     * @constructor
	     * @param {} val
	     */
var Entry=function(val){/**
	         * @type {}
	         */
this.value=val,/**
	         * @type {module:zrender/core/LRU~Entry}
	         */
this.next,/**
	         * @type {module:zrender/core/LRU~Entry}
	         */
this.prev},LRU=function(maxSize){this._list=new LinkedList,this._map={},this._maxSize=maxSize||10},LRUProto=LRU.prototype;/**
	     * @param  {string} key
	     * @param  {} value
	     */
LRUProto.put=function(key,value){var list=this._list,map=this._map;if(null==map[key]){var len=list.len();if(len>=this._maxSize&&len>0){
// Remove the least recently used
var leastUsedEntry=list.head;list.remove(leastUsedEntry),delete map[leastUsedEntry.key]}var entry=list.insert(value);entry.key=key,map[key]=entry}},/**
	     * @param  {string} key
	     * @return {}
	     */
LRUProto.get=function(key){var entry=this._map[key],list=this._list;
// Put the latest used entry in the tail
return null!=entry?(entry!==list.tail&&(list.remove(entry),list.insertEntry(entry)),entry.value):void 0},/**
	     * Clear the cache
	     */
LRUProto.clear=function(){this._list.clear(),this._map={}},module.exports=LRU},/* 62 */
/***/
function(module,exports,__webpack_require__){/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 */
var Displayable=__webpack_require__(45),zrUtil=__webpack_require__(3),textContain=__webpack_require__(14),Text=function(opts){Displayable.call(this,opts)};Text.prototype={constructor:Text,type:"text",brush:function(ctx){var style=this.style,x=style.x||0,y=style.y||0,text=style.text,textFill=style.fill,textStroke=style.stroke;if(
// Convert to string
null!=text&&(text+=""),text){if(ctx.save(),this.style.bind(ctx),this.setTransform(ctx),textFill&&(ctx.fillStyle=textFill),textStroke&&(ctx.strokeStyle=textStroke),ctx.font=style.textFont||style.font,ctx.textAlign=style.textAlign,style.textVerticalAlign){var rect=textContain.getBoundingRect(text,ctx.font,style.textAlign,"top");switch(
// Ignore textBaseline
ctx.textBaseline="top",style.textVerticalAlign){case"middle":y-=rect.height/2;break;case"bottom":y-=rect.height}}else ctx.textBaseline=style.textBaseline;for(var lineHeight=textContain.measureText("国",ctx.font).width,textLines=text.split("\n"),i=0;i<textLines.length;i++)textFill&&ctx.fillText(textLines[i],x,y),textStroke&&ctx.strokeText(textLines[i],x,y),y+=lineHeight;ctx.restore()}},getBoundingRect:function(){if(!this._rect){var style=this.style,textVerticalAlign=style.textVerticalAlign,rect=textContain.getBoundingRect(style.text+"",style.textFont||style.font,style.textAlign,textVerticalAlign?"top":style.textBaseline);switch(textVerticalAlign){case"middle":rect.y-=rect.height/2;break;case"bottom":rect.y-=rect.height}rect.x+=style.x||0,rect.y+=style.y||0,this._rect=rect}return this._rect}},zrUtil.inherits(Text,Displayable),module.exports=Text},/* 63 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
module.exports=__webpack_require__(44).extend({type:"circle",shape:{cx:0,cy:0,r:0},buildPath:function(ctx,shape){
// Better stroking in ShapeBundle
ctx.moveTo(shape.cx+shape.r,shape.cy),ctx.arc(shape.cx,shape.cy,shape.r,0,2*Math.PI,!0)}})},/* 64 */
/***/
function(module,exports,__webpack_require__){/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
// FIXME clockwise seems wrong
module.exports=__webpack_require__(44).extend({type:"sector",shape:{cx:0,cy:0,r0:0,r:0,startAngle:0,endAngle:2*Math.PI,clockwise:!0},buildPath:function(ctx,shape){var x=shape.cx,y=shape.cy,r0=Math.max(shape.r0||0,0),r=Math.max(shape.r,0),startAngle=shape.startAngle,endAngle=shape.endAngle,clockwise=shape.clockwise,unitX=Math.cos(startAngle),unitY=Math.sin(startAngle);ctx.moveTo(unitX*r0+x,unitY*r0+y),ctx.lineTo(unitX*r+x,unitY*r+y),ctx.arc(x,y,r,startAngle,endAngle,!clockwise),ctx.lineTo(Math.cos(endAngle)*r0+x,Math.sin(endAngle)*r0+y),0!==r0&&ctx.arc(x,y,r0,endAngle,startAngle,clockwise),ctx.closePath()}})},/* 65 */
/***/
function(module,exports,__webpack_require__){/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
module.exports=__webpack_require__(44).extend({type:"ring",shape:{cx:0,cy:0,r:0,r0:0},buildPath:function(ctx,shape){var x=shape.cx,y=shape.cy,PI2=2*Math.PI;ctx.moveTo(x+shape.r,y),ctx.arc(x,y,shape.r,0,PI2,!1),ctx.moveTo(x+shape.r0,y),ctx.arc(x,y,shape.r0,0,PI2,!0)}})},/* 66 */
/***/
function(module,exports,__webpack_require__){/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
var polyHelper=__webpack_require__(67);module.exports=__webpack_require__(44).extend({type:"polygon",shape:{points:null,smooth:!1,smoothConstraint:null},buildPath:function(ctx,shape){polyHelper.buildPath(ctx,shape,!0)}})},/* 67 */
/***/
function(module,exports,__webpack_require__){var smoothSpline=__webpack_require__(68),smoothBezier=__webpack_require__(69);module.exports={buildPath:function(ctx,shape,closePath){var points=shape.points,smooth=shape.smooth;if(points&&points.length>=2){if(smooth&&"spline"!==smooth){var controlPoints=smoothBezier(points,smooth,closePath,shape.smoothConstraint);ctx.moveTo(points[0][0],points[0][1]);for(var len=points.length,i=0;(closePath?len:len-1)>i;i++){var cp1=controlPoints[2*i],cp2=controlPoints[2*i+1],p=points[(i+1)%len];ctx.bezierCurveTo(cp1[0],cp1[1],cp2[0],cp2[1],p[0],p[1])}}else{"spline"===smooth&&(points=smoothSpline(points,closePath)),ctx.moveTo(points[0][0],points[0][1]);for(var i=1,l=points.length;l>i;i++)ctx.lineTo(points[i][0],points[i][1])}closePath&&ctx.closePath()}}}},/* 68 */
/***/
function(module,exports,__webpack_require__){/**
	     * @inner
	     */
function interpolate(p0,p1,p2,p3,t,t2,t3){var v0=.5*(p2-p0),v1=.5*(p3-p1);return(2*(p1-p2)+v0+v1)*t3+(-3*(p1-p2)-2*v0-v1)*t2+v0*t+p1}/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
var vec2=__webpack_require__(16);/**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
module.exports=function(points,isLoop){for(var len=points.length,ret=[],distance=0,i=1;len>i;i++)distance+=vec2.distance(points[i-1],points[i]);var segs=distance/2;segs=len>segs?len:segs;for(var i=0;segs>i;i++){var p0,p2,p3,pos=i/(segs-1)*(isLoop?len:len-1),idx=Math.floor(pos),w=pos-idx,p1=points[idx%len];isLoop?(p0=points[(idx-1+len)%len],p2=points[(idx+1)%len],p3=points[(idx+2)%len]):(p0=points[0===idx?idx:idx-1],p2=points[idx>len-2?len-1:idx+1],p3=points[idx>len-3?len-1:idx+2]);var w2=w*w,w3=w*w2;ret.push([interpolate(p0[0],p1[0],p2[0],p3[0],w,w2,w3),interpolate(p0[1],p1[1],p2[1],p3[1],w,w2,w3)])}return ret}},/* 69 */
/***/
function(module,exports,__webpack_require__){/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
var vec2=__webpack_require__(16),v2Min=vec2.min,v2Max=vec2.max,v2Scale=vec2.scale,v2Distance=vec2.distance,v2Add=vec2.add;/**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
module.exports=function(points,smooth,isLoop,constraint){var prevPoint,nextPoint,min,max,cps=[],v=[],v1=[],v2=[];if(constraint){min=[1/0,1/0],max=[-(1/0),-(1/0)];for(var i=0,len=points.length;len>i;i++)v2Min(min,min,points[i]),v2Max(max,max,points[i]);
// 与指定的包围盒做并集
v2Min(min,min,constraint[0]),v2Max(max,max,constraint[1])}for(var i=0,len=points.length;len>i;i++){var point=points[i];if(isLoop)prevPoint=points[i?i-1:len-1],nextPoint=points[(i+1)%len];else{if(0===i||i===len-1){cps.push(vec2.clone(points[i]));continue}prevPoint=points[i-1],nextPoint=points[i+1]}vec2.sub(v,nextPoint,prevPoint),
// use degree to scale the handle length
v2Scale(v,v,smooth);var d0=v2Distance(point,prevPoint),d1=v2Distance(point,nextPoint),sum=d0+d1;0!==sum&&(d0/=sum,d1/=sum),v2Scale(v1,v,-d0),v2Scale(v2,v,d1);var cp0=v2Add([],point,v1),cp1=v2Add([],point,v2);constraint&&(v2Max(cp0,cp0,min),v2Min(cp0,cp0,max),v2Max(cp1,cp1,min),v2Min(cp1,cp1,max)),cps.push(cp0),cps.push(cp1)}return isLoop&&cps.push(cps.shift()),cps}},/* 70 */
/***/
function(module,exports,__webpack_require__){/**
	 * @module zrender/graphic/shape/Polyline
	 */
var polyHelper=__webpack_require__(67);module.exports=__webpack_require__(44).extend({type:"polyline",shape:{points:null,smooth:!1,smoothConstraint:null},style:{stroke:"#000",fill:null},buildPath:function(ctx,shape){polyHelper.buildPath(ctx,shape,!1)}})},/* 71 */
/***/
function(module,exports,__webpack_require__){/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
var roundRectHelper=__webpack_require__(60);module.exports=__webpack_require__(44).extend({type:"rect",shape:{
// 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
// r缩写为1         相当于 [1, 1, 1, 1]
// r缩写为[1]       相当于 [1, 1, 1, 1]
// r缩写为[1, 2]    相当于 [1, 2, 1, 2]
// r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
r:0,x:0,y:0,width:0,height:0},buildPath:function(ctx,shape){var x=shape.x,y=shape.y,width=shape.width,height=shape.height;shape.r?roundRectHelper.buildPath(ctx,shape):ctx.rect(x,y,width,height),ctx.closePath()}})},/* 72 */
/***/
function(module,exports,__webpack_require__){/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
module.exports=__webpack_require__(44).extend({type:"line",shape:{
// Start point
x1:0,y1:0,
// End point
x2:0,y2:0,percent:1},style:{stroke:"#000",fill:null},buildPath:function(ctx,shape){var x1=shape.x1,y1=shape.y1,x2=shape.x2,y2=shape.y2,percent=shape.percent;0!==percent&&(ctx.moveTo(x1,y1),1>percent&&(x2=x1*(1-percent)+x2*percent,y2=y1*(1-percent)+y2*percent),ctx.lineTo(x2,y2))},/**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
pointAt:function(p){var shape=this.shape;return[shape.x1*(1-p)+shape.x2*p,shape.y1*(1-p)+shape.y2*p]}})},/* 73 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
var curveTool=__webpack_require__(49),quadraticSubdivide=curveTool.quadraticSubdivide,cubicSubdivide=curveTool.cubicSubdivide,quadraticAt=curveTool.quadraticAt,cubicAt=curveTool.cubicAt,out=[];module.exports=__webpack_require__(44).extend({type:"bezier-curve",shape:{x1:0,y1:0,x2:0,y2:0,cpx1:0,cpy1:0,
// cpx2: 0,
// cpy2: 0
// Curve show percent, for animating
percent:1},style:{stroke:"#000",fill:null},buildPath:function(ctx,shape){var x1=shape.x1,y1=shape.y1,x2=shape.x2,y2=shape.y2,cpx1=shape.cpx1,cpy1=shape.cpy1,cpx2=shape.cpx2,cpy2=shape.cpy2,percent=shape.percent;0!==percent&&(ctx.moveTo(x1,y1),null==cpx2||null==cpy2?(1>percent&&(quadraticSubdivide(x1,cpx1,x2,percent,out),cpx1=out[1],x2=out[2],quadraticSubdivide(y1,cpy1,y2,percent,out),cpy1=out[1],y2=out[2]),ctx.quadraticCurveTo(cpx1,cpy1,x2,y2)):(1>percent&&(cubicSubdivide(x1,cpx1,cpx2,x2,percent,out),cpx1=out[1],cpx2=out[2],x2=out[3],cubicSubdivide(y1,cpy1,cpy2,y2,percent,out),cpy1=out[1],cpy2=out[2],y2=out[3]),ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x2,y2)))},/**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
pointAt:function(p){var shape=this.shape,cpx2=shape.cpx2,cpy2=shape.cpy2;return null===cpx2||null===cpy2?[quadraticAt(shape.x1,shape.cpx1,shape.x2,p),quadraticAt(shape.y1,shape.cpy1,shape.y2,p)]:[cubicAt(shape.x1,shape.cpx1,shape.cpx1,shape.x2,p),cubicAt(shape.y1,shape.cpy1,shape.cpy1,shape.y2,p)]}})},/* 74 */
/***/
function(module,exports,__webpack_require__){/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
module.exports=__webpack_require__(44).extend({type:"arc",shape:{cx:0,cy:0,r:0,startAngle:0,endAngle:2*Math.PI,clockwise:!0},style:{stroke:"#000",fill:null},buildPath:function(ctx,shape){var x=shape.cx,y=shape.cy,r=Math.max(shape.r,0),startAngle=shape.startAngle,endAngle=shape.endAngle,clockwise=shape.clockwise,unitX=Math.cos(startAngle),unitY=Math.sin(startAngle);ctx.moveTo(unitX*r+x,unitY*r+y),ctx.arc(x,y,r,startAngle,endAngle,!clockwise)}})},/* 75 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),Gradient=__webpack_require__(4),LinearGradient=function(x,y,x2,y2,colorStops){this.x=null==x?0:x,this.y=null==y?0:y,this.x2=null==x2?1:x2,this.y2=null==y2?0:y2,Gradient.call(this,colorStops)};LinearGradient.prototype={constructor:LinearGradient,type:"linear",updateCanvasGradient:function(shape,ctx){for(var rect=shape.getBoundingRect(),x=this.x*rect.width+rect.x,x2=this.x2*rect.width+rect.x,y=this.y*rect.height+rect.y,y2=this.y2*rect.height+rect.y,canvasGradient=ctx.createLinearGradient(x,y,x2,y2),colorStops=this.colorStops,i=0;i<colorStops.length;i++)canvasGradient.addColorStop(colorStops[i].offset,colorStops[i].color);this.canvasGradient=canvasGradient}},zrUtil.inherits(LinearGradient,Gradient),module.exports=LinearGradient},/* 76 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),Gradient=__webpack_require__(4),RadialGradient=function(x,y,r,colorStops){this.x=null==x?.5:x,this.y=null==y?.5:y,this.r=null==r?.5:r,Gradient.call(this,colorStops)};RadialGradient.prototype={constructor:RadialGradient,type:"radial",updateCanvasGradient:function(shape,ctx){for(var rect=shape.getBoundingRect(),width=rect.width,height=rect.height,min=Math.min(width,height),x=this.x*width+rect.x,y=this.y*height+rect.y,r=this.r*min,canvasGradient=ctx.createRadialGradient(x,y,0,x,y,r),colorStops=this.colorStops,i=0;i<colorStops.length;i++)canvasGradient.addColorStop(colorStops[i].offset,colorStops[i].color);this.canvasGradient=canvasGradient}},zrUtil.inherits(RadialGradient,Gradient),module.exports=RadialGradient},/* 77 */
/***/
function(module,exports,__webpack_require__){function delInstance(id){delete instances[id]}/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
// Global defines
var guid=__webpack_require__(31),env=__webpack_require__(78),Handler=__webpack_require__(79),Storage=__webpack_require__(83),Animation=__webpack_require__(84),useVML=!env.canvasSupported,painterCtors={canvas:__webpack_require__(85)},instances={},zrender={};/**
	     * @type {string}
	     */
zrender.version="3.0.8",/**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
zrender.init=function(dom,opts){var zr=new ZRender(guid(),dom,opts);return instances[zr.id]=zr,zr},/**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
zrender.dispose=function(zr){if(zr)zr.dispose();else{for(var key in instances)instances[key].dispose();instances={}}return zrender},/**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
zrender.getInstance=function(id){return instances[id]},zrender.registerPainter=function(name,Ctor){painterCtors[name]=Ctor};/**
	     * @module zrender/ZRender
	     */
/**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
var ZRender=function(id,dom,opts){opts=opts||{},this.dom=dom,this.id=id;var self=this,storage=new Storage,rendererType=opts.renderer;if(useVML){if(!painterCtors.vml)throw new Error("You need to require 'zrender/vml/vml' to support IE8");rendererType="vml"}else rendererType&&painterCtors[rendererType]||(rendererType="canvas");var painter=new painterCtors[rendererType](dom,storage,opts);this.storage=storage,this.painter=painter,env.node||(this.handler=new Handler(painter.getViewportRoot(),storage,painter)),/**
	         * @type {module:zrender/animation/Animation}
	         */
this.animation=new Animation({stage:{update:function(){self._needsRefresh&&self.refreshImmediately()}}}),this.animation.start(),/**
	         * @type {boolean}
	         * @private
	         */
this._needsRefresh;
// 修改 storage.delFromMap, 每次删除元素之前删除动画
// FIXME 有点ugly
var oldDelFromMap=storage.delFromMap,oldAddToMap=storage.addToMap;storage.delFromMap=function(elId){var el=storage.get(elId);oldDelFromMap.call(storage,elId),el&&el.removeSelfFromZr(self)},storage.addToMap=function(el){oldAddToMap.call(storage,el),el.addSelfToZr(self)}};ZRender.prototype={constructor:ZRender,/**
	         * 获取实例唯一标识
	         * @return {string}
	         */
getId:function(){return this.id},/**
	         * 添加元素
	         * @param  {string|module:zrender/Element} el
	         */
add:function(el){this.storage.addRoot(el),this._needsRefresh=!0},/**
	         * 删除元素
	         * @param  {string|module:zrender/Element} el
	         */
remove:function(el){this.storage.delRoot(el),this._needsRefresh=!0},/**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
configLayer:function(zLevel,config){this.painter.configLayer(zLevel,config),this._needsRefresh=!0},/**
	         * Repaint the canvas immediately
	         */
refreshImmediately:function(){
// Clear needsRefresh ahead to avoid something wrong happens in refresh
// Or it will cause zrender refreshes again and again.
this._needsRefresh=!1,this.painter.refresh(),/**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
this._needsRefresh=!1},/**
	         * Mark and repaint the canvas in the next frame of browser
	         */
refresh:function(){this._needsRefresh=!0},/**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         */
resize:function(){this.painter.resize(),this.handler&&this.handler.resize()},/**
	         * Stop and clear all animation immediately
	         */
clearAnimation:function(){this.animation.clear()},/**
	         * Get container width
	         */
getWidth:function(){return this.painter.getWidth()},/**
	         * Get container height
	         */
getHeight:function(){return this.painter.getHeight()},/**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
toDataURL:function(type,backgroundColor,args){return this.painter.toDataURL(type,backgroundColor,args)},/**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
pathToImage:function(e,width,height){var id=guid();return this.painter.pathToImage(id,e,width,height)},/**
	         * Set default cursor
	         * @param {string} cursorStyle 例如 crosshair
	         */
setDefaultCursorStyle:function(cursorStyle){this.handler.setDefaultCursorStyle(cursorStyle)},/**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
on:function(eventName,eventHandler,context){this.handler&&this.handler.on(eventName,eventHandler,context)},/**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
off:function(eventName,eventHandler){this.handler&&this.handler.off(eventName,eventHandler)},/**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
trigger:function(eventName,event){this.handler&&this.handler.trigger(eventName,event)},/**
	         * Clear all objects and the canvas.
	         */
clear:function(){this.storage.delRoot(),this.painter.clear()},/**
	         * Dispose self.
	         */
dispose:function(){this.animation.stop(),this.clear(),this.storage.dispose(),this.painter.dispose(),this.handler&&this.handler.dispose(),this.animation=this.storage=this.painter=this.handler=null,delInstance(this.id)}},module.exports=zrender},/* 78 */
/***/
function(module,exports){
// Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.
function detect(ua){var os={},browser={},webkit=ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/),android=ua.match(/(Android);?[\s\/]+([\d.]+)?/),ipad=ua.match(/(iPad).*OS\s([\d_]+)/),ipod=ua.match(/(iPod)(.*OS\s([\d_]+))?/),iphone=!ipad&&ua.match(/(iPhone\sOS)\s([\d_]+)/),webos=ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),touchpad=webos&&ua.match(/TouchPad/),kindle=ua.match(/Kindle\/([\d.]+)/),silk=ua.match(/Silk\/([\d._]+)/),blackberry=ua.match(/(BlackBerry).*Version\/([\d.]+)/),bb10=ua.match(/(BB10).*Version\/([\d.]+)/),rimtabletos=ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/),playbook=ua.match(/PlayBook/),chrome=ua.match(/Chrome\/([\d.]+)/)||ua.match(/CriOS\/([\d.]+)/),firefox=ua.match(/Firefox\/([\d.]+)/),safari=webkit&&ua.match(/Mobile\//)&&!chrome,webview=ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/)&&!chrome,ie=ua.match(/MSIE\s([\d.]+)/)||ua.match(/Trident\/.+?rv:(([\d.]+))/),edge=ua.match(/Edge\/([\d.]+)/);// IE 12 and 12+
// Todo: clean this up with a better OS/browser seperation:
// - discern (more) between multiple browsers on android
// - decide if kindle fire in silk mode is android or not
// - Firefox on Android doesn't specify the Android version
// - possibly devide in os, device and browser hashes
return(browser.webkit=!!webkit)&&(browser.version=webkit[1]),android&&(os.android=!0,os.version=android[2]),iphone&&!ipod&&(os.ios=os.iphone=!0,os.version=iphone[2].replace(/_/g,".")),ipad&&(os.ios=os.ipad=!0,os.version=ipad[2].replace(/_/g,".")),ipod&&(os.ios=os.ipod=!0,os.version=ipod[3]?ipod[3].replace(/_/g,"."):null),webos&&(os.webos=!0,os.version=webos[2]),touchpad&&(os.touchpad=!0),blackberry&&(os.blackberry=!0,os.version=blackberry[2]),bb10&&(os.bb10=!0,os.version=bb10[2]),rimtabletos&&(os.rimtabletos=!0,os.version=rimtabletos[2]),playbook&&(browser.playbook=!0),kindle&&(os.kindle=!0,os.version=kindle[1]),silk&&(browser.silk=!0,browser.version=silk[1]),!silk&&os.android&&ua.match(/Kindle Fire/)&&(browser.silk=!0),chrome&&(browser.chrome=!0,browser.version=chrome[1]),firefox&&(browser.firefox=!0,browser.version=firefox[1]),ie&&(browser.ie=!0,browser.version=ie[1]),safari&&(ua.match(/Safari/)||os.ios)&&(browser.safari=!0),webview&&(browser.webview=!0),ie&&(browser.ie=!0,browser.version=ie[1]),edge&&(browser.edge=!0,browser.version=edge[1]),os.tablet=!!(ipad||playbook||android&&!ua.match(/Mobile/)||firefox&&ua.match(/Tablet/)||ie&&!ua.match(/Phone/)&&ua.match(/Touch/)),os.phone=!(os.tablet||os.ipod||!(android||iphone||webos||blackberry||bb10||chrome&&ua.match(/Android/)||chrome&&ua.match(/CriOS\/([\d.]+)/)||firefox&&ua.match(/Mobile/)||ie&&ua.match(/Touch/))),{browser:browser,os:os,node:!1,
// 原生canvas支持，改极端点了
// canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
canvasSupported:!!document.createElement("canvas").getContext,
// @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
// works on most browsers
// IE10/11 does not support touch event, and MS Edge supports them but not by
// default, so we dont check navigator.maxTouchPoints for them here.
touchEventsSupported:"ontouchstart"in window&&!browser.ie&&!browser.edge,
// <http://caniuse.com/#search=pointer%20event>.
pointerEventsSupported:"onpointerdown"in window&&(browser.edge||browser.ie&&browser.version>=10)}}/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
var env={};env="undefined"==typeof navigator?{browser:{},os:{},node:!0,
// Assume canvas is supported
canvasSupported:!0}:detect(navigator.userAgent),module.exports=env},/* 79 */
/***/
function(module,exports,__webpack_require__){"use strict";function makeEventPacket(eveType,target,event){return{type:eveType,event:event,target:target,cancelBubble:!1,offsetX:event.zrX,offsetY:event.zrY,gestureEvent:event.gestureEvent,pinchX:event.pinchX,pinchY:event.pinchY,pinchScale:event.pinchScale,wheelDelta:event.zrDelta}}
// Pointer event handlers
// util.each(['pointerdown', 'pointermove', 'pointerup'], function (name) {
//     domHandlers[name] = function (event) {
//         var mouseName = name.replace('pointer', 'mouse');
//         domHandlers[mouseName].call(this, event);
//     };
// });
function processGesture(zrHandler,event,stage){var gestureMgr=zrHandler._gestureMgr;"start"===stage&&gestureMgr.clear();var gestureInfo=gestureMgr.recognize(event,zrHandler.findHover(event.zrX,event.zrY,null));if("end"===stage&&gestureMgr.clear(),gestureInfo){
// eventTool.stop(event);
var type=gestureInfo.type;event.gestureEvent=type,zrHandler._dispatchProxy(gestureInfo.target,type,gestureInfo.event)}}/**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
function initDomHandler(instance){function makeMouseHandler(fn,instance){return function(){return instance._touching?void 0:fn.apply(instance,arguments)}}for(var handlerNames=touchHandlerNames.concat(pointerHandlerNames),i=0;i<handlerNames.length;i++){var name=handlerNames[i];instance._handlers[name]=util.bind(domHandlers[name],instance)}for(var i=0;i<mouseHandlerNames.length;i++){var name=mouseHandlerNames[i];instance._handlers[name]=makeMouseHandler(domHandlers[name],instance)}}function isHover(displayable,x,y){if(displayable[displayable.rectHover?"rectContain":"contain"](x,y)){for(var el=displayable;el;){
// If ancestor is silent or clipped by ancestor
if(el.silent||el.clipPath&&!el.clipPath.contain(x,y))return!1;el=el.parent}return!0}return!1}/**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
function setTouchTimer(instance){instance._touching=!0,clearTimeout(instance._touchTimer),instance._touchTimer=setTimeout(function(){instance._touching=!1},700)}/**
	     * Althought MS Surface support screen touch, IE10/11 do not support
	     * touch event and MS Edge supported them but not by default (but chrome
	     * and firefox do). Thus we use Pointer event on MS browsers to handle touch.
	     */
function usePointerEvent(){
// TODO
// pointermove event dont trigger when using finger.
// We may figger it out latter.
return!1}function useTouchEvent(){return env.touchEventsSupported}function eventNameFix(name){return"mousewheel"===name&&env.browser.firefox?"DOMMouseScroll":name}/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
var env=__webpack_require__(78),eventTool=__webpack_require__(80),util=__webpack_require__(3),Draggable=__webpack_require__(81),GestureMgr=__webpack_require__(82),Eventful=__webpack_require__(32),mouseHandlerNames=["click","dblclick","mousewheel","mouseout"];!usePointerEvent()&&mouseHandlerNames.push("mouseup","mousedown","mousemove");var touchHandlerNames=["touchstart","touchend","touchmove"],pointerHandlerNames=["pointerdown","pointerup","pointermove"],TOUCH_CLICK_DELAY=300,addEventListener=eventTool.addEventListener,removeEventListener=eventTool.removeEventListener,normalizeEvent=eventTool.normalizeEvent,domHandlers={/**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
mousemove:function(event){event=normalizeEvent(this.root,event);var x=event.zrX,y=event.zrY,hovered=this.findHover(x,y,null),lastHovered=this._hovered;this._hovered=hovered,this.root.style.cursor=hovered?hovered.cursor:this._defaultCursorStyle,
// Mouse out on previous hovered element
lastHovered&&hovered!==lastHovered&&lastHovered.__zr&&this._dispatchProxy(lastHovered,"mouseout",event),
// Mouse moving on one element
this._dispatchProxy(hovered,"mousemove",event),
// Mouse over on a new element
hovered&&hovered!==lastHovered&&this._dispatchProxy(hovered,"mouseover",event)},/**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
mouseout:function(event){event=normalizeEvent(this.root,event);var element=event.toElement||event.relatedTarget;if(element!=this.root)for(;element&&9!=element.nodeType;){
// 忽略包含在root中的dom引起的mouseOut
if(element===this.root)return;element=element.parentNode}this._dispatchProxy(this._hovered,"mouseout",event),this.trigger("globalout",{event:event})},/**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
touchstart:function(event){event=normalizeEvent(this.root,event),this._lastTouchMoment=new Date,processGesture(this,event,"start"),domHandlers.mousemove.call(this,event),domHandlers.mousedown.call(this,event),setTouchTimer(this)},/**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
touchmove:function(event){event=normalizeEvent(this.root,event),processGesture(this,event,"change"),domHandlers.mousemove.call(this,event),setTouchTimer(this)},/**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
touchend:function(event){event=normalizeEvent(this.root,event),processGesture(this,event,"end"),domHandlers.mouseup.call(this,event),+new Date-this._lastTouchMoment<TOUCH_CLICK_DELAY&&domHandlers.click.call(this,event),setTouchTimer(this)}};
// Common handlers
util.each(["click","mousedown","mouseup","mousewheel","dblclick"],function(name){domHandlers[name]=function(event){event=normalizeEvent(this.root,event);
// Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
var hovered=this.findHover(event.zrX,event.zrY,null);this._dispatchProxy(hovered,name,event)}});/**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
var Handler=function(root,storage,painter){function mountHandlers(handlerNames,instance){util.each(handlerNames,function(name){addEventListener(root,eventNameFix(name),instance._handlers[name])},instance)}Eventful.call(this),this.root=root,this.storage=storage,this.painter=painter,/**
	         * @private
	         * @type {boolean}
	         */
this._hovered,/**
	         * @private
	         * @type {Date}
	         */
this._lastTouchMoment,/**
	         * @private
	         * @type {number}
	         */
this._lastX,/**
	         * @private
	         * @type {number}
	         */
this._lastY,/**
	         * @private
	         * @type {string}
	         */
this._defaultCursorStyle="default",/**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
this._gestureMgr=new GestureMgr,/**
	         * @private
	         * @type {Array.<Function>}
	         */
this._handlers=[],/**
	         * @private
	         * @type {boolean}
	         */
this._touching=!1,/**
	         * @private
	         * @type {number}
	         */
this._touchTimer,initDomHandler(this),usePointerEvent()?mountHandlers(pointerHandlerNames,this):useTouchEvent()&&mountHandlers(touchHandlerNames,this),
// Considering some devices that both enable touch and mouse event (like MS Surface
// and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
// mouse event can not be handle in those devices.
mountHandlers(mouseHandlerNames,this),Draggable.call(this)};Handler.prototype={constructor:Handler,/**
	         * Resize
	         */
resize:function(event){this._hovered=null},/**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
dispatch:function(eventName,eventArgs){var handler=this._handlers[eventName];handler&&handler.call(this,eventArgs)},/**
	         * Dispose
	         */
dispose:function(){for(var root=this.root,handlerNames=mouseHandlerNames.concat(touchHandlerNames),i=0;i<handlerNames.length;i++){var name=handlerNames[i];removeEventListener(root,eventNameFix(name),this._handlers[name])}this.root=this.storage=this.painter=null},/**
	         * 设置默认的cursor style
	         * @param {string} cursorStyle 例如 crosshair
	         */
setDefaultCursorStyle:function(cursorStyle){this._defaultCursorStyle=cursorStyle},/**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
_dispatchProxy:function(targetEl,eventName,event){for(var eventHandler="on"+eventName,eventPacket=makeEventPacket(eventName,targetEl,event),el=targetEl;el&&(el[eventHandler]&&(eventPacket.cancelBubble=el[eventHandler].call(el,eventPacket)),el.trigger(eventName,eventPacket),el=el.parent,!eventPacket.cancelBubble););eventPacket.cancelBubble||(
// 冒泡到顶级 zrender 对象
this.trigger(eventName,eventPacket),
// 分发事件到用户自定义层
// 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
this.painter&&this.painter.eachOtherLayer(function(layer){"function"==typeof layer[eventHandler]&&layer[eventHandler].call(layer,eventPacket),layer.trigger&&layer.trigger(eventName,eventPacket)}))},/**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
findHover:function(x,y,exclude){for(var list=this.storage.getDisplayList(),i=list.length-1;i>=0;i--)if(!list[i].silent&&list[i]!==exclude&&!list[i].ignore&&isHover(list[i],x,y))return list[i]}},util.mixin(Handler,Eventful),util.mixin(Handler,Draggable),module.exports=Handler},/* 80 */
/***/
function(module,exports,__webpack_require__){"use strict";function getBoundingClientRect(el){
// BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
return el.getBoundingClientRect?el.getBoundingClientRect():{left:0,top:0}}/**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
function normalizeEvent(el,e){if(e=e||window.event,null!=e.zrX)return e;var eventType=e.type,isTouch=eventType&&eventType.indexOf("touch")>=0;if(isTouch){var touch="touchend"!=eventType?e.targetTouches[0]:e.changedTouches[0];if(touch){var rBounding=getBoundingClientRect(el);
// touch事件坐标是全屏的~
e.zrX=touch.clientX-rBounding.left,e.zrY=touch.clientY-rBounding.top}}else{var box=getBoundingClientRect(el);e.zrX=e.clientX-box.left,e.zrY=e.clientY-box.top,e.zrDelta=e.wheelDelta?e.wheelDelta/120:-(e.detail||0)/3}return e}function addEventListener(el,name,handler){isDomLevel2?el.addEventListener(name,handler):el.attachEvent("on"+name,handler)}function removeEventListener(el,name,handler){isDomLevel2?el.removeEventListener(name,handler):el.detachEvent("on"+name,handler)}/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
var Eventful=__webpack_require__(32),isDomLevel2="undefined"!=typeof window&&!!window.addEventListener,stop=isDomLevel2?function(e){e.preventDefault(),e.stopPropagation(),e.cancelBubble=!0}:function(e){e.returnValue=!1,e.cancelBubble=!0};module.exports={normalizeEvent:normalizeEvent,addEventListener:addEventListener,removeEventListener:removeEventListener,stop:stop,
// 做向上兼容
Dispatcher:Eventful}},/* 81 */
/***/
function(module,exports){
// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable(){this.on("mousedown",this._dragStart,this),this.on("mousemove",this._drag,this),this.on("mouseup",this._dragEnd,this),this.on("globalout",this._dragEnd,this)}Draggable.prototype={constructor:Draggable,_dragStart:function(e){var draggingTarget=e.target;draggingTarget&&draggingTarget.draggable&&(this._draggingTarget=draggingTarget,draggingTarget.dragging=!0,this._x=e.offsetX,this._y=e.offsetY,this._dispatchProxy(draggingTarget,"dragstart",e.event))},_drag:function(e){var draggingTarget=this._draggingTarget;if(draggingTarget){var x=e.offsetX,y=e.offsetY,dx=x-this._x,dy=y-this._y;this._x=x,this._y=y,draggingTarget.drift(dx,dy,e),this._dispatchProxy(draggingTarget,"drag",e.event);var dropTarget=this.findHover(x,y,draggingTarget),lastDropTarget=this._dropTarget;this._dropTarget=dropTarget,draggingTarget!==dropTarget&&(lastDropTarget&&dropTarget!==lastDropTarget&&this._dispatchProxy(lastDropTarget,"dragleave",e.event),dropTarget&&dropTarget!==lastDropTarget&&this._dispatchProxy(dropTarget,"dragenter",e.event))}},_dragEnd:function(e){var draggingTarget=this._draggingTarget;draggingTarget&&(draggingTarget.dragging=!1),this._dispatchProxy(draggingTarget,"dragend",e.event),this._dropTarget&&this._dispatchProxy(this._dropTarget,"drop",e.event),this._draggingTarget=null,this._dropTarget=null}},module.exports=Draggable},/* 82 */
/***/
function(module,exports){"use strict";function dist(pointPair){var dx=pointPair[1][0]-pointPair[0][0],dy=pointPair[1][1]-pointPair[0][1];return Math.sqrt(dx*dx+dy*dy)}function center(pointPair){return[(pointPair[0][0]+pointPair[1][0])/2,(pointPair[0][1]+pointPair[1][1])/2]}/**
	 * Only implements needed gestures for mobile.
	 */
var GestureMgr=function(){/**
	         * @private
	         * @type {Array.<Object>}
	         */
this._track=[]};GestureMgr.prototype={constructor:GestureMgr,recognize:function(event,target){return this._doTrack(event,target),this._recognize(event)},clear:function(){return this._track.length=0,this},_doTrack:function(event,target){var touches=event.touches;if(touches){for(var trackItem={points:[],touches:[],target:target,event:event},i=0,len=touches.length;len>i;i++){var touch=touches[i];trackItem.points.push([touch.clientX,touch.clientY]),trackItem.touches.push(touch)}this._track.push(trackItem)}},_recognize:function(event){for(var eventName in recognizers)if(recognizers.hasOwnProperty(eventName)){var gestureInfo=recognizers[eventName](this._track,event);if(gestureInfo)return gestureInfo}}};var recognizers={pinch:function(track,event){var trackLen=track.length;if(trackLen){var pinchEnd=(track[trackLen-1]||{}).points,pinchPre=(track[trackLen-2]||{}).points||pinchEnd;if(pinchPre&&pinchPre.length>1&&pinchEnd&&pinchEnd.length>1){var pinchScale=dist(pinchEnd)/dist(pinchPre);!isFinite(pinchScale)&&(pinchScale=1),event.pinchScale=pinchScale;var pinchCenter=center(pinchEnd);return event.pinchX=pinchCenter[0],event.pinchY=pinchCenter[1],{type:"pinch",target:track[0].target,event:event}}}}};module.exports=GestureMgr},/* 83 */
/***/
function(module,exports,__webpack_require__){"use strict";function shapeCompareFunc(a,b){return a.zlevel===b.zlevel?a.z===b.z?a.z2===b.z2?a.__renderidx-b.__renderidx:a.z2-b.z2:a.z-b.z:a.zlevel-b.zlevel}/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
var util=__webpack_require__(3),Group=__webpack_require__(29),Storage=function(){
// 所有常规形状，id索引的map
this._elements={},this._roots=[],this._displayList=[],this._displayListLen=0};Storage.prototype={constructor:Storage,/**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
getDisplayList:function(update,includeIgnore){return includeIgnore=includeIgnore||!1,update&&this.updateDisplayList(includeIgnore),this._displayList},/**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
updateDisplayList:function(includeIgnore){this._displayListLen=0;for(var roots=this._roots,displayList=this._displayList,i=0,len=roots.length;len>i;i++)this._updateAndAddDisplayable(roots[i],null,includeIgnore);displayList.length=this._displayListLen;for(var i=0,len=displayList.length;len>i;i++)displayList[i].__renderidx=i;displayList.sort(shapeCompareFunc)},_updateAndAddDisplayable:function(el,clipPaths,includeIgnore){if(!el.ignore||includeIgnore){el.beforeUpdate(),el.update(),el.afterUpdate();var clipPath=el.clipPath;if(clipPath&&(
// clipPath 的变换是基于 group 的变换
clipPath.parent=el,clipPath.updateTransform(),
// FIXME 效率影响
clipPaths?(clipPaths=clipPaths.slice(),clipPaths.push(clipPath)):clipPaths=[clipPath]),"group"==el.type){for(var children=el._children,i=0;i<children.length;i++){var child=children[i];
// Force to mark as dirty if group is dirty
// FIXME __dirtyPath ?
child.__dirty=el.__dirty||child.__dirty,this._updateAndAddDisplayable(child,clipPaths,includeIgnore)}
// Mark group clean here
el.__dirty=!1}else el.__clipPaths=clipPaths,this._displayList[this._displayListLen++]=el}},/**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
addRoot:function(el){
// Element has been added
this._elements[el.id]||(el instanceof Group&&el.addChildrenToStorage(this),this.addToMap(el),this._roots.push(el))},/**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
delRoot:function(elId){if(null==elId){
// 不指定elId清空
for(var i=0;i<this._roots.length;i++){var root=this._roots[i];root instanceof Group&&root.delChildrenFromStorage(this)}return this._elements={},this._roots=[],this._displayList=[],void(this._displayListLen=0)}if(elId instanceof Array)for(var i=0,l=elId.length;l>i;i++)this.delRoot(elId[i]);else{var el;el="string"==typeof elId?this._elements[elId]:elId;var idx=util.indexOf(this._roots,el);idx>=0&&(this.delFromMap(el.id),this._roots.splice(idx,1),el instanceof Group&&el.delChildrenFromStorage(this))}},addToMap:function(el){return el instanceof Group&&(el.__storage=this),el.dirty(),this._elements[el.id]=el,this},get:function(elId){return this._elements[elId]},delFromMap:function(elId){var elements=this._elements,el=elements[elId];return el&&(delete elements[elId],el instanceof Group&&(el.__storage=null)),this},/**
	         * 清空并且释放Storage
	         */
dispose:function(){this._elements=this._renderList=this._roots=null}},module.exports=Storage},/* 84 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236
var util=__webpack_require__(3),Dispatcher=__webpack_require__(80).Dispatcher,requestAnimationFrame="undefined"!=typeof window&&(window.requestAnimationFrame||window.msRequestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame)||function(func){setTimeout(func,16)},Animator=__webpack_require__(35),Animation=function(options){options=options||{},this.stage=options.stage||{},this.onframe=options.onframe||function(){},this._clips=[],this._running=!1,this._time=0,Dispatcher.call(this)};Animation.prototype={constructor:Animation,/**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
addClip:function(clip){this._clips.push(clip)},/**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
addAnimator:function(animator){animator.animation=this;for(var clips=animator.getClips(),i=0;i<clips.length;i++)this.addClip(clips[i])},/**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
removeClip:function(clip){var idx=util.indexOf(this._clips,clip);idx>=0&&this._clips.splice(idx,1)},/**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
removeAnimator:function(animator){for(var clips=animator.getClips(),i=0;i<clips.length;i++)this.removeClip(clips[i]);animator.animation=null},_update:function(){for(var time=(new Date).getTime(),delta=time-this._time,clips=this._clips,len=clips.length,deferredEvents=[],deferredClips=[],i=0;len>i;i++){var clip=clips[i],e=clip.step(time);
// Throw out the events need to be called after
// stage.update, like destroy
e&&(deferredEvents.push(e),deferredClips.push(clip))}
// Remove the finished clip
for(var i=0;len>i;)clips[i]._needsRemove?(clips[i]=clips[len-1],clips.pop(),len--):i++;len=deferredEvents.length;for(var i=0;len>i;i++)deferredClips[i].fire(deferredEvents[i]);this._time=time,this.onframe(delta),this.trigger("frame",delta),this.stage.update&&this.stage.update()},/**
	         * 开始运行动画
	         */
start:function(){function step(){self._running&&(requestAnimationFrame(step),self._update())}var self=this;this._running=!0,this._time=(new Date).getTime(),requestAnimationFrame(step)},/**
	         * 停止运行动画
	         */
stop:function(){this._running=!1},/**
	         * 清除所有动画片段
	         */
clear:function(){this._clips=[]},/**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
animate:function(target,options){options=options||{};var animator=new Animator(target,options.loop,options.getter,options.setter);return animator}},util.mixin(Animation,Dispatcher),module.exports=Animation},/* 85 */
/***/
function(module,exports,__webpack_require__){"use strict";function parseInt10(val){return parseInt(val,10)}function isLayerValid(layer){return layer?layer.isBuildin?!0:"function"==typeof layer.resize&&"function"==typeof layer.refresh:!1}function preProcessLayer(layer){layer.__unusedCount++}function postProcessLayer(layer){layer.__dirty=!1,1==layer.__unusedCount&&layer.clear()}function isDisplayableCulled(el,width,height){return tmpRect.copy(el.getBoundingRect()),el.transform&&tmpRect.applyTransform(el.transform),viewRect.width=width,viewRect.height=height,!tmpRect.intersect(viewRect)}function isClipPathChanged(clipPaths,prevClipPaths){if(!clipPaths||!prevClipPaths||clipPaths.length!==prevClipPaths.length)return!0;for(var i=0;i<clipPaths.length;i++)if(clipPaths[i]!==prevClipPaths[i])return!0}function doClip(clipPaths,ctx){for(var i=0;i<clipPaths.length;i++){var m,clipPath=clipPaths[i];clipPath.transform&&(m=clipPath.transform,ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]));var path=clipPath.path;path.beginPath(ctx),clipPath.buildPath(path,clipPath.shape),ctx.clip(),
// Transform back
clipPath.transform&&(m=clipPath.invTransform,ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]))}}/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
var config=__webpack_require__(40),util=__webpack_require__(3),log=__webpack_require__(39),BoundingRect=__webpack_require__(15),Layer=__webpack_require__(86),tmpRect=new BoundingRect(0,0,0,0),viewRect=new BoundingRect(0,0,0,0),Painter=function(root,storage,opts){var singleCanvas=!root.nodeName||"CANVAS"===root.nodeName.toUpperCase();opts=opts||{},this.dpr=opts.devicePixelRatio||config.devicePixelRatio,this._singleCanvas=singleCanvas,this.root=root;var rootStyle=root.style;if(
// In node environment using node-canvas
rootStyle&&(rootStyle["-webkit-tap-highlight-color"]="transparent",rootStyle["-webkit-user-select"]="none",rootStyle["user-select"]="none",rootStyle["-webkit-touch-callout"]="none",root.innerHTML=""),/**
	         * @type {module:zrender/Storage}
	         */
this.storage=storage,singleCanvas){
// Use canvas width and height directly
var width=root.width,height=root.height;this._width=width,this._height=height;
// Create layer if only one given canvas
// Device pixel ratio is fixed to 1 because given canvas has its specified width and height
var mainLayer=new Layer(root,this,1);mainLayer.initContext(),
// FIXME Use canvas width and height
// mainLayer.resize(width, height);
this._layers={0:mainLayer},this._zlevelList=[0]}else{var width=this._getWidth(),height=this._getHeight();this._width=width,this._height=height;var domRoot=document.createElement("div");this._domRoot=domRoot;var domRootStyle=domRoot.style;
// domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
domRootStyle.position="relative",domRootStyle.overflow="hidden",domRootStyle.width=this._width+"px",domRootStyle.height=this._height+"px",root.appendChild(domRoot),/**
	             * @type {Object.<key, module:zrender/Layer>}
	             * @private
	             */
this._layers={},/**
	             * @type {Array.<number>}
	             * @private
	             */
this._zlevelList=[]}this._layerConfig={},this.pathToImage=this._createPathToImage()};Painter.prototype={constructor:Painter,/**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
isSingleCanvas:function(){return this._singleCanvas},/**
	         * @return {HTMLDivElement}
	         */
getViewportRoot:function(){return this._singleCanvas?this._layers[0].dom:this._domRoot},/**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
refresh:function(paintAll){var list=this.storage.getDisplayList(!0),zlevelList=this._zlevelList;this._paintList(list,paintAll);
// Paint custum layers
for(var i=0;i<zlevelList.length;i++){var z=zlevelList[i],layer=this._layers[z];!layer.isBuildin&&layer.refresh&&layer.refresh()}return this},_paintList:function(list,paintAll){null==paintAll&&(paintAll=!1),this._updateLayerStatus(list);var currentLayer,currentZLevel,ctx,viewWidth=this._width,viewHeight=this._height;this.eachBuildinLayer(preProcessLayer);for(var prevElClipPaths=null,i=0,l=list.length;l>i;i++){var el=list[i],elZLevel=this._singleCanvas?0:el.zlevel;if(
// Change draw layer
currentZLevel!==elZLevel&&(currentZLevel=elZLevel,currentLayer=this.getLayer(currentZLevel),currentLayer.isBuildin||log("ZLevel "+currentZLevel+" has been used by unkown layer "+currentLayer.id),ctx=currentLayer.ctx,currentLayer.__unusedCount=0,(currentLayer.__dirty||paintAll)&&currentLayer.clear()),(currentLayer.__dirty||paintAll)&&!el.invisible&&0!==el.style.opacity&&el.scale[0]&&el.scale[1]&&(!el.culling||!isDisplayableCulled(el,viewWidth,viewHeight))){var clipPaths=el.__clipPaths;
// Optimize when clipping on group with several elements
isClipPathChanged(clipPaths,prevElClipPaths)&&(
// If has previous clipping state, restore from it
prevElClipPaths&&ctx.restore(),
// New clipping state
clipPaths&&(ctx.save(),doClip(clipPaths,ctx)),prevElClipPaths=clipPaths),el.beforeBrush&&el.beforeBrush(ctx),el.brush(ctx,!1),el.afterBrush&&el.afterBrush(ctx)}el.__dirty=!1}
// If still has clipping state
prevElClipPaths&&ctx.restore(),this.eachBuildinLayer(postProcessLayer)},/**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
getLayer:function(zlevel){if(this._singleCanvas)return this._layers[0];var layer=this._layers[zlevel];
// Create a new layer
// Context is created after dom inserted to document
// Or excanvas will get 0px clientWidth and clientHeight
return layer||(layer=new Layer("zr_"+zlevel,this,this.dpr),layer.isBuildin=!0,this._layerConfig[zlevel]&&util.merge(layer,this._layerConfig[zlevel],!0),this.insertLayer(zlevel,layer),layer.initContext()),layer},insertLayer:function(zlevel,layer){var layersMap=this._layers,zlevelList=this._zlevelList,len=zlevelList.length,prevLayer=null,i=-1,domRoot=this._domRoot;if(layersMap[zlevel])return void log("ZLevel "+zlevel+" has been used already");
// Check if is a valid layer
if(!isLayerValid(layer))return void log("Layer of zlevel "+zlevel+" is not valid");if(len>0&&zlevel>zlevelList[0]){for(i=0;len-1>i&&!(zlevelList[i]<zlevel&&zlevelList[i+1]>zlevel);i++);prevLayer=layersMap[zlevelList[i]]}if(zlevelList.splice(i+1,0,zlevel),prevLayer){var prevDom=prevLayer.dom;prevDom.nextSibling?domRoot.insertBefore(layer.dom,prevDom.nextSibling):domRoot.appendChild(layer.dom)}else domRoot.firstChild?domRoot.insertBefore(layer.dom,domRoot.firstChild):domRoot.appendChild(layer.dom);layersMap[zlevel]=layer},
// Iterate each layer
eachLayer:function(cb,context){var z,i,zlevelList=this._zlevelList;for(i=0;i<zlevelList.length;i++)z=zlevelList[i],cb.call(context,this._layers[z],z)},
// Iterate each buildin layer
eachBuildinLayer:function(cb,context){var layer,z,i,zlevelList=this._zlevelList;for(i=0;i<zlevelList.length;i++)z=zlevelList[i],layer=this._layers[z],layer.isBuildin&&cb.call(context,layer,z)},
// Iterate each other layer except buildin layer
eachOtherLayer:function(cb,context){var layer,z,i,zlevelList=this._zlevelList;for(i=0;i<zlevelList.length;i++)z=zlevelList[i],layer=this._layers[z],layer.isBuildin||cb.call(context,layer,z)},/**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
getLayers:function(){return this._layers},_updateLayerStatus:function(list){var layers=this._layers,elCounts={};this.eachBuildinLayer(function(layer,z){elCounts[z]=layer.elCount,layer.elCount=0});for(var i=0,l=list.length;l>i;i++){var el=list[i],zlevel=this._singleCanvas?0:el.zlevel,layer=layers[zlevel];if(layer){
// 已经被标记为需要刷新
if(layer.elCount++,layer.__dirty)continue;layer.__dirty=el.__dirty}}
// 层中的元素数量有发生变化
this.eachBuildinLayer(function(layer,z){elCounts[z]!==layer.elCount&&(layer.__dirty=!0)})},/**
	         * 清除hover层外所有内容
	         */
clear:function(){return this.eachBuildinLayer(this._clearLayer),this},_clearLayer:function(layer){layer.clear()},/**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
configLayer:function(zlevel,config){if(config){var layerConfig=this._layerConfig;layerConfig[zlevel]?util.merge(layerConfig[zlevel],config,!0):layerConfig[zlevel]=config;var layer=this._layers[zlevel];layer&&util.merge(layer,layerConfig[zlevel],!0)}},/**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
delLayer:function(zlevel){var layers=this._layers,zlevelList=this._zlevelList,layer=layers[zlevel];layer&&(layer.dom.parentNode.removeChild(layer.dom),delete layers[zlevel],zlevelList.splice(util.indexOf(zlevelList,zlevel),1))},/**
	         * 区域大小变化后重绘
	         */
resize:function(width,height){var domRoot=this._domRoot;
// 优化没有实际改变的resize
if(
// FIXME Why ?
domRoot.style.display="none",width=width||this._getWidth(),height=height||this._getHeight(),domRoot.style.display="",this._width!=width||height!=this._height){domRoot.style.width=width+"px",domRoot.style.height=height+"px";for(var id in this._layers)this._layers[id].resize(width,height);this.refresh(!0)}return this._width=width,this._height=height,this},/**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
clearLayer:function(zlevel){var layer=this._layers[zlevel];layer&&layer.clear()},/**
	         * 释放
	         */
dispose:function(){this.root.innerHTML="",this.root=this.storage=this._domRoot=this._layers=null},/**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
getRenderedCanvas:function(opts){if(opts=opts||{},this._singleCanvas)return this._layers[0].dom;var imageLayer=new Layer("image",this,opts.pixelRatio||this.dpr);imageLayer.initContext();var ctx=imageLayer.ctx;imageLayer.clearColor=opts.backgroundColor,imageLayer.clear();for(var displayList=this.storage.getDisplayList(!0),i=0;i<displayList.length;i++){var el=displayList[i];el.invisible||(el.beforeBrush&&el.beforeBrush(ctx),
// TODO Check image cross origin
el.brush(ctx,!1),el.afterBrush&&el.afterBrush(ctx))}return imageLayer.dom},/**
	         * 获取绘图区域宽度
	         */
getWidth:function(){return this._width},/**
	         * 获取绘图区域高度
	         */
getHeight:function(){return this._height},_getWidth:function(){var root=this.root,stl=document.defaultView.getComputedStyle(root);
// FIXME Better way to get the width and height when element has not been append to the document
return(root.clientWidth||parseInt10(stl.width)||parseInt10(root.style.width))-(parseInt10(stl.paddingLeft)||0)-(parseInt10(stl.paddingRight)||0)|0},_getHeight:function(){var root=this.root,stl=document.defaultView.getComputedStyle(root);return(root.clientHeight||parseInt10(stl.height)||parseInt10(root.style.height))-(parseInt10(stl.paddingTop)||0)-(parseInt10(stl.paddingBottom)||0)|0},_pathToImage:function(id,path,width,height,dpr){var canvas=document.createElement("canvas"),ctx=canvas.getContext("2d");canvas.width=width*dpr,canvas.height=height*dpr,ctx.clearRect(0,0,width*dpr,height*dpr);var pathTransform={position:path.position,rotation:path.rotation,scale:path.scale};path.position=[0,0,0],path.rotation=0,path.scale=[1,1],path&&path.brush(ctx);var ImageShape=__webpack_require__(59),imgShape=new ImageShape({id:id,style:{x:0,y:0,image:canvas}});return null!=pathTransform.position&&(imgShape.position=path.position=pathTransform.position),null!=pathTransform.rotation&&(imgShape.rotation=path.rotation=pathTransform.rotation),null!=pathTransform.scale&&(imgShape.scale=path.scale=pathTransform.scale),imgShape},_createPathToImage:function(){var me=this;return function(id,e,width,height){return me._pathToImage(id,e,width,height,me.dpr)}}},module.exports=Painter},/* 86 */
/***/
function(module,exports,__webpack_require__){function returnFalse(){return!1}/**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
function createDom(id,type,painter,dpr){var newDom=document.createElement(type),width=painter.getWidth(),height=painter.getHeight(),newDomStyle=newDom.style;
// 没append呢，请原谅我这样写，清晰~
// id不作为索引用，避免可能造成的重名，定义为私有属性
return newDomStyle.position="absolute",newDomStyle.left=0,newDomStyle.top=0,newDomStyle.width=width+"px",newDomStyle.height=height+"px",newDom.width=width*dpr,newDom.height=height*dpr,newDom.setAttribute("data-zr-dom-id",id),newDom}/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
var util=__webpack_require__(3),config=__webpack_require__(40),Layer=function(id,painter,dpr){var dom;dpr=dpr||config.devicePixelRatio,"string"==typeof id?dom=createDom(id,"canvas",painter,dpr):util.isObject(id)&&(dom=id,id=dom.id),this.id=id,this.dom=dom;var domStyle=dom.style;domStyle&&(// Not in node
dom.onselectstart=returnFalse,// 避免页面选中的尴尬
domStyle["-webkit-user-select"]="none",domStyle["user-select"]="none",domStyle["-webkit-touch-callout"]="none",domStyle["-webkit-tap-highlight-color"]="rgba(0,0,0,0)"),this.domBack=null,this.ctxBack=null,this.painter=painter,this.config=null,
// Configs
/**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
this.clearColor=0,/**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
this.motionBlur=!1,/**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
this.lastFrameAlpha=.7,/**
	         * Layer dpr
	         * @type {number}
	         */
this.dpr=dpr};Layer.prototype={constructor:Layer,elCount:0,__dirty:!0,initContext:function(){this.ctx=this.dom.getContext("2d");var dpr=this.dpr;1!=dpr&&this.ctx.scale(dpr,dpr)},createBackBuffer:function(){var dpr=this.dpr;this.domBack=createDom("back-"+this.id,"canvas",this.painter,dpr),this.ctxBack=this.domBack.getContext("2d"),1!=dpr&&this.ctxBack.scale(dpr,dpr)},/**
	         * @param  {number} width
	         * @param  {number} height
	         */
resize:function(width,height){var dpr=this.dpr,dom=this.dom,domStyle=dom.style,domBack=this.domBack;domStyle.width=width+"px",domStyle.height=height+"px",dom.width=width*dpr,dom.height=height*dpr,1!=dpr&&this.ctx.scale(dpr,dpr),domBack&&(domBack.width=width*dpr,domBack.height=height*dpr,1!=dpr&&this.ctxBack.scale(dpr,dpr))},/**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
clear:function(clearAll){var dom=this.dom,ctx=this.ctx,width=dom.width,height=dom.height,haveClearColor=this.clearColor,haveMotionBLur=this.motionBlur&&!clearAll,lastFrameAlpha=this.lastFrameAlpha,dpr=this.dpr;if(haveMotionBLur&&(this.domBack||this.createBackBuffer(),this.ctxBack.globalCompositeOperation="copy",this.ctxBack.drawImage(dom,0,0,width/dpr,height/dpr)),ctx.clearRect(0,0,width/dpr,height/dpr),haveClearColor&&(ctx.save(),ctx.fillStyle=this.clearColor,ctx.fillRect(0,0,width/dpr,height/dpr),ctx.restore()),haveMotionBLur){var domBack=this.domBack;ctx.save(),ctx.globalAlpha=lastFrameAlpha,ctx.drawImage(domBack,0,0,width/dpr,height/dpr),ctx.restore()}}},module.exports=Layer},/* 87 */
/***/
function(module,exports,__webpack_require__){var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),PI=Math.PI;/**
	     * @param {module:echarts/ExtensionAPI} api
	     * @param {Object} [opts]
	     * @param {string} [opts.text]
	     * @param {string} [opts.color]
	     * @param {string} [opts.textColor]
	     * @return {module:zrender/Element}
	     */
module.exports=function(api,opts){opts=opts||{},zrUtil.defaults(opts,{text:"loading",color:"#c23531",textColor:"#000",maskColor:"rgba(255, 255, 255, 0.8)",zlevel:0});var mask=new graphic.Rect({style:{fill:opts.maskColor},zlevel:opts.zlevel,z:1e4}),arc=new graphic.Arc({shape:{startAngle:-PI/2,endAngle:-PI/2+.1,r:10},style:{stroke:opts.color,lineCap:"round",lineWidth:5},zlevel:opts.zlevel,z:10001}),labelRect=new graphic.Rect({style:{fill:"none",text:opts.text,textPosition:"right",textDistance:10,textFill:opts.textColor},zlevel:opts.zlevel,z:10001});arc.animateShape(!0).when(1e3,{endAngle:3*PI/2}).start("circularInOut"),arc.animateShape(!0).when(1e3,{startAngle:3*PI/2}).delay(300).start("circularInOut");var group=new graphic.Group;
// Inject resize
return group.add(arc),group.add(labelRect),group.add(mask),group.resize=function(){var cx=api.getWidth()/2,cy=api.getHeight()/2;arc.setShape({cx:cx,cy:cy});var r=arc.shape.r;labelRect.setShape({x:cx-r,y:cy-r,width:2*r,height:2*r}),mask.setShape({x:0,y:0,width:api.getWidth(),height:api.getHeight()})},group.resize(),group}},/* 88 */
/***/
function(module,exports,__webpack_require__){var Gradient=__webpack_require__(4);module.exports=function(seriesType,styleType,ecModel){function encodeColor(seriesModel){var colorAccessPath=[styleType,"normal","color"],colorList=ecModel.get("color"),data=seriesModel.getData(),color=seriesModel.get(colorAccessPath)||colorList[seriesModel.seriesIndex%colorList.length];// Default color
// FIXME Set color function or use the platte color
data.setVisual("color",color),
// Only visible series has each data be visual encoded
ecModel.isSeriesFiltered(seriesModel)||("function"!=typeof color||color instanceof Gradient||data.each(function(idx){data.setItemVisual(idx,"color",color(seriesModel.getDataParams(idx)))}),data.each(function(idx){var itemModel=data.getItemModel(idx),color=itemModel.get(colorAccessPath,!0);null!=color&&data.setItemVisual(idx,"color",color)}))}seriesType?ecModel.eachSeriesByType(seriesType,encodeColor):ecModel.eachSeries(encodeColor)}},/* 89 */
/***/
function(module,exports,__webpack_require__){function get(opt,path){path=path.split(",");for(var obj=opt,i=0;i<path.length&&(obj=obj&&obj[path[i]],null!=obj);i++);return obj}function set(opt,path,val,overwrite){path=path.split(",");for(var key,obj=opt,i=0;i<path.length-1;i++)key=path[i],null==obj[key]&&(obj[key]={}),obj=obj[key];(overwrite||null==obj[path[i]])&&(obj[path[i]]=val)}function compatLayoutProperties(option){each(LAYOUT_PROPERTIES,function(prop){prop[0]in option&&!(prop[1]in option)&&(option[prop[1]]=option[prop[0]])})}
// Compatitable with 2.0
var zrUtil=__webpack_require__(3),compatStyle=__webpack_require__(90),LAYOUT_PROPERTIES=[["x","left"],["y","top"],["x2","right"],["y2","bottom"]],COMPATITABLE_COMPONENTS=["grid","geo","parallel","legend","toolbox","title","visualMap","dataZoom","timeline"],COMPATITABLE_SERIES=["bar","boxplot","candlestick","chord","effectScatter","funnel","gauge","lines","graph","heatmap","line","map","parallel","pie","radar","sankey","scatter","treemap"],each=zrUtil.each;module.exports=function(option){each(option.series,function(seriesOpt){if(zrUtil.isObject(seriesOpt)){var seriesType=seriesOpt.type;if(compatStyle(seriesOpt),"pie"!==seriesType&&"gauge"!==seriesType||null!=seriesOpt.clockWise&&(seriesOpt.clockwise=seriesOpt.clockWise),"gauge"===seriesType){var pointerColor=get(seriesOpt,"pointer.color");null!=pointerColor&&set(seriesOpt,"itemStyle.normal.color",pointerColor)}for(var i=0;i<COMPATITABLE_SERIES.length;i++)if(COMPATITABLE_SERIES[i]===seriesOpt.type){compatLayoutProperties(seriesOpt);break}}}),
// dataRange has changed to visualMap
option.dataRange&&(option.visualMap=option.dataRange),each(COMPATITABLE_COMPONENTS,function(componentName){var options=option[componentName];options&&(zrUtil.isArray(options)||(options=[options]),each(options,function(option){compatLayoutProperties(option)}))})}},/* 90 */
/***/
function(module,exports,__webpack_require__){function compatItemStyle(opt){var itemStyleOpt=opt&&opt.itemStyle;itemStyleOpt&&zrUtil.each(POSSIBLE_STYLES,function(styleName){var normalItemStyleOpt=itemStyleOpt.normal,emphasisItemStyleOpt=itemStyleOpt.emphasis;normalItemStyleOpt&&normalItemStyleOpt[styleName]&&(opt[styleName]=opt[styleName]||{},opt[styleName].normal?zrUtil.merge(opt[styleName].normal,normalItemStyleOpt[styleName]):opt[styleName].normal=normalItemStyleOpt[styleName],normalItemStyleOpt[styleName]=null),emphasisItemStyleOpt&&emphasisItemStyleOpt[styleName]&&(opt[styleName]=opt[styleName]||{},opt[styleName].emphasis?zrUtil.merge(opt[styleName].emphasis,emphasisItemStyleOpt[styleName]):opt[styleName].emphasis=emphasisItemStyleOpt[styleName],emphasisItemStyleOpt[styleName]=null)})}var zrUtil=__webpack_require__(3),POSSIBLE_STYLES=["areaStyle","lineStyle","nodeStyle","linkStyle","chordStyle","label","labelLine"];module.exports=function(seriesOpt){if(seriesOpt){compatItemStyle(seriesOpt),compatItemStyle(seriesOpt.markPoint),compatItemStyle(seriesOpt.markLine);var data=seriesOpt.data;if(data){for(var i=0;i<data.length;i++)compatItemStyle(data[i]);
// mark point data
var markPoint=seriesOpt.markPoint;if(markPoint&&markPoint.data)for(var mpData=markPoint.data,i=0;i<mpData.length;i++)compatItemStyle(mpData[i]);
// mark line data
var markLine=seriesOpt.markLine;if(markLine&&markLine.data)for(var mlData=markLine.data,i=0;i<mlData.length;i++)zrUtil.isArray(mlData[i])?(compatItemStyle(mlData[i][0]),compatItemStyle(mlData[i][1])):compatItemStyle(mlData[i])}}}},/* 91 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);__webpack_require__(92),__webpack_require__(97),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(103),"line","circle","line")),echarts.registerLayout(zrUtil.curry(__webpack_require__(104),"line")),
// Down sample after filter
echarts.registerProcessor("statistic",zrUtil.curry(__webpack_require__(105),"line")),
// In case developer forget to include grid component
__webpack_require__(106)},/* 92 */
/***/
function(module,exports,__webpack_require__){"use strict";var createListFromArray=__webpack_require__(93),SeriesModel=__webpack_require__(27);module.exports=SeriesModel.extend({type:"series.line",dependencies:["grid","polar"],getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel)},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:"cartesian2d",legendHoverLink:!0,hoverAnimation:!0,
// stack: null
xAxisIndex:0,yAxisIndex:0,polarIndex:0,
// If clip the overflow value
clipOverflow:!0,label:{normal:{
// show: false,
position:"top"}},
// itemStyle: {
//     normal: {
//         // color: 各异
//     },
//     emphasis: {
//         // color: 各异,
//     }
// },
lineStyle:{normal:{width:2,type:"solid"}},
// areaStyle: {
// },
// smooth: false,
// smoothMonotone: null,
// 拐点图形类型
symbol:"emptyCircle",
// 拐点图形大小
symbolSize:4,
// 拐点图形旋转控制
// symbolRotate: null,
// 是否显示 symbol, 只有在 tooltip hover 的时候显示
showSymbol:!0,
// 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
// showAllSymbol: false
//
// 大数据过滤，'average', 'max', 'min', 'sum'
// sampling: 'none'
animationEasing:"linear"}})},/* 93 */
/***/
function(module,exports,__webpack_require__){"use strict";function firstDataNotNull(data){for(var i=0;i<data.length&&null==data[i];)i++;return data[i]}function ifNeedCompleteOrdinalData(data){var sampleItem=firstDataNotNull(data);return null!=sampleItem&&!zrUtil.isArray(getDataItemValue(sampleItem))}/**
	     * Helper function to create a list from option data
	     */
function createListFromArray(data,seriesModel,ecModel){
// If data is undefined
data=data||[];var coordSysName=seriesModel.get("coordinateSystem"),creator=creators[coordSysName],registeredCoordSys=CoordinateSystem.get(coordSysName),result=creator&&creator(data,seriesModel,ecModel),dimensions=result&&result.dimensions;dimensions||(dimensions=registeredCoordSys&&registeredCoordSys.dimensions||["x","y"],dimensions=completeDimensions(dimensions,data,dimensions.concat(["value"])));var categories,categoryAxisModel=result&&result.categoryAxisModel,categoryDimIndex="ordinal"===dimensions[0].type?0:"ordinal"===dimensions[1].type?1:-1,list=new List(dimensions,seriesModel),nameList=createNameList(result,data),dimValueGetter=categoryAxisModel&&ifNeedCompleteOrdinalData(data)?function(itemOpt,dimName,dataIndex,dimIndex){
// Use dataIndex as ordinal value in categoryAxis
return dimIndex===categoryDimIndex?dataIndex:converDataValue(getDataItemValue(itemOpt),dimensions[dimIndex])}:function(itemOpt,dimName,dataIndex,dimIndex){var value=getDataItemValue(itemOpt),val=converDataValue(value&&value[dimIndex],dimensions[dimIndex]);
// Lazy get categories
// In case some one write '1', '2' istead of 1, 2
return categoryDimIndex===dimIndex&&"string"==typeof val&&(categories=categories||categoryAxisModel.getCategories(),val=zrUtil.indexOf(categories,val),0>val&&!isNaN(val)&&(val=+val)),val};return list.initData(data,nameList,dimValueGetter),list}function isStackable(axisType){return"category"!==axisType&&"time"!==axisType}function getDimTypeByAxis(axisType){return"category"===axisType?"ordinal":"time"===axisType?"time":"float"}function createNameList(result,data){var nameList=[];if(result&&result.categoryAxisModel){
// FIXME Two category axis
var categories=result.categoryAxisModel.getCategories();if(categories){var dataLen=data.length;
// Ordered data is given explicitly like
// [[3, 0.2], [1, 0.3], [2, 0.15]]
// or given scatter data,
// pick the category
if(zrUtil.isArray(data[0])&&data[0].length>1){nameList=[];for(var i=0;dataLen>i;i++)nameList[i]=categories[data[i][result.categoryIndex||0]]}else nameList=categories.slice(0)}}return nameList}var List=__webpack_require__(94),completeDimensions=__webpack_require__(96),zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),CoordinateSystem=__webpack_require__(25),getDataItemValue=modelUtil.getDataItemValue,converDataValue=modelUtil.converDataValue,creators={cartesian2d:function(data,seriesModel,ecModel){var xAxisModel=ecModel.getComponent("xAxis",seriesModel.get("xAxisIndex")),yAxisModel=ecModel.getComponent("yAxis",seriesModel.get("yAxisIndex")),xAxisType=xAxisModel.get("type"),yAxisType=yAxisModel.get("type"),dimensions=[{name:"x",type:getDimTypeByAxis(xAxisType),stackable:isStackable(xAxisType)},{name:"y",
// If two category axes
type:getDimTypeByAxis(yAxisType),stackable:isStackable(yAxisType)}],isXAxisCateogry="category"===xAxisType;return completeDimensions(dimensions,data,["x","y","z"]),{dimensions:dimensions,categoryIndex:isXAxisCateogry?0:1,categoryAxisModel:isXAxisCateogry?xAxisModel:"category"===yAxisType?yAxisModel:null}},polar:function(data,seriesModel,ecModel){var polarIndex=seriesModel.get("polarIndex")||0,axisFinder=function(axisModel){return axisModel.get("polarIndex")===polarIndex},angleAxisModel=ecModel.findComponents({mainType:"angleAxis",filter:axisFinder})[0],radiusAxisModel=ecModel.findComponents({mainType:"radiusAxis",filter:axisFinder})[0],radiusAxisType=radiusAxisModel.get("type"),angleAxisType=angleAxisModel.get("type"),dimensions=[{name:"radius",type:getDimTypeByAxis(radiusAxisType),stackable:isStackable(radiusAxisType)},{name:"angle",type:getDimTypeByAxis(angleAxisType),stackable:isStackable(angleAxisType)}],isAngleAxisCateogry="category"===angleAxisType;return completeDimensions(dimensions,data,["radius","angle","value"]),{dimensions:dimensions,categoryIndex:isAngleAxisCateogry?1:0,categoryAxisModel:isAngleAxisCateogry?angleAxisModel:"category"===radiusAxisType?radiusAxisModel:null}},geo:function(data,seriesModel,ecModel){
// TODO Region
// 多个散点图系列在同一个地区的时候
return{dimensions:completeDimensions([{name:"lng"},{name:"lat"}],data,["lng","lat","value"])}}};module.exports=createListFromArray},/* 94 */
/***/
function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */
(function(global){function normalizeDimensions(dimensions){return zrUtil.isArray(dimensions)||(dimensions=[dimensions]),dimensions}function cloneListForMapAndSample(original,excludeDimensions){var allDimensions=original.dimensions,list=new List(zrUtil.map(allDimensions,original.getDimensionInfo,original),original.hostModel);
// FIXME If needs stackedOn, value may already been stacked
transferImmuProperties(list,original,original._wrappedMethods);
// Init storage
for(var storage=list._storage={},originalStorage=original._storage,i=0;i<allDimensions.length;i++){var dim=allDimensions[i],dimStore=originalStorage[dim];zrUtil.indexOf(excludeDimensions,dim)>=0?storage[dim]=new dimStore.constructor(originalStorage[dim].length):storage[dim]=originalStorage[dim]}return list}/**
	 * List for data storage
	 * @module echarts/data/List
	 */
var UNDEFINED="undefined",globalObj="undefined"==typeof window?global:window,Float64Array=typeof globalObj.Float64Array===UNDEFINED?Array:globalObj.Float64Array,Int32Array=typeof globalObj.Int32Array===UNDEFINED?Array:globalObj.Int32Array,dataCtors={"float":Float64Array,"int":Int32Array,
// Ordinal data type can be string or int
ordinal:Array,number:Array,time:Array},Model=__webpack_require__(8),DataDiffer=__webpack_require__(95),zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),isObject=zrUtil.isObject,IMMUTABLE_PROPERTIES=["stackedOn","_nameList","_idList","_rawData"],transferImmuProperties=function(a,b,wrappedMethod){zrUtil.each(IMMUTABLE_PROPERTIES.concat(wrappedMethod||[]),function(propName){b.hasOwnProperty(propName)&&(a[propName]=b[propName])})},List=function(dimensions,hostModel){dimensions=dimensions||["x","y"];for(var dimensionInfos={},dimensionNames=[],i=0;i<dimensions.length;i++){var dimensionName,dimensionInfo={};"string"==typeof dimensions[i]?(dimensionName=dimensions[i],dimensionInfo={name:dimensionName,stackable:!1,type:"number"}):(dimensionInfo=dimensions[i],dimensionName=dimensionInfo.name,dimensionInfo.type=dimensionInfo.type||"number"),dimensionNames.push(dimensionName),dimensionInfos[dimensionName]=dimensionInfo}/**
	         * @readOnly
	         * @type {Array.<string>}
	         */
this.dimensions=dimensionNames,/**
	         * Infomation of each data dimension, like data type.
	         * @type {Object}
	         */
this._dimensionInfos=dimensionInfos,/**
	         * @type {module:echarts/model/Model}
	         */
this.hostModel=hostModel,/**
	         * Indices stores the indices of data subset after filtered.
	         * This data subset will be used in chart.
	         * @type {Array.<number>}
	         * @readOnly
	         */
this.indices=[],/**
	         * Data storage
	         * @type {Object.<key, TypedArray|Array>}
	         * @private
	         */
this._storage={},/**
	         * @type {Array.<string>}
	         */
this._nameList=[],/**
	         * @type {Array.<string>}
	         */
this._idList=[],/**
	         * Models of data option is stored sparse for optimizing memory cost
	         * @type {Array.<module:echarts/model/Model>}
	         * @private
	         */
this._optionModels=[],/**
	         * @param {module:echarts/data/List}
	         */
this.stackedOn=null,/**
	         * Global visual properties after visual coding
	         * @type {Object}
	         * @private
	         */
this._visual={},/**
	         * Globel layout properties.
	         * @type {Object}
	         * @private
	         */
this._layout={},/**
	         * Item visual properties after visual coding
	         * @type {Array.<Object>}
	         * @private
	         */
this._itemVisuals=[],/**
	         * Item layout properties after layout
	         * @type {Array.<Object>}
	         * @private
	         */
this._itemLayouts=[],/**
	         * Graphic elemnents
	         * @type {Array.<module:zrender/Element>}
	         * @private
	         */
this._graphicEls=[],/**
	         * @type {Array.<Array|Object>}
	         * @private
	         */
this._rawData,/**
	         * @type {Object}
	         * @private
	         */
this._extent},listProto=List.prototype;listProto.type="list",/**
	     * Get dimension name
	     * @param {string|number} dim
	     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	     */
listProto.getDimension=function(dim){return isNaN(dim)||(dim=this.dimensions[dim]||dim),dim},/**
	     * Get type and stackable info of particular dimension
	     * @param {string|number} dim
	     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	     */
listProto.getDimensionInfo=function(dim){return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)])},/**
	     * Initialize from data
	     * @param {Array.<Object|number|Array>} data
	     * @param {Array.<string>} [nameList]
	     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
	     */
listProto.initData=function(data,nameList,dimValueGetter){data=data||[],this._rawData=data;
// Clear
var storage=this._storage={},indices=this.indices=[],dimensions=this.dimensions,size=data.length,dimensionInfoMap=this._dimensionInfos,idList=[],nameRepeatCount={};nameList=nameList||[];
// Init storage
for(var i=0;i<dimensions.length;i++){var dimInfo=dimensionInfoMap[dimensions[i]],DataCtor=dataCtors[dimInfo.type];storage[dimensions[i]]=new DataCtor(size)}
// Default dim value getter
dimValueGetter=dimValueGetter||function(dataItem,dimName,dataIndex,dimIndex){var value=modelUtil.getDataItemValue(dataItem);return modelUtil.converDataValue(zrUtil.isArray(value)?value[dimIndex]:value,dimensionInfoMap[dimName])};for(var idx=0;idx<data.length;idx++){
// Each data item is value
// [1, 2]
// 2
// Bar chart, line chart which uses category axis
// only gives the 'y' value. 'x' value is the indices of cateogry
// Use a tempValue to normalize the value to be a (x, y) value
// Store the data by dimensions
for(var dataItem=data[idx],k=0;k<dimensions.length;k++){var dim=dimensions[k],dimStorage=storage[dim];
// PENDING NULL is empty or zero
dimStorage[idx]=dimValueGetter(dataItem,dim,idx,k)}indices.push(idx)}
// Use the name in option and create id
for(var i=0;i<data.length;i++){var id="";nameList[i]||(nameList[i]=data[i].name,
// Try using the id in option
id=data[i].id);var name=nameList[i]||"";!id&&name&&(
// Use name as id and add counter to avoid same name
nameRepeatCount[name]=nameRepeatCount[name]||0,id=name,nameRepeatCount[name]>0&&(id+="__ec__"+nameRepeatCount[name]),nameRepeatCount[name]++),id&&(idList[i]=id)}this._nameList=nameList,this._idList=idList},/**
	     * @return {number}
	     */
listProto.count=function(){return this.indices.length},/**
	     * Get value. Return NaN if idx is out of range.
	     * @param {string} dim Dim must be concrete name.
	     * @param {number} idx
	     * @param {boolean} stack
	     * @return {number}
	     */
listProto.get=function(dim,idx,stack){var storage=this._storage,dataIndex=this.indices[idx];
// If value not exists
if(null==dataIndex)return NaN;var value=storage[dim]&&storage[dim][dataIndex];
// FIXME ordinal data type is not stackable
if(stack){var dimensionInfo=this._dimensionInfos[dim];if(dimensionInfo&&dimensionInfo.stackable)for(var stackedOn=this.stackedOn;stackedOn;){
// Get no stacked data of stacked on
var stackedValue=stackedOn.get(dim,idx);
// Considering positive stack, negative stack and empty data
(value>=0&&stackedValue>0||0>=value&&0>stackedValue)&&(value+=stackedValue),stackedOn=stackedOn.stackedOn}}return value},/**
	     * Get value for multi dimensions.
	     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
	     * @param {number} idx
	     * @param {boolean} stack
	     * @return {number}
	     */
listProto.getValues=function(dimensions,idx,stack){var values=[];zrUtil.isArray(dimensions)||(stack=idx,idx=dimensions,dimensions=this.dimensions);for(var i=0,len=dimensions.length;len>i;i++)values.push(this.get(dimensions[i],idx,stack));return values},/**
	     * If value is NaN. Inlcuding '-'
	     * @param {string} dim
	     * @param {number} idx
	     * @return {number}
	     */
listProto.hasValue=function(idx){for(var dimensions=this.dimensions,dimensionInfos=this._dimensionInfos,i=0,len=dimensions.length;len>i;i++)if("ordinal"!==dimensionInfos[dimensions[i]].type&&isNaN(this.get(dimensions[i],idx)))return!1;return!0},/**
	     * Get extent of data in one dimension
	     * @param {string} dim
	     * @param {boolean} stack
	     */
listProto.getDataExtent=function(dim,stack){var dimData=this._storage[dim],dimInfo=this.getDimensionInfo(dim);stack=dimInfo&&dimInfo.stackable&&stack;var value,dimExtent=(this._extent||(this._extent={}))[dim+!!stack];if(dimExtent)return dimExtent;
// var dimInfo = this._dimensionInfos[dim];
if(dimData){
// var isOrdinal = dimInfo.type === 'ordinal';
for(var min=1/0,max=-(1/0),i=0,len=this.count();len>i;i++)value=this.get(dim,i,stack),min>value&&(min=value),value>max&&(max=value);return this._extent[dim+stack]=[min,max]}return[1/0,-(1/0)]},/**
	     * Get sum of data in one dimension
	     * @param {string} dim
	     * @param {boolean} stack
	     */
listProto.getSum=function(dim,stack){var dimData=this._storage[dim],sum=0;if(dimData)for(var i=0,len=this.count();len>i;i++){var value=this.get(dim,i,stack);isNaN(value)||(sum+=value)}return sum},/**
	     * Retreive the index with given value
	     * @param {number} idx
	     * @param {number} value
	     * @return {number}
	     */
// FIXME Precision of float value
listProto.indexOf=function(dim,value){var storage=this._storage,dimData=storage[dim],indices=this.indices;if(dimData)for(var i=0,len=indices.length;len>i;i++){var rawIndex=indices[i];if(dimData[rawIndex]===value)return i}return-1},/**
	     * Retreive the index with given name
	     * @param {number} idx
	     * @param {number} name
	     * @return {number}
	     */
listProto.indexOfName=function(name){for(var indices=this.indices,nameList=this._nameList,i=0,len=indices.length;len>i;i++){var rawIndex=indices[i];if(nameList[rawIndex]===name)return i}return-1},/**
	     * Retreive the index of nearest value
	     * @param {string>} dim
	     * @param {number} value
	     * @param {boolean} stack If given value is after stacked
	     * @return {number}
	     */
listProto.indexOfNearest=function(dim,value,stack){var storage=this._storage,dimData=storage[dim];if(dimData){for(var minDist=Number.MAX_VALUE,nearestIdx=-1,i=0,len=this.count();len>i;i++){var diff=value-this.get(dim,i,stack),dist=Math.abs(diff);(minDist>dist||dist===minDist&&diff>0)&&(minDist=dist,nearestIdx=i)}return nearestIdx}return-1},/**
	     * Get raw data index
	     * @param {number} idx
	     * @return {number}
	     */
listProto.getRawIndex=function(idx){var rawIdx=this.indices[idx];return null==rawIdx?-1:rawIdx},/**
	     * @param {number} idx
	     * @param {boolean} [notDefaultIdx=false]
	     * @return {string}
	     */
listProto.getName=function(idx){return this._nameList[this.indices[idx]]||""},/**
	     * @param {number} idx
	     * @param {boolean} [notDefaultIdx=false]
	     * @return {string}
	     */
listProto.getId=function(idx){return this._idList[this.indices[idx]]||this.getRawIndex(idx)+""},/**
	     * Data iteration
	     * @param {string|Array.<string>}
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     *
	     * @example
	     *  list.each('x', function (x, idx) {});
	     *  list.each(['x', 'y'], function (x, y, idx) {});
	     *  list.each(function (idx) {})
	     */
listProto.each=function(dimensions,cb,stack,context){"function"==typeof dimensions&&(context=stack,stack=cb,cb=dimensions,dimensions=[]),dimensions=zrUtil.map(normalizeDimensions(dimensions),this.getDimension,this);var value=[],dimSize=dimensions.length,indices=this.indices;context=context||this;for(var i=0;i<indices.length;i++)if(0===dimSize)cb.call(context,i);else if(1===dimSize)cb.call(context,this.get(dimensions[0],i,stack),i);else{for(var k=0;dimSize>k;k++)value[k]=this.get(dimensions[k],i,stack);
// Index
value[k]=i,cb.apply(context,value)}},/**
	     * Data filter
	     * @param {string|Array.<string>}
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     */
listProto.filterSelf=function(dimensions,cb,stack,context){"function"==typeof dimensions&&(context=stack,stack=cb,cb=dimensions,dimensions=[]),dimensions=zrUtil.map(normalizeDimensions(dimensions),this.getDimension,this);var newIndices=[],value=[],dimSize=dimensions.length,indices=this.indices;context=context||this;for(var i=0;i<indices.length;i++){var keep;
// Simple optimization
if(1===dimSize)keep=cb.call(context,this.get(dimensions[0],i,stack),i);else{for(var k=0;dimSize>k;k++)value[k]=this.get(dimensions[k],i,stack);value[k]=i,keep=cb.apply(context,value)}keep&&newIndices.push(indices[i])}
// Reset data extent
return this.indices=newIndices,this._extent={},this},/**
	     * Data mapping to a plain array
	     * @param {string|Array.<string>} [dimensions]
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     * @return {Array}
	     */
listProto.mapArray=function(dimensions,cb,stack,context){"function"==typeof dimensions&&(context=stack,stack=cb,cb=dimensions,dimensions=[]);var result=[];return this.each(dimensions,function(){result.push(cb&&cb.apply(this,arguments))},stack,context),result},/**
	     * Data mapping to a new List with given dimensions
	     * @param {string|Array.<string>} dimensions
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     * @return {Array}
	     */
listProto.map=function(dimensions,cb,stack,context){dimensions=zrUtil.map(normalizeDimensions(dimensions),this.getDimension,this);var list=cloneListForMapAndSample(this,dimensions),indices=list.indices=this.indices,storage=list._storage,tmpRetValue=[];return this.each(dimensions,function(){var idx=arguments[arguments.length-1],retValue=cb&&cb.apply(this,arguments);if(null!=retValue){
// a number
"number"==typeof retValue&&(tmpRetValue[0]=retValue,retValue=tmpRetValue);for(var i=0;i<retValue.length;i++){var dim=dimensions[i],dimStore=storage[dim],rawIdx=indices[idx];dimStore&&(dimStore[rawIdx]=retValue[i])}}},stack,context),list},/**
	     * Large data down sampling on given dimension
	     * @param {string} dimension
	     * @param {number} rate
	     * @param {Function} sampleValue
	     * @param {Function} sampleIndex Sample index for name and id
	     */
listProto.downSample=function(dimension,rate,sampleValue,sampleIndex){
// Copy data from original data
for(var list=cloneListForMapAndSample(this,[dimension]),storage=this._storage,targetStorage=list._storage,originalIndices=this.indices,indices=list.indices=[],frameValues=[],frameIndices=[],frameSize=Math.floor(1/rate),dimStore=targetStorage[dimension],len=this.count(),i=0;i<storage[dimension].length;i++)targetStorage[dimension][i]=storage[dimension][i];for(var i=0;len>i;i+=frameSize){
// Last frame
frameSize>len-i&&(frameSize=len-i,frameValues.length=frameSize);for(var k=0;frameSize>k;k++){var idx=originalIndices[i+k];frameValues[k]=dimStore[idx],frameIndices[k]=idx}var value=sampleValue(frameValues),idx=frameIndices[sampleIndex(frameValues,value)||0];
// Only write value on the filtered data
dimStore[idx]=value,indices.push(idx)}return list},/**
	     * Get model of one data item.
	     *
	     * @param {number} idx
	     */
// FIXME Model proxy ?
listProto.getItemModel=function(idx){var hostModel=this.hostModel;return idx=this.indices[idx],new Model(this._rawData[idx],hostModel,hostModel.ecModel)},/**
	     * Create a data differ
	     * @param {module:echarts/data/List} otherList
	     * @return {module:echarts/data/DataDiffer}
	     */
listProto.diff=function(otherList){var idList=this._idList,otherIdList=otherList&&otherList._idList;return new DataDiffer(otherList?otherList.indices:[],this.indices,function(idx){return otherIdList[idx]||idx+""},function(idx){return idList[idx]||idx+""})},/**
	     * Get visual property.
	     * @param {string} key
	     */
listProto.getVisual=function(key){var visual=this._visual;return visual&&visual[key]},/**
	     * Set visual property
	     * @param {string|Object} key
	     * @param {*} [value]
	     *
	     * @example
	     *  setVisual('color', color);
	     *  setVisual({
	     *      'color': color
	     *  });
	     */
listProto.setVisual=function(key,val){if(isObject(key))for(var name in key)key.hasOwnProperty(name)&&this.setVisual(name,key[name]);else this._visual=this._visual||{},this._visual[key]=val},/**
	     * Set layout property.
	     * @param {string} key
	     * @param {*} [val]
	     */
listProto.setLayout=function(key,val){if(isObject(key))for(var name in key)key.hasOwnProperty(name)&&this.setLayout(name,key[name]);else this._layout[key]=val},/**
	     * Get layout property.
	     * @param  {string} key.
	     * @return {*}
	     */
listProto.getLayout=function(key){return this._layout[key]},/**
	     * Get layout of single data item
	     * @param {number} idx
	     */
listProto.getItemLayout=function(idx){return this._itemLayouts[idx]},/**
	     * Set layout of single data item
	     * @param {number} idx
	     * @param {Object} layout
	     * @param {boolean=} [merge=false]
	     */
listProto.setItemLayout=function(idx,layout,merge){this._itemLayouts[idx]=merge?zrUtil.extend(this._itemLayouts[idx]||{},layout):layout},/**
	     * Get visual property of single data item
	     * @param {number} idx
	     * @param {string} key
	     * @param {boolean} ignoreParent
	     */
listProto.getItemVisual=function(idx,key,ignoreParent){var itemVisual=this._itemVisuals[idx],val=itemVisual&&itemVisual[key];return null!=val||ignoreParent?val:this.getVisual(key)},/**
	     * Set visual property of single data item
	     *
	     * @param {number} idx
	     * @param {string|Object} key
	     * @param {*} [value]
	     *
	     * @example
	     *  setItemVisual(0, 'color', color);
	     *  setItemVisual(0, {
	     *      'color': color
	     *  });
	     */
listProto.setItemVisual=function(idx,key,value){var itemVisual=this._itemVisuals[idx]||{};if(this._itemVisuals[idx]=itemVisual,isObject(key))for(var name in key)key.hasOwnProperty(name)&&(itemVisual[name]=key[name]);else itemVisual[key]=value};var setItemDataAndSeriesIndex=function(child){child.seriesIndex=this.seriesIndex,child.dataIndex=this.dataIndex};/**
	     * Set graphic element relative to data. It can be set as null
	     * @param {number} idx
	     * @param {module:zrender/Element} [el]
	     */
listProto.setItemGraphicEl=function(idx,el){var hostModel=this.hostModel;el&&(
// Add data index and series index for indexing the data by element
// Useful in tooltip
el.dataIndex=idx,el.seriesIndex=hostModel&&hostModel.seriesIndex,"group"===el.type&&el.traverse(setItemDataAndSeriesIndex,el)),this._graphicEls[idx]=el},/**
	     * @param {number} idx
	     * @return {module:zrender/Element}
	     */
listProto.getItemGraphicEl=function(idx){return this._graphicEls[idx]},/**
	     * @param {Function} cb
	     * @param {*} context
	     */
listProto.eachItemGraphicEl=function(cb,context){zrUtil.each(this._graphicEls,function(el,idx){el&&cb&&cb.call(context,el,idx)})},/**
	     * Shallow clone a new list except visual and layout properties, and graph elements.
	     * New list only change the indices.
	     */
listProto.cloneShallow=function(){var dimensionInfoList=zrUtil.map(this.dimensions,this.getDimensionInfo,this),list=new List(dimensionInfoList,this.hostModel);
// FIXME
return list._storage=this._storage,transferImmuProperties(list,this,this._wrappedMethods),list.indices=this.indices.slice(),list},/**
	     * Wrap some method to add more feature
	     * @param {string} methodName
	     * @param {Function} injectFunction
	     */
listProto.wrapMethod=function(methodName,injectFunction){var originalMethod=this[methodName];"function"==typeof originalMethod&&(this._wrappedMethods=this._wrappedMethods||[],this._wrappedMethods.push(methodName),this[methodName]=function(){var res=originalMethod.apply(this,arguments);return injectFunction.call(this,res)})},module.exports=List}).call(exports,function(){return this}())},/* 95 */
/***/
function(module,exports){"use strict";function defaultKeyGetter(item){return item}function DataDiffer(oldArr,newArr,oldKeyGetter,newKeyGetter){this._old=oldArr,this._new=newArr,this._oldKeyGetter=oldKeyGetter||defaultKeyGetter,this._newKeyGetter=newKeyGetter||defaultKeyGetter}function initIndexMap(arr,map,keyGetter){for(var i=0;i<arr.length;i++){var key=keyGetter(arr[i]),existence=map[key];null==existence?map[key]=i:(existence.length||(map[key]=existence=[existence]),existence.push(i))}}DataDiffer.prototype={constructor:DataDiffer,/**
	         * Callback function when add a data
	         */
add:function(func){return this._add=func,this},/**
	         * Callback function when update a data
	         */
update:function(func){return this._update=func,this},/**
	         * Callback function when remove a data
	         */
remove:function(func){return this._remove=func,this},execute:function(){var i,oldArr=this._old,newArr=this._new,oldKeyGetter=this._oldKeyGetter,newKeyGetter=this._newKeyGetter,oldDataIndexMap={},newDataIndexMap={};
// Travel by inverted order to make sure order consistency
// when duplicate keys exists (consider newDataIndex.pop() below).
// For performance consideration, these code below do not look neat.
for(initIndexMap(oldArr,oldDataIndexMap,oldKeyGetter),initIndexMap(newArr,newDataIndexMap,newKeyGetter),i=0;i<oldArr.length;i++){var key=oldKeyGetter(oldArr[i]),idx=newDataIndexMap[key];
// idx can never be empty array here. see 'set null' logic below.
if(null!=idx){
// Consider there is duplicate key (for example, use dataItem.name as key).
// We should make sure every item in newArr and oldArr can be visited.
var len=idx.length;len?(1===len&&(newDataIndexMap[key]=null),idx=idx.unshift()):newDataIndexMap[key]=null,this._update&&this._update(idx,i)}else this._remove&&this._remove(i)}for(var key in newDataIndexMap)if(newDataIndexMap.hasOwnProperty(key)){var idx=newDataIndexMap[key];if(null==idx)continue;
// idx can never be empty array here. see 'set null' logic above.
if(idx.length)for(var i=0,len=idx.length;len>i;i++)this._add&&this._add(idx[i]);else this._add&&this._add(idx)}}},module.exports=DataDiffer},/* 96 */
/***/
function(module,exports,__webpack_require__){/**
	     * Complete the dimensions array guessed from the data structure.
	     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']
	     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]
	     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']
	     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.
	     * @return {Array.<string>}
	     */
function completeDimensions(dimensions,data,defaultNames,extraPrefix){if(!data)return dimensions;var value0=retrieveValue(data[0]),dimSize=zrUtil.isArray(value0)&&value0.length||1;defaultNames=defaultNames||[],extraPrefix=extraPrefix||"extra";for(var i=0;dimSize>i;i++)if(!dimensions[i]){var name=defaultNames[i]||extraPrefix+(i-defaultNames.length);dimensions[i]=guessOrdinal(data,i)?{type:"ordinal",name:name}:name}return dimensions}
// The rule should not be complex, otherwise user might not
// be able to known where the data is wrong.
function guessOrdinal(data,dimIndex){for(var i=0,len=data.length;len>i;i++){var value=retrieveValue(data[i]);if(!zrUtil.isArray(value))return!1;var value=value[dimIndex];if(null!=value&&isFinite(value))return!1;if(zrUtil.isString(value)&&"-"!==value)return!0}return!1}function retrieveValue(o){return zrUtil.isArray(o)?o:zrUtil.isObject(o)?o.value:o}/**
	 * Complete dimensions by data (guess dimension).
	 */
var zrUtil=__webpack_require__(3);module.exports=completeDimensions},/* 97 */
/***/
function(module,exports,__webpack_require__){"use strict";function isPointsSame(points1,points2){if(points1.length===points2.length){for(var i=0;i<points1.length;i++){var p1=points1[i],p2=points2[i];if(p1[0]!==p2[0]||p1[1]!==p2[1])return}return!0}}function getSmooth(smooth){return"number"==typeof smooth?smooth:smooth?.3:0}function getAxisExtentWithGap(axis){var extent=axis.getGlobalExtent();if(axis.onBand){
// Remove extra 1px to avoid line miter in clipped edge
var halfBandWidth=axis.getBandWidth()/2-1,dir=extent[1]>extent[0]?1:-1;extent[0]+=dir*halfBandWidth,extent[1]-=dir*halfBandWidth}return extent}function sign(val){return val>=0?1:-1}/**
	     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
	     * @param {module:echarts/data/List} data
	     * @param {Array.<Array.<number>>} points
	     * @private
	     */
function getStackedOnPoints(coordSys,data){var baseAxis=coordSys.getBaseAxis(),valueAxis=coordSys.getOtherAxis(baseAxis),valueStart=baseAxis.onZero?0:valueAxis.scale.getExtent()[0],valueDim=valueAxis.dim,baseDataOffset="x"===valueDim||"radius"===valueDim?1:0;return data.mapArray([valueDim],function(val,idx){
// Find first stacked value with same sign
for(var stackedOnSameSign,stackedOn=data.stackedOn;stackedOn&&sign(stackedOn.get(valueDim,idx))===sign(val);){stackedOnSameSign=stackedOn;break}var stackedData=[];return stackedData[baseDataOffset]=data.get(baseAxis.dim,idx),stackedData[1-baseDataOffset]=stackedOnSameSign?stackedOnSameSign.get(valueDim,idx,!0):valueStart,coordSys.dataToPoint(stackedData)},!0)}function queryDataIndex(data,payload){return null!=payload.dataIndex?payload.dataIndex:null!=payload.name?data.indexOfName(payload.name):void 0}function createGridClipShape(cartesian,hasAnimation,seriesModel){var xExtent=getAxisExtentWithGap(cartesian.getAxis("x")),yExtent=getAxisExtentWithGap(cartesian.getAxis("y")),isHorizontal=cartesian.getBaseAxis().isHorizontal(),x=xExtent[0],y=yExtent[0],width=xExtent[1]-x,height=yExtent[1]-y;
// Expand clip shape to avoid line value exceeds axis
seriesModel.get("clipOverflow")||(isHorizontal?(y-=height,height*=3):(x-=width,width*=3));var clipPath=new graphic.Rect({shape:{x:x,y:y,width:width,height:height}});return hasAnimation&&(clipPath.shape[isHorizontal?"width":"height"]=0,graphic.initProps(clipPath,{shape:{width:width,height:height}},seriesModel)),clipPath}function createPolarClipShape(polar,hasAnimation,seriesModel){var angleAxis=polar.getAngleAxis(),radiusAxis=polar.getRadiusAxis(),radiusExtent=radiusAxis.getExtent(),angleExtent=angleAxis.getExtent(),RADIAN=Math.PI/180,clipPath=new graphic.Sector({shape:{cx:polar.cx,cy:polar.cy,r0:radiusExtent[0],r:radiusExtent[1],startAngle:-angleExtent[0]*RADIAN,endAngle:-angleExtent[1]*RADIAN,clockwise:angleAxis.inverse}});return hasAnimation&&(clipPath.shape.endAngle=-angleExtent[0]*RADIAN,graphic.initProps(clipPath,{shape:{endAngle:-angleExtent[1]*RADIAN}},seriesModel)),clipPath}function createClipShape(coordSys,hasAnimation,seriesModel){return"polar"===coordSys.type?createPolarClipShape(coordSys,hasAnimation,seriesModel):createGridClipShape(coordSys,hasAnimation,seriesModel)}var zrUtil=__webpack_require__(3),SymbolDraw=__webpack_require__(98),Symbol=__webpack_require__(99),lineAnimationDiff=__webpack_require__(101),graphic=__webpack_require__(42),polyHelper=__webpack_require__(102),ChartView=__webpack_require__(41);module.exports=ChartView.extend({type:"line",init:function(){var lineGroup=new graphic.Group,symbolDraw=new SymbolDraw;this.group.add(symbolDraw.group),this._symbolDraw=symbolDraw,this._lineGroup=lineGroup},render:function(seriesModel,ecModel,api){var coordSys=seriesModel.coordinateSystem,group=this.group,data=seriesModel.getData(),lineStyleModel=seriesModel.getModel("lineStyle.normal"),areaStyleModel=seriesModel.getModel("areaStyle.normal"),points=data.mapArray(data.getItemLayout,!0),isCoordSysPolar="polar"===coordSys.type,prevCoordSys=this._coordSys,symbolDraw=this._symbolDraw,polyline=this._polyline,polygon=this._polygon,lineGroup=this._lineGroup,hasAnimation=seriesModel.get("animation"),isAreaChart=!areaStyleModel.isEmpty(),stackedOnPoints=getStackedOnPoints(coordSys,data),showSymbol=seriesModel.get("showSymbol"),isSymbolIgnore=showSymbol&&!isCoordSysPolar&&!seriesModel.get("showAllSymbol")&&this._getSymbolIgnoreFunc(data,coordSys),oldData=this._data;oldData&&oldData.eachItemGraphicEl(function(el,idx){el.__temp&&(group.remove(el),oldData.setItemGraphicEl(idx,null))}),
// Remove previous created symbols if showSymbol changed to false
showSymbol||symbolDraw.remove(),group.add(lineGroup),
// Initialization animation or coordinate system changed
polyline&&prevCoordSys.type===coordSys.type?(isAreaChart&&!polygon?
// If areaStyle is added
polygon=this._newPolygon(points,stackedOnPoints,coordSys,hasAnimation):polygon&&!isAreaChart&&(
// If areaStyle is removed
lineGroup.remove(polygon),polygon=this._polygon=null),
// Update clipPath
lineGroup.setClipPath(createClipShape(coordSys,!1,seriesModel)),
// Always update, or it is wrong in the case turning on legend
// because points are not changed
showSymbol&&symbolDraw.updateData(data,isSymbolIgnore),
// Stop symbol animation and sync with line points
// FIXME performance?
data.eachItemGraphicEl(function(el){el.stopAnimation(!0)}),
// In the case data zoom triggerred refreshing frequently
// Data may not change if line has a category axis. So it should animate nothing
isPointsSame(this._stackedOnPoints,stackedOnPoints)&&isPointsSame(this._points,points)||(hasAnimation?this._updateAnimation(data,stackedOnPoints,coordSys,api):(polyline.setShape({points:points}),polygon&&polygon.setShape({points:points,stackedOnPoints:stackedOnPoints})))):(showSymbol&&symbolDraw.updateData(data,isSymbolIgnore),polyline=this._newPolyline(points,coordSys,hasAnimation),isAreaChart&&(polygon=this._newPolygon(points,stackedOnPoints,coordSys,hasAnimation)),lineGroup.setClipPath(createClipShape(coordSys,!0,seriesModel))),polyline.setStyle(zrUtil.defaults(
// Use color in lineStyle first
lineStyleModel.getLineStyle(),{stroke:data.getVisual("color"),lineJoin:"bevel"}));var smooth=seriesModel.get("smooth");if(smooth=getSmooth(seriesModel.get("smooth")),polyline.setShape({smooth:smooth,smoothMonotone:seriesModel.get("smoothMonotone")}),polygon){var stackedOn=data.stackedOn,stackedOnSmooth=0;if(polygon.style.opacity=.7,polygon.setStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(),{fill:data.getVisual("color"),lineJoin:"bevel"})),stackedOn){var stackedOnSeries=stackedOn.hostModel;stackedOnSmooth=getSmooth(stackedOnSeries.get("smooth"))}polygon.setShape({smooth:smooth,stackedOnSmooth:stackedOnSmooth,smoothMonotone:seriesModel.get("smoothMonotone")})}this._data=data,
// Save the coordinate system for transition animation when data changed
this._coordSys=coordSys,this._stackedOnPoints=stackedOnPoints,this._points=points},highlight:function(seriesModel,ecModel,api,payload){var data=seriesModel.getData(),dataIndex=queryDataIndex(data,payload);if(null!=dataIndex&&dataIndex>=0){var symbol=data.getItemGraphicEl(dataIndex);if(!symbol){
// Create a temporary symbol if it is not exists
var pt=data.getItemLayout(dataIndex);symbol=new Symbol(data,dataIndex,api),symbol.position=pt,symbol.setZ(seriesModel.get("zlevel"),seriesModel.get("z")),symbol.ignore=isNaN(pt[0])||isNaN(pt[1]),symbol.__temp=!0,data.setItemGraphicEl(dataIndex,symbol),
// Stop scale animation
symbol.stopSymbolAnimation(!0),this.group.add(symbol)}symbol.highlight()}else
// Highlight whole series
ChartView.prototype.highlight.call(this,seriesModel,ecModel,api,payload)},downplay:function(seriesModel,ecModel,api,payload){var data=seriesModel.getData(),dataIndex=queryDataIndex(data,payload);if(null!=dataIndex&&dataIndex>=0){var symbol=data.getItemGraphicEl(dataIndex);symbol&&(symbol.__temp?(data.setItemGraphicEl(dataIndex,null),this.group.remove(symbol)):symbol.downplay())}else
// Downplay whole series
ChartView.prototype.downplay.call(this,seriesModel,ecModel,api,payload)},/**
	         * @param {module:zrender/container/Group} group
	         * @param {Array.<Array.<number>>} points
	         * @private
	         */
_newPolyline:function(points){var polyline=this._polyline;
// Remove previous created polyline
return polyline&&this._lineGroup.remove(polyline),polyline=new polyHelper.Polyline({shape:{points:points},silent:!0,z2:10}),this._lineGroup.add(polyline),this._polyline=polyline,polyline},/**
	         * @param {module:zrender/container/Group} group
	         * @param {Array.<Array.<number>>} stackedOnPoints
	         * @param {Array.<Array.<number>>} points
	         * @private
	         */
_newPolygon:function(points,stackedOnPoints){var polygon=this._polygon;
// Remove previous created polygon
return polygon&&this._lineGroup.remove(polygon),polygon=new polyHelper.Polygon({shape:{points:points,stackedOnPoints:stackedOnPoints},silent:!0}),this._lineGroup.add(polygon),this._polygon=polygon,polygon},/**
	         * @private
	         */
_getSymbolIgnoreFunc:function(data,coordSys){var categoryAxis=coordSys.getAxesByScale("ordinal")[0];
// `getLabelInterval` is provided by echarts/component/axis
// `getLabelInterval` is provided by echarts/component/axis
return categoryAxis&&categoryAxis.isLabelIgnored?zrUtil.bind(categoryAxis.isLabelIgnored,categoryAxis):void 0},/**
	         * @private
	         */
// FIXME Two value axis
_updateAnimation:function(data,stackedOnPoints,coordSys,api){var polyline=this._polyline,polygon=this._polygon,seriesModel=data.hostModel,diff=lineAnimationDiff(this._data,data,this._stackedOnPoints,stackedOnPoints,this._coordSys,coordSys);polyline.shape.points=diff.current,graphic.updateProps(polyline,{shape:{points:diff.next}},seriesModel),polygon&&(polygon.setShape({points:diff.current,stackedOnPoints:diff.stackedOnCurrent}),graphic.updateProps(polygon,{shape:{points:diff.next,stackedOnPoints:diff.stackedOnNext}},seriesModel));for(var updatedDataInfo=[],diffStatus=diff.status,i=0;i<diffStatus.length;i++){var cmd=diffStatus[i].cmd;if("="===cmd){var el=data.getItemGraphicEl(diffStatus[i].idx1);el&&updatedDataInfo.push({el:el,ptIdx:i})}}polyline.animators&&polyline.animators.length&&polyline.animators[0].during(function(){for(var i=0;i<updatedDataInfo.length;i++){var el=updatedDataInfo[i].el;el.attr("position",polyline.shape.points[updatedDataInfo[i].ptIdx])}})},remove:function(ecModel){var group=this.group,oldData=this._data;this._lineGroup.removeAll(),this._symbolDraw.remove(!0),
// Remove temporary created elements when highlighting
oldData&&oldData.eachItemGraphicEl(function(el,idx){el.__temp&&(group.remove(el),oldData.setItemGraphicEl(idx,null))}),this._polyline=this._polygon=this._coordSys=this._points=this._stackedOnPoints=this._data=null}})},/* 98 */
/***/
function(module,exports,__webpack_require__){/**
	     * @constructor
	     * @alias module:echarts/chart/helper/SymbolDraw
	     * @param {module:zrender/graphic/Group} [symbolCtor]
	     */
function SymbolDraw(symbolCtor){this.group=new graphic.Group,this._symbolCtor=symbolCtor||Symbol}function symbolNeedsDraw(data,idx,isIgnore){var point=data.getItemLayout(idx);return point&&!isNaN(point[0])&&!isNaN(point[1])&&!(isIgnore&&isIgnore(idx))&&"none"!==data.getItemVisual(idx,"symbol")}/**
	 * @module echarts/chart/helper/SymbolDraw
	 */
var graphic=__webpack_require__(42),Symbol=__webpack_require__(99),symbolDrawProto=SymbolDraw.prototype;/**
	     * Update symbols draw by new data
	     * @param {module:echarts/data/List} data
	     * @param {Array.<boolean>} [isIgnore]
	     */
symbolDrawProto.updateData=function(data,isIgnore){var group=this.group,seriesModel=data.hostModel,oldData=this._data,SymbolCtor=this._symbolCtor;data.diff(oldData).add(function(newIdx){var point=data.getItemLayout(newIdx);if(symbolNeedsDraw(data,newIdx,isIgnore)){var symbolEl=new SymbolCtor(data,newIdx);symbolEl.attr("position",point),data.setItemGraphicEl(newIdx,symbolEl),group.add(symbolEl)}}).update(function(newIdx,oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx),point=data.getItemLayout(newIdx);
// Add back
return symbolNeedsDraw(data,newIdx,isIgnore)?(symbolEl?(symbolEl.updateData(data,newIdx),graphic.updateProps(symbolEl,{position:point},seriesModel)):(symbolEl=new SymbolCtor(data,newIdx),symbolEl.attr("position",point)),group.add(symbolEl),void data.setItemGraphicEl(newIdx,symbolEl)):void group.remove(symbolEl)}).remove(function(oldIdx){var el=oldData.getItemGraphicEl(oldIdx);el&&el.fadeOut(function(){group.remove(el)})}).execute(),this._data=data},symbolDrawProto.updateLayout=function(){var data=this._data;data&&
// Not use animation
data.eachItemGraphicEl(function(el,idx){el.attr("position",data.getItemLayout(idx))})},symbolDrawProto.remove=function(enableAnimation){var group=this.group,data=this._data;data&&(enableAnimation?data.eachItemGraphicEl(function(el){el.fadeOut(function(){group.remove(el)})}):group.removeAll())},module.exports=SymbolDraw},/* 99 */
/***/
function(module,exports,__webpack_require__){function normalizeSymbolSize(symbolSize){return zrUtil.isArray(symbolSize)||(symbolSize=[+symbolSize,+symbolSize]),symbolSize}/**
	     * @constructor
	     * @alias {module:echarts/chart/helper/Symbol}
	     * @param {module:echarts/data/List} data
	     * @param {number} idx
	     * @extends {module:zrender/graphic/Group}
	     */
function Symbol(data,idx){graphic.Group.call(this),this.updateData(data,idx)}function driftSymbol(dx,dy){this.parent.drift(dx,dy)}/**
	 * @module echarts/chart/helper/Symbol
	 */
var zrUtil=__webpack_require__(3),symbolUtil=__webpack_require__(100),graphic=__webpack_require__(42),numberUtil=__webpack_require__(7),symbolProto=Symbol.prototype;symbolProto._createSymbol=function(symbolType,data,idx){
// Remove paths created before
this.removeAll();var seriesModel=data.hostModel,color=data.getItemVisual(idx,"color"),symbolPath=symbolUtil.createSymbol(symbolType,-.5,-.5,1,1,color);symbolPath.attr({style:{strokeNoScale:!0},z2:100,culling:!0,scale:[0,0]}),
// Rewrite drift method
symbolPath.drift=driftSymbol;var size=normalizeSymbolSize(data.getItemVisual(idx,"symbolSize"));graphic.initProps(symbolPath,{scale:size},seriesModel),this._symbolType=symbolType,this.add(symbolPath)},/**
	     * Stop animation
	     * @param {boolean} toLastFrame
	     */
symbolProto.stopSymbolAnimation=function(toLastFrame){this.childAt(0).stopAnimation(toLastFrame)},/**
	     * Get scale(aka, current symbol size).
	     * Including the change caused by animation
	     * @param {Array.<number>} toLastFrame
	     */
symbolProto.getScale=function(){return this.childAt(0).scale},/**
	     * Highlight symbol
	     */
symbolProto.highlight=function(){this.childAt(0).trigger("emphasis")},/**
	     * Downplay symbol
	     */
symbolProto.downplay=function(){this.childAt(0).trigger("normal")},/**
	     * @param {number} zlevel
	     * @param {number} z
	     */
symbolProto.setZ=function(zlevel,z){var symbolPath=this.childAt(0);symbolPath.zlevel=zlevel,symbolPath.z=z},symbolProto.setDraggable=function(draggable){var symbolPath=this.childAt(0);symbolPath.draggable=draggable,symbolPath.cursor=draggable?"move":"pointer"},/**
	     * Update symbol properties
	     * @param  {module:echarts/data/List} data
	     * @param  {number} idx
	     */
symbolProto.updateData=function(data,idx){var symbolType=data.getItemVisual(idx,"symbol")||"circle",seriesModel=data.hostModel,symbolSize=normalizeSymbolSize(data.getItemVisual(idx,"symbolSize"));if(symbolType!==this._symbolType)this._createSymbol(symbolType,data,idx);else{var symbolPath=this.childAt(0);graphic.updateProps(symbolPath,{scale:symbolSize},seriesModel)}this._updateCommon(data,idx,symbolSize),this._seriesModel=seriesModel};
// Update common properties
var normalStyleAccessPath=["itemStyle","normal"],emphasisStyleAccessPath=["itemStyle","emphasis"],normalLabelAccessPath=["label","normal"],emphasisLabelAccessPath=["label","emphasis"];symbolProto._updateCommon=function(data,idx,symbolSize){var symbolPath=this.childAt(0),seriesModel=data.hostModel,itemModel=data.getItemModel(idx),normalItemStyleModel=itemModel.getModel(normalStyleAccessPath),color=data.getItemVisual(idx,"color"),elStyle=symbolPath.style,hoverStyle=itemModel.getModel(emphasisStyleAccessPath).getItemStyle();symbolPath.rotation=itemModel.getShallow("symbolRotate")*Math.PI/180||0;var symbolOffset=itemModel.getShallow("symbolOffset");if(symbolOffset){var pos=symbolPath.position;pos[0]=numberUtil.parsePercent(symbolOffset[0],symbolSize[0]),pos[1]=numberUtil.parsePercent(symbolOffset[1],symbolSize[1])}symbolPath.setColor(color),zrUtil.extend(elStyle,
// Color must be excluded.
// Because symbol provide setColor individually to set fill and stroke
normalItemStyleModel.getItemStyle(["color"]));var opacity=data.getItemVisual(idx,"opacity");null!=opacity&&(elStyle.opacity=opacity);for(var dataType,labelModel=itemModel.getModel(normalLabelAccessPath),hoverLabelModel=itemModel.getModel(emphasisLabelAccessPath),dimensions=data.dimensions.slice(),valueDim=dimensions.pop();"ordinal"===(dataType=data.getDimensionInfo(valueDim).type)||"time"===dataType;)valueDim=dimensions.pop();labelModel.get("show")?(graphic.setText(elStyle,labelModel,color),elStyle.text=zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"normal"),data.get(valueDim,idx))):elStyle.text="",hoverLabelModel.getShallow("show")?(graphic.setText(hoverStyle,hoverLabelModel,color),hoverStyle.text=zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"emphasis"),data.get(valueDim,idx))):hoverStyle.text="";var size=normalizeSymbolSize(data.getItemVisual(idx,"symbolSize"));if(symbolPath.off("mouseover").off("mouseout").off("emphasis").off("normal"),graphic.setHoverStyle(symbolPath,hoverStyle),itemModel.getShallow("hoverAnimation")){var onEmphasis=function(){var ratio=size[1]/size[0];this.animateTo({scale:[Math.max(1.1*size[0],size[0]+3),Math.max(1.1*size[1],size[1]+3*ratio)]},400,"elasticOut")},onNormal=function(){this.animateTo({scale:size},400,"elasticOut")};symbolPath.on("mouseover",onEmphasis).on("mouseout",onNormal).on("emphasis",onEmphasis).on("normal",onNormal)}},symbolProto.fadeOut=function(cb){var symbolPath=this.childAt(0);
// Not show text when animating
symbolPath.style.text="",graphic.updateProps(symbolPath,{scale:[0,0]},this._seriesModel,cb)},zrUtil.inherits(Symbol,graphic.Group),module.exports=Symbol},/* 100 */
/***/
function(module,exports,__webpack_require__){"use strict";
// Symbol factory
var graphic=__webpack_require__(42),BoundingRect=__webpack_require__(15),Triangle=graphic.extendShape({type:"triangle",shape:{cx:0,cy:0,width:0,height:0},buildPath:function(path,shape){var cx=shape.cx,cy=shape.cy,width=shape.width/2,height=shape.height/2;path.moveTo(cx,cy-height),path.lineTo(cx+width,cy+height),path.lineTo(cx-width,cy+height),path.closePath()}}),Diamond=graphic.extendShape({type:"diamond",shape:{cx:0,cy:0,width:0,height:0},buildPath:function(path,shape){var cx=shape.cx,cy=shape.cy,width=shape.width/2,height=shape.height/2;path.moveTo(cx,cy-height),path.lineTo(cx+width,cy),path.lineTo(cx,cy+height),path.lineTo(cx-width,cy),path.closePath()}}),Pin=graphic.extendShape({type:"pin",shape:{
// x, y on the cusp
x:0,y:0,width:0,height:0},buildPath:function(path,shape){var x=shape.x,y=shape.y,w=shape.width/5*3,h=Math.max(w,shape.height),r=w/2,dy=r*r/(h-r),cy=y-h+r+dy,angle=Math.asin(dy/r),dx=Math.cos(angle)*r,tanX=Math.sin(angle),tanY=Math.cos(angle);path.arc(x,cy,r,Math.PI-angle,2*Math.PI+angle);var cpLen=.6*r,cpLen2=.7*r;path.bezierCurveTo(x+dx-tanX*cpLen,cy+dy+tanY*cpLen,x,y-cpLen2,x,y),path.bezierCurveTo(x,y-cpLen2,x-dx+tanX*cpLen,cy+dy+tanY*cpLen,x-dx,cy+dy),path.closePath()}}),Arrow=graphic.extendShape({type:"arrow",shape:{x:0,y:0,width:0,height:0},buildPath:function(ctx,shape){var height=shape.height,width=shape.width,x=shape.x,y=shape.y,dx=width/3*2;ctx.moveTo(x,y),ctx.lineTo(x+dx,y+height),ctx.lineTo(x,y+height/4*3),ctx.lineTo(x-dx,y+height),ctx.lineTo(x,y),ctx.closePath()}}),symbolCtors={line:graphic.Line,rect:graphic.Rect,roundRect:graphic.Rect,square:graphic.Rect,circle:graphic.Circle,diamond:Diamond,pin:Pin,arrow:Arrow,triangle:Triangle},symbolShapeMakers={line:function(x,y,w,h,shape){
// FIXME
shape.x1=x,shape.y1=y+h/2,shape.x2=x+w,shape.y2=y+h/2},rect:function(x,y,w,h,shape){shape.x=x,shape.y=y,shape.width=w,shape.height=h},roundRect:function(x,y,w,h,shape){shape.x=x,shape.y=y,shape.width=w,shape.height=h,shape.r=Math.min(w,h)/4},square:function(x,y,w,h,shape){var size=Math.min(w,h);shape.x=x,shape.y=y,shape.width=size,shape.height=size},circle:function(x,y,w,h,shape){
// Put circle in the center of square
shape.cx=x+w/2,shape.cy=y+h/2,shape.r=Math.min(w,h)/2},diamond:function(x,y,w,h,shape){shape.cx=x+w/2,shape.cy=y+h/2,shape.width=w,shape.height=h},pin:function(x,y,w,h,shape){shape.x=x+w/2,shape.y=y+h/2,shape.width=w,shape.height=h},arrow:function(x,y,w,h,shape){shape.x=x+w/2,shape.y=y+h/2,shape.width=w,shape.height=h},triangle:function(x,y,w,h,shape){shape.cx=x+w/2,shape.cy=y+h/2,shape.width=w,shape.height=h}},symbolBuildProxies={};for(var name in symbolCtors)symbolBuildProxies[name]=new symbolCtors[name];var Symbol=graphic.extendShape({type:"symbol",shape:{symbolType:"",x:0,y:0,width:0,height:0},beforeBrush:function(){var style=this.style,shape=this.shape;
// FIXME
"pin"===shape.symbolType&&"inside"===style.textPosition&&(style.textPosition=["50%","40%"],style.textAlign="center",style.textVerticalAlign="middle")},buildPath:function(ctx,shape){var symbolType=shape.symbolType,proxySymbol=symbolBuildProxies[symbolType];"none"!==shape.symbolType&&(proxySymbol||(symbolType="rect",proxySymbol=symbolBuildProxies[symbolType]),symbolShapeMakers[symbolType](shape.x,shape.y,shape.width,shape.height,proxySymbol.shape),proxySymbol.buildPath(ctx,proxySymbol.shape))}}),symbolPathSetColor=function(color){if("image"!==this.type){var symbolStyle=this.style,symbolShape=this.shape;symbolShape&&"line"===symbolShape.symbolType?symbolStyle.stroke=color:this.__isEmptyBrush?(symbolStyle.stroke=color,symbolStyle.fill="#fff"):(
// FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
symbolStyle.fill&&(symbolStyle.fill=color),symbolStyle.stroke&&(symbolStyle.stroke=color)),this.dirty()}},symbolUtil={/**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {string} color
	         */
createSymbol:function(symbolType,x,y,w,h,color){var isEmpty=0===symbolType.indexOf("empty");isEmpty&&(symbolType=symbolType.substr(5,1).toLowerCase()+symbolType.substr(6));var symbolPath;return symbolPath=0===symbolType.indexOf("image://")?new graphic.Image({style:{image:symbolType.slice(8),x:x,y:y,width:w,height:h}}):0===symbolType.indexOf("path://")?graphic.makePath(symbolType.slice(7),{},new BoundingRect(x,y,w,h)):new Symbol({shape:{symbolType:symbolType,x:x,y:y,width:w,height:h}}),symbolPath.__isEmptyBrush=isEmpty,symbolPath.setColor=symbolPathSetColor,symbolPath.setColor(color),symbolPath}};module.exports=symbolUtil},/* 101 */
/***/
function(module,exports){
// var arrayDiff = require('zrender/lib/core/arrayDiff');
// 'zrender/core/arrayDiff' has been used before, but it did
// not do well in performance when roam with fixed dataZoom window.
function sign(val){return val>=0?1:-1}function getStackedOnPoint(coordSys,data,idx){
// Find first stacked value with same sign
for(var stackedOnSameSign,baseAxis=coordSys.getBaseAxis(),valueAxis=coordSys.getOtherAxis(baseAxis),valueStart=baseAxis.onZero?0:valueAxis.scale.getExtent()[0],valueDim=valueAxis.dim,baseDataOffset="x"===valueDim||"radius"===valueDim?1:0,stackedOn=data.stackedOn,val=data.get(valueDim,idx);stackedOn&&sign(stackedOn.get(valueDim,idx))===sign(val);){stackedOnSameSign=stackedOn;break}var stackedData=[];return stackedData[baseDataOffset]=data.get(baseAxis.dim,idx),stackedData[1-baseDataOffset]=stackedOnSameSign?stackedOnSameSign.get(valueDim,idx,!0):valueStart,coordSys.dataToPoint(stackedData)}
// function convertToIntId(newIdList, oldIdList) {
//     // Generate int id instead of string id.
//     // Compare string maybe slow in score function of arrDiff
//     // Assume id in idList are all unique
//     var idIndicesMap = {};
//     var idx = 0;
//     for (var i = 0; i < newIdList.length; i++) {
//         idIndicesMap[newIdList[i]] = idx;
//         newIdList[i] = idx++;
//     }
//     for (var i = 0; i < oldIdList.length; i++) {
//         var oldId = oldIdList[i];
//         // Same with newIdList
//         if (idIndicesMap[oldId]) {
//             oldIdList[i] = idIndicesMap[oldId];
//         }
//         else {
//             oldIdList[i] = idx++;
//         }
//     }
// }
function diffData(oldData,newData){var diffResult=[];return newData.diff(oldData).add(function(idx){diffResult.push({cmd:"+",idx:idx})}).update(function(newIdx,oldIdx){diffResult.push({cmd:"=",idx:oldIdx,idx1:newIdx})}).remove(function(idx){diffResult.push({cmd:"-",idx:idx})}).execute(),diffResult}module.exports=function(oldData,newData,oldStackedOnPoints,newStackedOnPoints,oldCoordSys,newCoordSys){for(var diff=diffData(oldData,newData),currPoints=[],nextPoints=[],currStackedPoints=[],nextStackedPoints=[],status=[],sortedIndices=[],rawIndices=[],dims=newCoordSys.dimensions,i=0;i<diff.length;i++){var diffItem=diff[i],pointAdded=!0;
// FIXME, animation is not so perfect when dataZoom window moves fast
// Which is in case remvoing or add more than one data in the tail or head
switch(diffItem.cmd){case"=":var currentPt=oldData.getItemLayout(diffItem.idx),nextPt=newData.getItemLayout(diffItem.idx1);
// If previous data is NaN, use next point directly
(isNaN(currentPt[0])||isNaN(currentPt[1]))&&(currentPt=nextPt.slice()),currPoints.push(currentPt),nextPoints.push(nextPt),currStackedPoints.push(oldStackedOnPoints[diffItem.idx]),nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]),rawIndices.push(newData.getRawIndex(diffItem.idx1));break;case"+":var idx=diffItem.idx;currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0],idx,!0),newData.get(dims[1],idx,!0)])),nextPoints.push(newData.getItemLayout(idx).slice()),currStackedPoints.push(getStackedOnPoint(oldCoordSys,newData,idx)),nextStackedPoints.push(newStackedOnPoints[idx]),rawIndices.push(newData.getRawIndex(idx));break;case"-":var idx=diffItem.idx,rawIndex=oldData.getRawIndex(idx);
// Data is replaced. In the case of dynamic data queue
// FIXME FIXME FIXME
rawIndex!==idx?(currPoints.push(oldData.getItemLayout(idx)),nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0],idx,!0),oldData.get(dims[1],idx,!0)])),currStackedPoints.push(oldStackedOnPoints[idx]),nextStackedPoints.push(getStackedOnPoint(newCoordSys,oldData,idx)),rawIndices.push(rawIndex)):pointAdded=!1}
// Original indices
pointAdded&&(status.push(diffItem),sortedIndices.push(sortedIndices.length))}
// Diff result may be crossed if all items are changed
// Sort by data index
sortedIndices.sort(function(a,b){return rawIndices[a]-rawIndices[b]});for(var sortedCurrPoints=[],sortedNextPoints=[],sortedCurrStackedPoints=[],sortedNextStackedPoints=[],sortedStatus=[],i=0;i<sortedIndices.length;i++){var idx=sortedIndices[i];sortedCurrPoints[i]=currPoints[idx],sortedNextPoints[i]=nextPoints[idx],sortedCurrStackedPoints[i]=currStackedPoints[idx],sortedNextStackedPoints[i]=nextStackedPoints[idx],sortedStatus[i]=status[idx]}return{current:sortedCurrPoints,next:sortedNextPoints,stackedOnCurrent:sortedCurrStackedPoints,stackedOnNext:sortedNextStackedPoints,status:sortedStatus}}},/* 102 */
/***/
function(module,exports,__webpack_require__){function drawSegment(ctx,points,start,stop,len,dir,smoothMin,smoothMax,smooth,smoothMonotone){for(var idx=start,k=0;len>k;k++){var p=points[idx];if(idx>=stop||0>idx||isNaN(p[0])||isNaN(p[1]))break;if(idx===start)ctx[dir>0?"moveTo":"lineTo"](p[0],p[1]),v2Copy(cp0,p);else if(smooth>0){var prevIdx=idx-dir,nextIdx=idx+dir,ratioNextSeg=.5,prevP=points[prevIdx],nextP=points[nextIdx];
// Last point
if(dir>0&&(idx===len-1||isNaN(nextP[0])||isNaN(nextP[1]))||0>=dir&&(0===idx||isNaN(nextP[0])||isNaN(nextP[1])))v2Copy(cp1,p);else{
// If next data is null
(isNaN(nextP[0])||isNaN(nextP[1]))&&(nextP=p),vec2.sub(v,nextP,prevP);var lenPrevSeg,lenNextSeg;if("x"===smoothMonotone||"y"===smoothMonotone){var dim="x"===smoothMonotone?0:1;lenPrevSeg=Math.abs(p[dim]-prevP[dim]),lenNextSeg=Math.abs(p[dim]-nextP[dim])}else lenPrevSeg=vec2.dist(p,prevP),lenNextSeg=vec2.dist(p,nextP);
// Use ratio of seg length
ratioNextSeg=lenNextSeg/(lenNextSeg+lenPrevSeg),scaleAndAdd(cp1,p,v,-smooth*(1-ratioNextSeg))}
// Smooth constraint
vec2Min(cp0,cp0,smoothMax),vec2Max(cp0,cp0,smoothMin),vec2Min(cp1,cp1,smoothMax),vec2Max(cp1,cp1,smoothMin),ctx.bezierCurveTo(cp0[0],cp0[1],cp1[0],cp1[1],p[0],p[1]),
// cp0 of next segment
scaleAndAdd(cp0,p,v,smooth*ratioNextSeg)}else ctx.lineTo(p[0],p[1]);idx+=dir}return k}function getBoundingBox(points,smoothConstraint){var ptMin=[1/0,1/0],ptMax=[-(1/0),-(1/0)];if(smoothConstraint)for(var i=0;i<points.length;i++){var pt=points[i];pt[0]<ptMin[0]&&(ptMin[0]=pt[0]),pt[1]<ptMin[1]&&(ptMin[1]=pt[1]),pt[0]>ptMax[0]&&(ptMax[0]=pt[0]),pt[1]>ptMax[1]&&(ptMax[1]=pt[1])}return{min:smoothConstraint?ptMin:ptMax,max:smoothConstraint?ptMax:ptMin}}
// Poly path support NaN point
var Path=__webpack_require__(44),vec2=__webpack_require__(16),vec2Min=vec2.min,vec2Max=vec2.max,scaleAndAdd=vec2.scaleAndAdd,v2Copy=vec2.copy,v=[],cp0=[],cp1=[];module.exports={Polyline:Path.extend({type:"ec-polyline",shape:{points:[],smooth:0,smoothConstraint:!0,smoothMonotone:null},style:{fill:null,stroke:"#000"},buildPath:function(ctx,shape){for(var points=shape.points,i=0,len=points.length,result=getBoundingBox(points,shape.smoothConstraint);len>i;)i+=drawSegment(ctx,points,i,len,len,1,result.min,result.max,shape.smooth,shape.smoothMonotone)+1}}),Polygon:Path.extend({type:"ec-polygon",shape:{points:[],
// Offset between stacked base points and points
stackedOnPoints:[],smooth:0,stackedOnSmooth:0,smoothConstraint:!0,smoothMonotone:null},buildPath:function(ctx,shape){for(var points=shape.points,stackedOnPoints=shape.stackedOnPoints,i=0,len=points.length,smoothMonotone=shape.smoothMonotone,bbox=getBoundingBox(points,shape.smoothConstraint),stackedOnBBox=getBoundingBox(stackedOnPoints,shape.smoothConstraint);len>i;){var k=drawSegment(ctx,points,i,len,len,1,bbox.min,bbox.max,shape.smooth,smoothMonotone);drawSegment(ctx,stackedOnPoints,i+k-1,len,k,-1,stackedOnBBox.min,stackedOnBBox.max,shape.stackedOnSmooth,smoothMonotone),i+=k+1,ctx.closePath()}}})}},/* 103 */
/***/
function(module,exports){module.exports=function(seriesType,defaultSymbolType,legendSymbol,ecModel,api){
// Encoding visual for all series include which is filtered for legend drawing
ecModel.eachRawSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData(),symbolType=seriesModel.get("symbol")||defaultSymbolType,symbolSize=seriesModel.get("symbolSize");data.setVisual({legendSymbol:legendSymbol||symbolType,symbol:symbolType,symbolSize:symbolSize}),
// Only visible series has each data be visual encoded
ecModel.isSeriesFiltered(seriesModel)||("function"==typeof symbolSize&&data.each(function(idx){var rawValue=seriesModel.getRawValue(idx),params=seriesModel.getDataParams(idx);data.setItemVisual(idx,"symbolSize",symbolSize(rawValue,params))}),data.each(function(idx){var itemModel=data.getItemModel(idx),itemSymbolType=itemModel.get("symbol",!0),itemSymbolSize=itemModel.get("symbolSize",!0);
// If has item symbol
null!=itemSymbolType&&data.setItemVisual(idx,"symbol",itemSymbolType),null!=itemSymbolSize&&
// PENDING Transform symbolSize ?
data.setItemVisual(idx,"symbolSize",itemSymbolSize)}))})}},/* 104 */
/***/
function(module,exports){module.exports=function(seriesType,ecModel,api){ecModel.eachSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData(),coordSys=seriesModel.coordinateSystem,dims=coordSys.dimensions;data.each(dims,function(x,y,idx){var point;point=isNaN(x)||isNaN(y)?[NaN,NaN]:coordSys.dataToPoint([x,y]),data.setItemLayout(idx,point)},!0)})}},/* 105 */
/***/
function(module,exports){var samplers={average:function(frame){for(var sum=0,count=0,i=0;i<frame.length;i++)isNaN(frame[i])||(sum+=frame[i],count++);
// Return NaN if count is 0
return 0===count?NaN:sum/count},sum:function(frame){for(var sum=0,i=0;i<frame.length;i++)
// Ignore NaN
sum+=frame[i]||0;return sum},max:function(frame){for(var max=-(1/0),i=0;i<frame.length;i++)frame[i]>max&&(max=frame[i]);return max},min:function(frame){for(var min=1/0,i=0;i<frame.length;i++)frame[i]<min&&(min=frame[i]);return min},
// TODO
// Median
nearest:function(frame){return frame[0]}},indexSampler=function(frame,value){return Math.round(frame.length/2)};module.exports=function(seriesType,ecModel,api){ecModel.eachSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData(),sampling=seriesModel.get("sampling"),coordSys=seriesModel.coordinateSystem;
// Only cartesian2d support down sampling
if("cartesian2d"===coordSys.type&&sampling){var baseAxis=coordSys.getBaseAxis(),valueAxis=coordSys.getOtherAxis(baseAxis),extent=baseAxis.getExtent(),size=extent[1]-extent[0],rate=Math.round(data.count()/size);if(rate>1){var sampler;"string"==typeof sampling?sampler=samplers[sampling]:"function"==typeof sampling&&(sampler=sampling),sampler&&(data=data.downSample(valueAxis.dim,1/rate,sampler,indexSampler),seriesModel.setData(data))}}},this)}},/* 106 */
/***/
function(module,exports,__webpack_require__){"use strict";var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3);__webpack_require__(107),__webpack_require__(124),
// Grid view
__webpack_require__(1).extendComponentView({type:"grid",render:function(gridModel,ecModel){this.group.removeAll(),gridModel.get("show")&&this.group.add(new graphic.Rect({shape:gridModel.coordinateSystem.getRect(),style:zrUtil.defaults({fill:gridModel.get("backgroundColor")},gridModel.getItemStyle()),silent:!0}))}})},/* 107 */
/***/
function(module,exports,__webpack_require__){/**
	     * Check if the axis is used in the specified grid
	     * @inner
	     */
function isAxisUsedInTheGrid(axisModel,gridModel,ecModel){return ecModel.getComponent("grid",axisModel.get("gridIndex"))===gridModel}function getLabelUnionRect(axis){var rect,axisModel=axis.model,labels=axisModel.getFormattedLabels(),step=1,labelCount=labels.length;labelCount>40&&(
// Simple optimization for large amount of labels
step=Math.ceil(labelCount/40));for(var i=0;labelCount>i;i+=step)if(!axis.isLabelIgnored(i)){var singleRect=axisModel.getTextRect(labels[i]);rect?rect.union(singleRect):rect=singleRect}return rect}function Grid(gridModel,ecModel,api){/**
	         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
	         * @private
	         */
this._coordsMap={},/**
	         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
	         * @private
	         */
this._coordsList=[],/**
	         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
	         * @private
	         */
this._axesMap={},/**
	         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
	         * @private
	         */
this._axesList=[],this._initCartesian(gridModel,ecModel,api),this._model=gridModel}/**
	     * @inner
	     */
function updateAxisTransfrom(axis,coordBase){var axisExtent=axis.getExtent(),axisExtentSum=axisExtent[0]+axisExtent[1];
// Fast transform
axis.toGlobalCoord="x"===axis.dim?function(coord){return coord+coordBase}:function(coord){return axisExtentSum-coord+coordBase},axis.toLocalCoord="x"===axis.dim?function(coord){return coord-coordBase}:function(coord){return axisExtentSum-coord+coordBase}}/**
	 * Grid is a region which contains at most 4 cartesian systems
	 *
	 * TODO Default cartesian
	 */
var layout=__webpack_require__(21),axisHelper=__webpack_require__(108),zrUtil=__webpack_require__(3),Cartesian2D=__webpack_require__(114),Axis2D=__webpack_require__(116),each=zrUtil.each,ifAxisCrossZero=axisHelper.ifAxisCrossZero,niceScaleExtent=axisHelper.niceScaleExtent;
// 依赖 GridModel, AxisModel 做预处理
__webpack_require__(119);var gridProto=Grid.prototype;gridProto.type="grid",gridProto.getRect=function(){return this._rect},gridProto.update=function(ecModel,api){function ifAxisCanNotOnZero(otherAxisDim){var axes=axesMap[otherAxisDim];for(var idx in axes){var axis=axes[idx];if(axis&&("category"===axis.type||!ifAxisCrossZero(axis)))return!0}return!1}var axesMap=this._axesMap;this._updateScale(ecModel,this._model),each(axesMap.x,function(xAxis){niceScaleExtent(xAxis,xAxis.model)}),each(axesMap.y,function(yAxis){niceScaleExtent(yAxis,yAxis.model)}),
// Fix configuration
each(axesMap.x,function(xAxis){
// onZero can not be enabled in these two situations
// 1. When any other axis is a category axis
// 2. When any other axis not across 0 point
ifAxisCanNotOnZero("y")&&(xAxis.onZero=!1)}),each(axesMap.y,function(yAxis){ifAxisCanNotOnZero("x")&&(yAxis.onZero=!1)}),
// Resize again if containLabel is enabled
// FIXME It may cause getting wrong grid size in data processing stage
this.resize(this._model,api)},/**
	     * Resize the grid
	     * @param {module:echarts/coord/cartesian/GridModel} gridModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
gridProto.resize=function(gridModel,api){function adjustAxes(){each(axesList,function(axis){var isHorizontal=axis.isHorizontal(),extent=isHorizontal?[0,gridRect.width]:[0,gridRect.height],idx=axis.inverse?1:0;axis.setExtent(extent[idx],extent[1-idx]),updateAxisTransfrom(axis,isHorizontal?gridRect.x:gridRect.y)})}var gridRect=layout.getLayoutRect(gridModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()});this._rect=gridRect;var axesList=this._axesList;adjustAxes(),
// Minus label size
gridModel.get("containLabel")&&(each(axesList,function(axis){if(!axis.model.get("axisLabel.inside")){var labelUnionRect=getLabelUnionRect(axis);if(labelUnionRect){var dim=axis.isHorizontal()?"height":"width",margin=axis.model.get("axisLabel.margin");gridRect[dim]-=labelUnionRect[dim]+margin,"top"===axis.position?gridRect.y+=labelUnionRect.height+margin:"left"===axis.position&&(gridRect.x+=labelUnionRect.width+margin)}}}),adjustAxes())},/**
	     * @param {string} axisType
	     * @param {ndumber} [axisIndex]
	     */
gridProto.getAxis=function(axisType,axisIndex){var axesMapOnDim=this._axesMap[axisType];if(null!=axesMapOnDim){if(null==axisIndex)
// Find first axis
for(var name in axesMapOnDim)return axesMapOnDim[name];return axesMapOnDim[axisIndex]}},gridProto.getCartesian=function(xAxisIndex,yAxisIndex){var key="x"+xAxisIndex+"y"+yAxisIndex;return this._coordsMap[key]},/**
	     * Initialize cartesian coordinate systems
	     * @private
	     */
gridProto._initCartesian=function(gridModel,ecModel,api){function createAxisCreator(axisType){return function(axisModel,idx){if(isAxisUsedInTheGrid(axisModel,gridModel,ecModel)){var axisPosition=axisModel.get("position");"x"===axisType?(
// Fix position
"top"!==axisPosition&&"bottom"!==axisPosition&&(
// Default bottom of X
axisPosition="bottom"),axisPositionUsed[axisPosition]&&(axisPosition="top"===axisPosition?"bottom":"top")):(
// Fix position
"left"!==axisPosition&&"right"!==axisPosition&&(
// Default left of Y
axisPosition="left"),axisPositionUsed[axisPosition]&&(axisPosition="left"===axisPosition?"right":"left")),axisPositionUsed[axisPosition]=!0;var axis=new Axis2D(axisType,axisHelper.createScaleByModel(axisModel),[0,0],axisModel.get("type"),axisPosition),isCategory="category"===axis.type;axis.onBand=isCategory&&axisModel.get("boundaryGap"),axis.inverse=axisModel.get("inverse"),axis.onZero=axisModel.get("axisLine.onZero"),
// Inject axis into axisModel
axisModel.axis=axis,
// Inject axisModel into axis
axis.model=axisModel,
// Index of axis, can be used as key
axis.index=idx,this._axesList.push(axis),axesMap[axisType][idx]=axis,axesCount[axisType]++}}}var axisPositionUsed={left:!1,right:!1,top:!1,bottom:!1},axesMap={x:{},y:{}},axesCount={x:0,y:0};
/// Create axis
/// Create cartesian2d
// Roll back when there no either x or y axis
return ecModel.eachComponent("xAxis",createAxisCreator("x"),this),ecModel.eachComponent("yAxis",createAxisCreator("y"),this),axesCount.x&&axesCount.y?(this._axesMap=axesMap,void each(axesMap.x,function(xAxis,xAxisIndex){each(axesMap.y,function(yAxis,yAxisIndex){var key="x"+xAxisIndex+"y"+yAxisIndex,cartesian=new Cartesian2D(key);cartesian.grid=this,this._coordsMap[key]=cartesian,this._coordsList.push(cartesian),cartesian.addAxis(xAxis),cartesian.addAxis(yAxis)},this)},this)):(this._axesMap={},void(this._axesList=[]))},/**
	     * Update cartesian properties from series
	     * @param  {module:echarts/model/Option} option
	     * @private
	     */
gridProto._updateScale=function(ecModel,gridModel){function unionExtent(data,axis,seriesModel){each(seriesModel.coordDimToDataDim(axis.dim),function(dim){axis.scale.unionExtent(data.getDataExtent(dim,"ordinal"!==axis.scale.type))})}
// Reset scale
zrUtil.each(this._axesList,function(axis){axis.scale.setExtent(1/0,-(1/0))}),ecModel.eachSeries(function(seriesModel){if("cartesian2d"===seriesModel.get("coordinateSystem")){var xAxisIndex=seriesModel.get("xAxisIndex"),yAxisIndex=seriesModel.get("yAxisIndex"),xAxisModel=ecModel.getComponent("xAxis",xAxisIndex),yAxisModel=ecModel.getComponent("yAxis",yAxisIndex);if(!isAxisUsedInTheGrid(xAxisModel,gridModel,ecModel)||!isAxisUsedInTheGrid(yAxisModel,gridModel,ecModel))return;var cartesian=this.getCartesian(xAxisIndex,yAxisIndex),data=seriesModel.getData(),xAxis=cartesian.getAxis("x"),yAxis=cartesian.getAxis("y");"list"===data.type&&(unionExtent(data,xAxis,seriesModel),unionExtent(data,yAxis,seriesModel))}},this)},Grid.create=function(ecModel,api){var grids=[];
// Inject the coordinateSystems into seriesModel
return ecModel.eachComponent("grid",function(gridModel,idx){var grid=new Grid(gridModel,ecModel,api);grid.name="grid_"+idx,grid.resize(gridModel,api),gridModel.coordinateSystem=grid,grids.push(grid)}),ecModel.eachSeries(function(seriesModel){if("cartesian2d"===seriesModel.get("coordinateSystem")){var xAxisIndex=seriesModel.get("xAxisIndex"),xAxisModel=ecModel.getComponent("xAxis",xAxisIndex),grid=grids[xAxisModel.get("gridIndex")];seriesModel.coordinateSystem=grid.getCartesian(xAxisIndex,seriesModel.get("yAxisIndex"))}}),grids},
// For deciding which dimensions to use when creating list data
Grid.dimensions=Cartesian2D.prototype.dimensions,__webpack_require__(25).register("cartesian2d",Grid),module.exports=Grid},/* 108 */
/***/
function(module,exports,__webpack_require__){var OrdinalScale=__webpack_require__(109),IntervalScale=__webpack_require__(111);__webpack_require__(112),__webpack_require__(113);var Scale=__webpack_require__(110),numberUtil=__webpack_require__(7),zrUtil=__webpack_require__(3),textContain=__webpack_require__(14),axisHelper={};/**
	     * Get axis scale extent before niced.
	     */
axisHelper.getScaleExtent=function(axis,model){var scale=axis.scale,originalExtent=scale.getExtent(),span=originalExtent[1]-originalExtent[0];if("ordinal"===scale.type)
// If series has no data, scale extent may be wrong
// If series has no data, scale extent may be wrong
return isFinite(span)?originalExtent:[0,0];var min=model.getMin?model.getMin():model.get("min"),max=model.getMax?model.getMax():model.get("max"),crossZero=model.getNeedCrossZero?model.getNeedCrossZero():!model.get("scale"),boundaryGap=model.get("boundaryGap");zrUtil.isArray(boundaryGap)||(boundaryGap=[boundaryGap||0,boundaryGap||0]),boundaryGap[0]=numberUtil.parsePercent(boundaryGap[0],1),boundaryGap[1]=numberUtil.parsePercent(boundaryGap[1],1);var fixMin=!0,fixMax=!0;
// Add boundary gap
// TODO Only one data
// Evaluate if axis needs cross zero
// Axis is over zero and min is not set
// Axis is under zero and max is not set
return null==min&&(min=originalExtent[0]-boundaryGap[0]*span,fixMin=!1),null==max&&(max=originalExtent[1]+boundaryGap[1]*span,fixMax=!1),"dataMin"===min&&(min=originalExtent[0]),"dataMax"===max&&(max=originalExtent[1]),crossZero&&(min>0&&max>0&&!fixMin&&(min=0),0>min&&0>max&&!fixMax&&(max=0)),[min,max]},axisHelper.niceScaleExtent=function(axis,model){var scale=axis.scale,extent=axisHelper.getScaleExtent(axis,model),fixMin=null!=(model.getMin?model.getMin():model.get("min")),fixMax=null!=(model.getMax?model.getMax():model.get("max"));scale.setExtent(extent[0],extent[1]),scale.niceExtent(model.get("splitNumber"),fixMin,fixMax);
// If some one specified the min, max. And the default calculated interval
// is not good enough. He can specify the interval. It is often appeared
// in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
// to be 60.
// FIXME
var interval=model.get("interval");null!=interval&&scale.setInterval&&scale.setInterval(interval)},/**
	     * @param {module:echarts/model/Model} model
	     * @param {string} [axisType] Default retrieve from model.type
	     * @return {module:echarts/scale/*}
	     */
axisHelper.createScaleByModel=function(model,axisType){if(axisType=axisType||model.get("type"))switch(axisType){
// Buildin scale
case"category":return new OrdinalScale(model.getCategories(),[1/0,-(1/0)]);case"value":return new IntervalScale;
// Extended scale, like time and log
default:return(Scale.getClass(axisType)||IntervalScale).create(model)}},/**
	     * Check if the axis corss 0
	     */
axisHelper.ifAxisCrossZero=function(axis){var dataExtent=axis.scale.getExtent(),min=dataExtent[0],max=dataExtent[1];return!(min>0&&max>0||0>min&&0>max)},/**
	     * @param {Array.<number>} tickCoords In axis self coordinate.
	     * @param {Array.<string>} labels
	     * @param {string} font
	     * @param {boolean} isAxisHorizontal
	     * @return {number}
	     */
axisHelper.getAxisLabelInterval=function(tickCoords,labels,font,isAxisHorizontal){
// FIXME
// 不同角的axis和label，不只是horizontal和vertical.
var textSpaceTakenRect,autoLabelInterval=0,accumulatedLabelInterval=0,step=1;labels.length>40&&(
// Simple optimization for large amount of labels
step=Math.round(labels.length/40));for(var i=0;i<tickCoords.length;i+=step){var tickCoord=tickCoords[i],rect=textContain.getBoundingRect(labels[i],font,"center","top");rect[isAxisHorizontal?"x":"y"]+=tickCoord,rect[isAxisHorizontal?"width":"height"]*=1.5,textSpaceTakenRect?textSpaceTakenRect.intersect(rect)?(accumulatedLabelInterval++,autoLabelInterval=Math.max(autoLabelInterval,accumulatedLabelInterval)):(textSpaceTakenRect.union(rect),accumulatedLabelInterval=0):textSpaceTakenRect=rect.clone()}return 0===autoLabelInterval&&step>1?step:autoLabelInterval*step},/**
	     * @param {Object} axis
	     * @param {Function} labelFormatter
	     * @return {Array.<string>}
	     */
axisHelper.getFormattedLabels=function(axis,labelFormatter){var scale=axis.scale,labels=scale.getTicksLabels(),ticks=scale.getTicks();return"string"==typeof labelFormatter?(labelFormatter=function(tpl){return function(val){return tpl.replace("{value}",val)}}(labelFormatter),zrUtil.map(labels,labelFormatter)):"function"==typeof labelFormatter?zrUtil.map(ticks,function(tick,idx){return labelFormatter("category"===axis.type?scale.getLabel(tick):tick,idx)},this):labels},module.exports=axisHelper},/* 109 */
/***/
function(module,exports,__webpack_require__){/**
	 * Linear continuous scale
	 * @module echarts/coord/scale/Ordinal
	 *
	 * http://en.wikipedia.org/wiki/Level_of_measurement
	 */
// FIXME only one data
var zrUtil=__webpack_require__(3),Scale=__webpack_require__(110),scaleProto=Scale.prototype,OrdinalScale=Scale.extend({type:"ordinal",init:function(data,extent){this._data=data,this._extent=extent||[0,data.length-1]},parse:function(val){return"string"==typeof val?zrUtil.indexOf(this._data,val):Math.round(val)},contain:function(rank){return rank=this.parse(rank),scaleProto.contain.call(this,rank)&&null!=this._data[rank]},/**
	         * Normalize given rank or name to linear [0, 1]
	         * @param {number|string} [val]
	         * @return {number}
	         */
normalize:function(val){return scaleProto.normalize.call(this,this.parse(val))},scale:function(val){return Math.round(scaleProto.scale.call(this,val))},/**
	         * @return {Array}
	         */
getTicks:function(){for(var ticks=[],extent=this._extent,rank=extent[0];rank<=extent[1];)ticks.push(rank),rank++;return ticks},/**
	         * Get item on rank n
	         * @param {number} n
	         * @return {string}
	         */
getLabel:function(n){return this._data[n]},/**
	         * @return {number}
	         */
count:function(){return this._extent[1]-this._extent[0]+1},niceTicks:zrUtil.noop,niceExtent:zrUtil.noop});/**
	     * @return {module:echarts/scale/Time}
	     */
OrdinalScale.create=function(){return new OrdinalScale},module.exports=OrdinalScale},/* 110 */
/***/
function(module,exports,__webpack_require__){function Scale(){/**
	         * Extent
	         * @type {Array.<number>}
	         * @protected
	         */
this._extent=[1/0,-(1/0)],/**
	         * Step is calculated in adjustExtent
	         * @type {Array.<number>}
	         * @protected
	         */
this._interval=0,this.init&&this.init.apply(this,arguments)}/**
	 * // Scale class management
	 * @module echarts/scale/Scale
	 */
var clazzUtil=__webpack_require__(9),scaleProto=Scale.prototype;/**
	     * Parse input val to valid inner number.
	     * @param {*} val
	     * @return {number}
	     */
scaleProto.parse=function(val){
// Notice: This would be a trap here, If the implementation
// of this method depends on extent, and this method is used
// before extent set (like in dataZoom), it would be wrong.
// Nevertheless, parse does not depend on extent generally.
return val},scaleProto.contain=function(val){var extent=this._extent;return val>=extent[0]&&val<=extent[1]},/**
	     * Normalize value to linear [0, 1], return 0.5 if extent span is 0
	     * @param {number} val
	     * @return {number}
	     */
scaleProto.normalize=function(val){var extent=this._extent;return extent[1]===extent[0]?.5:(val-extent[0])/(extent[1]-extent[0])},/**
	     * Scale normalized value
	     * @param {number} val
	     * @return {number}
	     */
scaleProto.scale=function(val){var extent=this._extent;return val*(extent[1]-extent[0])+extent[0]},/**
	     * Set extent from data
	     * @param {Array.<number>} other
	     */
scaleProto.unionExtent=function(other){var extent=this._extent;other[0]<extent[0]&&(extent[0]=other[0]),other[1]>extent[1]&&(extent[1]=other[1])},/**
	     * Get extent
	     * @return {Array.<number>}
	     */
scaleProto.getExtent=function(){return this._extent.slice()},/**
	     * Set extent
	     * @param {number} start
	     * @param {number} end
	     */
scaleProto.setExtent=function(start,end){var thisExtent=this._extent;isNaN(start)||(thisExtent[0]=start),isNaN(end)||(thisExtent[1]=end)},/**
	     * @return {Array.<string>}
	     */
scaleProto.getTicksLabels=function(){for(var labels=[],ticks=this.getTicks(),i=0;i<ticks.length;i++)labels.push(this.getLabel(ticks[i]));return labels},clazzUtil.enableClassExtend(Scale),clazzUtil.enableClassManagement(Scale,{registerWhenExtend:!0}),module.exports=Scale},/* 111 */
/***/
function(module,exports,__webpack_require__){/**
	 * Interval scale
	 * @module echarts/scale/Interval
	 */
var numberUtil=__webpack_require__(7),formatUtil=__webpack_require__(6),Scale=__webpack_require__(110),mathFloor=Math.floor,mathCeil=Math.ceil,IntervalScale=Scale.extend({type:"interval",_interval:0,setExtent:function(start,end){var thisExtent=this._extent;
//start,end may be a Number like '25',so...
isNaN(start)||(thisExtent[0]=parseFloat(start)),isNaN(end)||(thisExtent[1]=parseFloat(end))},unionExtent:function(other){var extent=this._extent;other[0]<extent[0]&&(extent[0]=other[0]),other[1]>extent[1]&&(extent[1]=other[1]),
// unionExtent may called by it's sub classes
IntervalScale.prototype.setExtent.call(this,extent[0],extent[1])},/**
	         * Get interval
	         */
getInterval:function(){return this._interval||this.niceTicks(),this._interval},/**
	         * Set interval
	         */
setInterval:function(interval){this._interval=interval,
// Dropped auto calculated niceExtent and use user setted extent
// We assume user wan't to set both interval, min, max to get a better result
this._niceExtent=this._extent.slice()},/**
	         * @return {Array.<number>}
	         */
getTicks:function(){this._interval||this.niceTicks();var interval=this._interval,extent=this._extent,ticks=[],safeLimit=1e4;if(interval){var niceExtent=this._niceExtent;extent[0]<niceExtent[0]&&ticks.push(extent[0]);for(var tick=niceExtent[0];tick<=niceExtent[1];)if(ticks.push(tick),tick=numberUtil.round(tick+interval),ticks.length>safeLimit)return[];extent[1]>niceExtent[1]&&ticks.push(extent[1])}return ticks},/**
	         * @return {Array.<string>}
	         */
getTicksLabels:function(){for(var labels=[],ticks=this.getTicks(),i=0;i<ticks.length;i++)labels.push(this.getLabel(ticks[i]));return labels},/**
	         * @param {number} n
	         * @return {number}
	         */
getLabel:function(data){return formatUtil.addCommas(data)},/**
	         * Update interval and extent of intervals for nice ticks
	         *
	         * @param {number} [splitNumber = 5] Desired number of ticks
	         */
niceTicks:function(splitNumber){splitNumber=splitNumber||5;var extent=this._extent,span=extent[1]-extent[0];if(isFinite(span)){
// User may set axis min 0 and data are all negative
// FIXME If it needs to reverse ?
0>span&&(span=-span,extent.reverse());
// From "Nice Numbers for Graph Labels" of Graphic Gems
// var niceSpan = numberUtil.nice(span, false);
var step=numberUtil.nice(span/splitNumber,!0),niceExtent=[numberUtil.round(mathCeil(extent[0]/step)*step),numberUtil.round(mathFloor(extent[1]/step)*step)];this._interval=step,this._niceExtent=niceExtent}},/**
	         * Nice extent.
	         * @param {number} [splitNumber = 5] Given approx tick number
	         * @param {boolean} [fixMin=false]
	         * @param {boolean} [fixMax=false]
	         */
niceExtent:function(splitNumber,fixMin,fixMax){var extent=this._extent;
// If extent start and end are same, expand them
if(extent[0]===extent[1])if(0!==extent[0]){
// Expand extent
var expandSize=extent[0]/2;extent[0]-=expandSize,extent[1]+=expandSize}else extent[1]=1;var span=extent[1]-extent[0];
// If there are no data and extent are [Infinity, -Infinity]
isFinite(span)||(extent[0]=0,extent[1]=1),this.niceTicks(splitNumber);
// var extent = this._extent;
var interval=this._interval;fixMin||(extent[0]=numberUtil.round(mathFloor(extent[0]/interval)*interval)),fixMax||(extent[1]=numberUtil.round(mathCeil(extent[1]/interval)*interval))}});/**
	     * @return {module:echarts/scale/Time}
	     */
IntervalScale.create=function(){return new IntervalScale},module.exports=IntervalScale},/* 112 */
/***/
function(module,exports,__webpack_require__){/**
	 * Interval scale
	 * @module echarts/coord/scale/Time
	 */
var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),formatUtil=__webpack_require__(6),IntervalScale=__webpack_require__(111),intervalScaleProto=IntervalScale.prototype,mathCeil=Math.ceil,mathFloor=Math.floor,ONE_DAY=864e5,bisect=function(a,x,lo,hi){for(;hi>lo;){var mid=lo+hi>>>1;a[mid][2]<x?lo=mid+1:hi=mid}return lo},TimeScale=IntervalScale.extend({type:"time",
// Overwrite
getLabel:function(val){var stepLvl=this._stepLvl,date=new Date(val);return formatUtil.formatTime(stepLvl[0],date)},
// Overwrite
niceExtent:function(approxTickNum,fixMin,fixMax){var extent=this._extent;
// If there are no data and extent are [Infinity, -Infinity]
if(
// If extent start and end are same, expand them
extent[0]===extent[1]&&(
// Expand extent
extent[0]-=ONE_DAY,extent[1]+=ONE_DAY),extent[1]===-(1/0)&&extent[0]===1/0){var d=new Date;extent[1]=new Date(d.getFullYear(),d.getMonth(),d.getDate()),extent[0]=extent[1]-ONE_DAY}this.niceTicks(approxTickNum,fixMin,fixMax);
// var extent = this._extent;
var interval=this._interval;fixMin||(extent[0]=numberUtil.round(mathFloor(extent[0]/interval)*interval)),fixMax||(extent[1]=numberUtil.round(mathCeil(extent[1]/interval)*interval))},
// Overwrite
niceTicks:function(approxTickNum){approxTickNum=approxTickNum||10;var extent=this._extent,span=extent[1]-extent[0],approxInterval=span/approxTickNum,scaleLevelsLen=scaleLevels.length,idx=bisect(scaleLevels,approxInterval,0,scaleLevelsLen),level=scaleLevels[Math.min(idx,scaleLevelsLen-1)],interval=level[2];
// Same with interval scale if span is much larger than 1 year
if("year"===level[0]){var yearSpan=span/interval,yearStep=numberUtil.nice(yearSpan/approxTickNum,!0);interval*=yearStep}var niceExtent=[mathCeil(extent[0]/interval)*interval,mathFloor(extent[1]/interval)*interval];this._stepLvl=level,
// Interval will be used in getTicks
this._interval=interval,this._niceExtent=niceExtent},parse:function(val){
// val might be float.
return+numberUtil.parseDate(val)}});zrUtil.each(["contain","normalize"],function(methodName){TimeScale.prototype[methodName]=function(val){return intervalScaleProto[methodName].call(this,this.parse(val))}});
// Steps from d3
var scaleLevels=[
// Format       step    interval
["hh:mm:ss",1,1e3],// 1s
["hh:mm:ss",5,5e3],// 5s
["hh:mm:ss",10,1e4],// 10s
["hh:mm:ss",15,15e3],// 15s
["hh:mm:ss",30,3e4],// 30s
["hh:mm\nMM-dd",1,6e4],// 1m
["hh:mm\nMM-dd",5,3e5],// 5m
["hh:mm\nMM-dd",10,6e5],// 10m
["hh:mm\nMM-dd",15,9e5],// 15m
["hh:mm\nMM-dd",30,18e5],// 30m
["hh:mm\nMM-dd",1,36e5],// 1h
["hh:mm\nMM-dd",2,72e5],// 2h
["hh:mm\nMM-dd",6,216e5],// 6h
["hh:mm\nMM-dd",12,432e5],// 12h
["MM-dd\nyyyy",1,ONE_DAY],// 1d
["week",7,7*ONE_DAY],// 7d
["month",1,31*ONE_DAY],// 1M
["quarter",3,380*ONE_DAY/4],// 3M
["half-year",6,380*ONE_DAY/2],// 6M
["year",1,380*ONE_DAY]];/**
	     * @return {module:echarts/scale/Time}
	     */
TimeScale.create=function(){return new TimeScale},module.exports=TimeScale},/* 113 */
/***/
function(module,exports,__webpack_require__){/**
	 * Log scale
	 * @module echarts/scale/Log
	 */
var zrUtil=__webpack_require__(3),Scale=__webpack_require__(110),numberUtil=__webpack_require__(7),IntervalScale=__webpack_require__(111),scaleProto=Scale.prototype,intervalScaleProto=IntervalScale.prototype,mathFloor=Math.floor,mathCeil=Math.ceil,mathPow=Math.pow,LOG_BASE=10,mathLog=Math.log,LogScale=Scale.extend({type:"log",/**
	         * @return {Array.<number>}
	         */
getTicks:function(){return zrUtil.map(intervalScaleProto.getTicks.call(this),function(val){return numberUtil.round(mathPow(LOG_BASE,val))})},/**
	         * @param {number} val
	         * @return {string}
	         */
getLabel:intervalScaleProto.getLabel,/**
	         * @param  {number} val
	         * @return {number}
	         */
scale:function(val){return val=scaleProto.scale.call(this,val),mathPow(LOG_BASE,val)},/**
	         * @param {number} start
	         * @param {number} end
	         */
setExtent:function(start,end){start=mathLog(start)/mathLog(LOG_BASE),end=mathLog(end)/mathLog(LOG_BASE),intervalScaleProto.setExtent.call(this,start,end)},/**
	         * @return {number} end
	         */
getExtent:function(){var extent=scaleProto.getExtent.call(this);return extent[0]=mathPow(LOG_BASE,extent[0]),extent[1]=mathPow(LOG_BASE,extent[1]),extent},/**
	         * @param  {Array.<number>} extent
	         */
unionExtent:function(extent){extent[0]=mathLog(extent[0])/mathLog(LOG_BASE),extent[1]=mathLog(extent[1])/mathLog(LOG_BASE),scaleProto.unionExtent.call(this,extent)},/**
	         * Update interval and extent of intervals for nice ticks
	         * @param  {number} [approxTickNum = 10] Given approx tick number
	         */
niceTicks:function(approxTickNum){approxTickNum=approxTickNum||10;var extent=this._extent,span=extent[1]-extent[0];if(!(span===1/0||0>=span)){var interval=mathPow(10,mathFloor(mathLog(span/approxTickNum)/Math.LN10)),err=approxTickNum/span*interval;
// Filter ticks to get closer to the desired count.
.5>=err&&(interval*=10);var niceExtent=[numberUtil.round(mathCeil(extent[0]/interval)*interval),numberUtil.round(mathFloor(extent[1]/interval)*interval)];this._interval=interval,this._niceExtent=niceExtent}},/**
	         * Nice extent.
	         * @param {number} [approxTickNum = 10] Given approx tick number
	         * @param {boolean} [fixMin=false]
	         * @param {boolean} [fixMax=false]
	         */
niceExtent:intervalScaleProto.niceExtent});zrUtil.each(["contain","normalize"],function(methodName){LogScale.prototype[methodName]=function(val){return val=mathLog(val)/mathLog(LOG_BASE),scaleProto[methodName].call(this,val)}}),LogScale.create=function(){return new LogScale},module.exports=LogScale},/* 114 */
/***/
function(module,exports,__webpack_require__){"use strict";function Cartesian2D(name){Cartesian.call(this,name)}var zrUtil=__webpack_require__(3),Cartesian=__webpack_require__(115);Cartesian2D.prototype={constructor:Cartesian2D,type:"cartesian2d",/**
	         * @type {Array.<string>}
	         * @readOnly
	         */
dimensions:["x","y"],/**
	         * Base axis will be used on stacking.
	         *
	         * @return {module:echarts/coord/cartesian/Axis2D}
	         */
getBaseAxis:function(){return this.getAxesByScale("ordinal")[0]||this.getAxesByScale("time")[0]||this.getAxis("x")},/**
	         * If contain point
	         * @param {Array.<number>} point
	         * @return {boolean}
	         */
containPoint:function(point){var axisX=this.getAxis("x"),axisY=this.getAxis("y");return axisX.contain(axisX.toLocalCoord(point[0]))&&axisY.contain(axisY.toLocalCoord(point[1]))},/**
	         * If contain data
	         * @param {Array.<number>} data
	         * @return {boolean}
	         */
containData:function(data){return this.getAxis("x").containData(data[0])&&this.getAxis("y").containData(data[1])},/**
	         * Convert series data to an array of points
	         * @param {module:echarts/data/List} data
	         * @param {boolean} stack
	         * @return {Array}
	         *  Return array of points. For example:
	         *  `[[10, 10], [20, 20], [30, 30]]`
	         */
dataToPoints:function(data,stack){return data.mapArray(["x","y"],function(x,y){return this.dataToPoint([x,y])},stack,this)},/**
	         * @param {Array.<number>} data
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
dataToPoint:function(data,clamp){var xAxis=this.getAxis("x"),yAxis=this.getAxis("y");return[xAxis.toGlobalCoord(xAxis.dataToCoord(data[0],clamp)),yAxis.toGlobalCoord(yAxis.dataToCoord(data[1],clamp))]},/**
	         * @param {Array.<number>} point
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
pointToData:function(point,clamp){var xAxis=this.getAxis("x"),yAxis=this.getAxis("y");return[xAxis.coordToData(xAxis.toLocalCoord(point[0]),clamp),yAxis.coordToData(yAxis.toLocalCoord(point[1]),clamp)]},/**
	         * Get other axis
	         * @param {module:echarts/coord/cartesian/Axis2D} axis
	         */
getOtherAxis:function(axis){return this.getAxis("x"===axis.dim?"y":"x")}},zrUtil.inherits(Cartesian2D,Cartesian),module.exports=Cartesian2D},/* 115 */
/***/
function(module,exports,__webpack_require__){"use strict";function dimAxisMapper(dim){return this._axes[dim]}/**
	 * Cartesian coordinate system
	 * @module  echarts/coord/Cartesian
	 *
	 */
var zrUtil=__webpack_require__(3),Cartesian=function(name){this._axes={},this._dimList=[],/**
	         * @type {string}
	         */
this.name=name||""};Cartesian.prototype={constructor:Cartesian,type:"cartesian",/**
	         * Get axis
	         * @param  {number|string} dim
	         * @return {module:echarts/coord/Cartesian~Axis}
	         */
getAxis:function(dim){return this._axes[dim]},/**
	         * Get axes list
	         * @return {Array.<module:echarts/coord/Cartesian~Axis>}
	         */
getAxes:function(){return zrUtil.map(this._dimList,dimAxisMapper,this)},/**
	         * Get axes list by given scale type
	         */
getAxesByScale:function(scaleType){return scaleType=scaleType.toLowerCase(),zrUtil.filter(this.getAxes(),function(axis){return axis.scale.type===scaleType})},/**
	         * Add axis
	         * @param {module:echarts/coord/Cartesian.Axis}
	         */
addAxis:function(axis){var dim=axis.dim;this._axes[dim]=axis,this._dimList.push(dim)},/**
	         * Convert data to coord in nd space
	         * @param {Array.<number>|Object.<string, number>} val
	         * @return {Array.<number>|Object.<string, number>}
	         */
dataToCoord:function(val){return this._dataCoordConvert(val,"dataToCoord")},/**
	         * Convert coord in nd space to data
	         * @param  {Array.<number>|Object.<string, number>} val
	         * @return {Array.<number>|Object.<string, number>}
	         */
coordToData:function(val){return this._dataCoordConvert(val,"coordToData")},_dataCoordConvert:function(input,method){for(var dimList=this._dimList,output=input instanceof Array?[]:{},i=0;i<dimList.length;i++){var dim=dimList[i],axis=this._axes[dim];output[dim]=axis[method](input[dim])}return output}},module.exports=Cartesian},/* 116 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117),axisLabelInterval=__webpack_require__(118),Axis2D=function(dim,scale,coordExtent,axisType,position){Axis.call(this,dim,scale,coordExtent),/**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
this.type=axisType||"value",/**
	         * Axis position
	         *  - 'top'
	         *  - 'bottom'
	         *  - 'left'
	         *  - 'right'
	         */
this.position=position||"bottom"};Axis2D.prototype={constructor:Axis2D,/**
	         * Index of axis, can be used as key
	         */
index:0,/**
	         * If axis is on the zero position of the other axis
	         * @type {boolean}
	         */
onZero:!1,/**
	         * Axis model
	         * @param {module:echarts/coord/cartesian/AxisModel}
	         */
model:null,isHorizontal:function(){var position=this.position;return"top"===position||"bottom"===position},getGlobalExtent:function(){var ret=this.getExtent();return ret[0]=this.toGlobalCoord(ret[0]),ret[1]=this.toGlobalCoord(ret[1]),ret},/**
	         * @return {number}
	         */
getLabelInterval:function(){var labelInterval=this._labelInterval;return labelInterval||(labelInterval=this._labelInterval=axisLabelInterval(this)),labelInterval},/**
	         * If label is ignored.
	         * Automatically used when axis is category and label can not be all shown
	         * @param  {number}  idx
	         * @return {boolean}
	         */
isLabelIgnored:function(idx){if("category"===this.type){var labelInterval=this.getLabelInterval();return"function"==typeof labelInterval&&!labelInterval(idx,this.scale.getLabel(idx))||idx%(labelInterval+1)}},/**
	         * Transform global coord to local coord,
	         * i.e. var localCoord = axis.toLocalCoord(80);
	         * designate by module:echarts/coord/cartesian/Grid.
	         * @type {Function}
	         */
toLocalCoord:null,/**
	         * Transform global coord to local coord,
	         * i.e. var globalCoord = axis.toLocalCoord(40);
	         * designate by module:echarts/coord/cartesian/Grid.
	         * @type {Function}
	         */
toGlobalCoord:null},zrUtil.inherits(Axis2D,Axis),module.exports=Axis2D},/* 117 */
/***/
function(module,exports,__webpack_require__){function fixExtentWithBands(extent,nTick){var size=extent[1]-extent[0],len=nTick,margin=size/len/2;extent[0]+=margin,extent[1]-=margin}var numberUtil=__webpack_require__(7),linearMap=numberUtil.linearMap,zrUtil=__webpack_require__(3),normalizedExtent=[0,1],Axis=function(dim,scale,extent){/**
	         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
	         * @type {string}
	         */
this.dim=dim,/**
	         * Axis scale
	         * @type {module:echarts/coord/scale/*}
	         */
this.scale=scale,/**
	         * @type {Array.<number>}
	         * @private
	         */
this._extent=extent||[0,0],/**
	         * @type {boolean}
	         */
this.inverse=!1,/**
	         * Usually true when axis has a ordinal scale
	         * @type {boolean}
	         */
this.onBand=!1};Axis.prototype={constructor:Axis,/**
	         * If axis extent contain given coord
	         * @param {number} coord
	         * @return {boolean}
	         */
contain:function(coord){var extent=this._extent,min=Math.min(extent[0],extent[1]),max=Math.max(extent[0],extent[1]);return coord>=min&&max>=coord},/**
	         * If axis extent contain given data
	         * @param {number} data
	         * @return {boolean}
	         */
containData:function(data){return this.contain(this.dataToCoord(data))},/**
	         * Get coord extent.
	         * @return {Array.<number>}
	         */
getExtent:function(){var ret=this._extent.slice();return ret},/**
	         * Get precision used for formatting
	         * @param {Array.<number>} [dataExtent]
	         * @return {number}
	         */
getPixelPrecision:function(dataExtent){return numberUtil.getPixelPrecision(dataExtent||this.scale.getExtent(),this._extent)},/**
	         * Set coord extent
	         * @param {number} start
	         * @param {number} end
	         */
setExtent:function(start,end){var extent=this._extent;extent[0]=start,extent[1]=end},/**
	         * Convert data to coord. Data is the rank if it has a ordinal scale
	         * @param {number} data
	         * @param  {boolean} clamp
	         * @return {number}
	         */
dataToCoord:function(data,clamp){var extent=this._extent,scale=this.scale;return data=scale.normalize(data),this.onBand&&"ordinal"===scale.type&&(extent=extent.slice(),fixExtentWithBands(extent,scale.count())),linearMap(data,normalizedExtent,extent,clamp)},/**
	         * Convert coord to data. Data is the rank if it has a ordinal scale
	         * @param {number} coord
	         * @param  {boolean} clamp
	         * @return {number}
	         */
coordToData:function(coord,clamp){var extent=this._extent,scale=this.scale;this.onBand&&"ordinal"===scale.type&&(extent=extent.slice(),fixExtentWithBands(extent,scale.count()));var t=linearMap(coord,extent,normalizedExtent,clamp);return this.scale.scale(t)},/**
	         * @return {Array.<number>}
	         */
getTicksCoords:function(){if(this.onBand){for(var bands=this.getBands(),coords=[],i=0;i<bands.length;i++)coords.push(bands[i][0]);return bands[i-1]&&coords.push(bands[i-1][1]),coords}return zrUtil.map(this.scale.getTicks(),this.dataToCoord,this)},/**
	         * Coords of labels are on the ticks or on the middle of bands
	         * @return {Array.<number>}
	         */
getLabelsCoords:function(){if(this.onBand){for(var band,bands=this.getBands(),coords=[],i=0;i<bands.length;i++)band=bands[i],coords.push((band[0]+band[1])/2);return coords}return zrUtil.map(this.scale.getTicks(),this.dataToCoord,this)},/**
	         * Get bands.
	         *
	         * If axis has labels [1, 2, 3, 4]. Bands on the axis are
	         * |---1---|---2---|---3---|---4---|.
	         *
	         * @return {Array}
	         */
// FIXME Situation when labels is on ticks
getBands:function(){for(var extent=this.getExtent(),bands=[],len=this.scale.count(),start=extent[0],end=extent[1],span=end-start,i=0;len>i;i++)bands.push([span*i/len+start,span*(i+1)/len+start]);return bands},/**
	         * Get width of band
	         * @return {number}
	         */
getBandWidth:function(){var axisExtent=this._extent,dataExtent=this.scale.getExtent(),len=dataExtent[1]-dataExtent[0]+(this.onBand?1:0);
// Fix #2728, avoid NaN when only one data.
0===len&&(len=1);var size=Math.abs(axisExtent[1]-axisExtent[0]);return Math.abs(size)/len}},module.exports=Axis},/* 118 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * Helper function for axisLabelInterval calculation
	 */
var zrUtil=__webpack_require__(3),axisHelper=__webpack_require__(108);module.exports=function(axis){var axisModel=axis.model,labelModel=axisModel.getModel("axisLabel"),labelInterval=labelModel.get("interval");return"category"!==axis.type||"auto"!==labelInterval?"auto"===labelInterval?0:labelInterval:axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(),axis.dataToCoord,axis),axisModel.getFormattedLabels(),labelModel.getModel("textStyle").getFont(),axis.isHorizontal())}},/* 119 */
/***/
function(module,exports,__webpack_require__){"use strict";
// Grid 是在有直角坐标系的时候必须要存在的
// 所以这里也要被 Cartesian2D 依赖
__webpack_require__(120);var ComponentModel=__webpack_require__(19);module.exports=ComponentModel.extend({type:"grid",dependencies:["xAxis","yAxis"],layoutMode:"box",/**
	         * @type {module:echarts/coord/cartesian/Grid}
	         */
coordinateSystem:null,defaultOption:{show:!1,zlevel:0,z:0,left:"10%",top:60,right:"10%",bottom:60,
// If grid size contain label
containLabel:!1,
// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
backgroundColor:"rgba(0,0,0,0)",borderWidth:1,borderColor:"#ccc"}})},/* 120 */
/***/
function(module,exports,__webpack_require__){"use strict";function getAxisType(axisDim,option){
// Default axis with data is category axis
return option.type||(option.data?"category":"value")}var ComponentModel=__webpack_require__(19),zrUtil=__webpack_require__(3),axisModelCreator=__webpack_require__(121),AxisModel=ComponentModel.extend({type:"cartesian2dAxis",/**
	         * @type {module:echarts/coord/cartesian/Axis2D}
	         */
axis:null,/**
	         * @override
	         */
init:function(){AxisModel.superApply(this,"init",arguments),this._resetRange()},/**
	         * @override
	         */
mergeOption:function(){AxisModel.superApply(this,"mergeOption",arguments),this._resetRange()},/**
	         * @override
	         */
restoreData:function(){AxisModel.superApply(this,"restoreData",arguments),this._resetRange()},/**
	         * @public
	         * @param {number} rangeStart
	         * @param {number} rangeEnd
	         */
setRange:function(rangeStart,rangeEnd){this.option.rangeStart=rangeStart,this.option.rangeEnd=rangeEnd},/**
	         * @public
	         * @return {Array.<number|string|Date>}
	         */
getMin:function(){var option=this.option;return null!=option.rangeStart?option.rangeStart:option.min},/**
	         * @public
	         * @return {Array.<number|string|Date>}
	         */
getMax:function(){var option=this.option;return null!=option.rangeEnd?option.rangeEnd:option.max},/**
	         * @public
	         * @return {boolean}
	         */
getNeedCrossZero:function(){var option=this.option;return null!=option.rangeStart||null!=option.rangeEnd?!1:!option.scale},/**
	         * @private
	         */
_resetRange:function(){
// rangeStart and rangeEnd is readonly.
this.option.rangeStart=this.option.rangeEnd=null}});zrUtil.merge(AxisModel.prototype,__webpack_require__(123));var extraOption={gridIndex:0};axisModelCreator("x",AxisModel,getAxisType,extraOption),axisModelCreator("y",AxisModel,getAxisType,extraOption),module.exports=AxisModel},/* 121 */
/***/
function(module,exports,__webpack_require__){var axisDefault=__webpack_require__(122),zrUtil=__webpack_require__(3),ComponentModel=__webpack_require__(19),layout=__webpack_require__(21),AXIS_TYPES=["value","category","time","log"];/**
	     * Generate sub axis model class
	     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
	     * @param {module:echarts/model/Component} BaseAxisModelClass
	     * @param {Function} axisTypeDefaulter
	     * @param {Object} [extraDefaultOption]
	     */
module.exports=function(axisName,BaseAxisModelClass,axisTypeDefaulter,extraDefaultOption){zrUtil.each(AXIS_TYPES,function(axisType){BaseAxisModelClass.extend({type:axisName+"Axis."+axisType,mergeDefaultAndTheme:function(option,ecModel){var layoutMode=this.layoutMode,inputPositionParams=layoutMode?layout.getLayoutParams(option):{},themeModel=ecModel.getTheme();zrUtil.merge(option,themeModel.get(axisType+"Axis")),zrUtil.merge(option,this.getDefaultOption()),option.type=axisTypeDefaulter(axisName,option),layoutMode&&layout.mergeLayoutParam(option,inputPositionParams,layoutMode)},defaultOption:zrUtil.mergeAll([{},axisDefault[axisType+"Axis"],extraDefaultOption],!0)})}),ComponentModel.registerSubTypeDefaulter(axisName+"Axis",zrUtil.curry(axisTypeDefaulter,axisName))}},/* 122 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),defaultOption={show:!0,zlevel:0,// 一级层叠
z:0,// 二级层叠
// 反向坐标轴
inverse:!1,
// 坐标轴名字，默认为空
name:"",
// 坐标轴名字位置，支持'start' | 'middle' | 'end'
nameLocation:"end",
// 坐标轴文字样式，默认取全局样式
nameTextStyle:{},
// 文字与轴线距离
nameGap:15,
// 是否能触发鼠标事件
silent:!0,
// 坐标轴线
axisLine:{
// 默认显示，属性show控制显示与否
show:!0,onZero:!0,
// 属性lineStyle控制线条样式
lineStyle:{color:"#333",width:1,type:"solid"}},
// 坐标轴小标记
axisTick:{
// 属性show控制显示与否，默认显示
show:!0,
// 控制小标记是否在grid里
inside:!1,
// 属性length控制线长
length:5,
// 属性lineStyle控制线条样式
lineStyle:{color:"#333",width:1}},
// 坐标轴文本标签，详见axis.axisLabel
axisLabel:{show:!0,
// 控制文本标签是否在grid里
inside:!1,rotate:0,margin:8,
// formatter: null,
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
textStyle:{color:"#333",fontSize:12}},
// 分隔线
splitLine:{
// 默认显示，属性show控制显示与否
show:!0,
// 属性lineStyle（详见lineStyle）控制线条样式
lineStyle:{color:["#ccc"],width:1,type:"solid"}},
// 分隔区域
splitArea:{
// 默认不显示，属性show控制显示与否
show:!1,
// 属性areaStyle（详见areaStyle）控制区域样式
areaStyle:{color:["rgba(250,250,250,0.3)","rgba(200,200,200,0.3)"]}}},categoryAxis=zrUtil.merge({
// 类目起始和结束两端空白策略
boundaryGap:!0,
// 坐标轴小标记
axisTick:{interval:"auto"},
// 坐标轴文本标签，详见axis.axisLabel
axisLabel:{interval:"auto"}},defaultOption),valueAxis=zrUtil.defaults({
// 数值起始和结束两端空白策略
boundaryGap:[0,0],
// 最小值, 设置成 'dataMin' 则从数据中计算最小值
// min: null,
// 最大值，设置成 'dataMax' 则从数据中计算最大值
// max: null,
// Readonly prop, specifies start value of the range when using data zoom.
// rangeStart: null
// Readonly prop, specifies end value of the range when using data zoom.
// rangeEnd: null
// 脱离0值比例，放大聚焦到最终_min，_max区间
// scale: false,
// 分割段数，默认为5
splitNumber:5},defaultOption),timeAxis=zrUtil.defaults({scale:!0,min:"dataMin",max:"dataMax"},valueAxis),logAxis=zrUtil.defaults({},valueAxis);logAxis.scale=!0,module.exports={categoryAxis:categoryAxis,valueAxis:valueAxis,timeAxis:timeAxis,logAxis:logAxis}},/* 123 */
/***/
function(module,exports,__webpack_require__){function getName(obj){return zrUtil.isObject(obj)&&null!=obj.value?obj.value:obj}/**
	     * Get categories
	     */
function getCategories(){return"category"===this.get("type")&&zrUtil.map(this.get("data"),getName)}/**
	     * Format labels
	     * @return {Array.<string>}
	     */
function getFormattedLabels(){return axisHelper.getFormattedLabels(this.axis,this.get("axisLabel.formatter"))}var zrUtil=__webpack_require__(3),axisHelper=__webpack_require__(108);module.exports={getFormattedLabels:getFormattedLabels,getCategories:getCategories}},/* 124 */
/***/
function(module,exports,__webpack_require__){"use strict";
// TODO boundaryGap
__webpack_require__(120),__webpack_require__(125)},/* 125 */
/***/
function(module,exports,__webpack_require__){/**
	     * @inner
	     */
function layoutAxis(gridModel,axisModel){function getZero(dim,val){var theAxis=grid.getAxis(dim);return theAxis.toGlobalCoord(theAxis.dataToCoord(0))}var grid=gridModel.coordinateSystem,axis=axisModel.axis,layout={},rawAxisPosition=axis.position,axisPosition=axis.onZero?"onZero":rawAxisPosition,axisDim=axis.dim,rect=grid.getRect(),rectBound=[rect.x,rect.x+rect.width,rect.y,rect.y+rect.height],posMap={x:{top:rectBound[2],bottom:rectBound[3]},y:{left:rectBound[0],right:rectBound[1]}};posMap.x.onZero=Math.max(Math.min(getZero("y"),posMap.x.bottom),posMap.x.top),posMap.y.onZero=Math.max(Math.min(getZero("x"),posMap.y.right),posMap.y.left),
// Axis position
layout.position=["y"===axisDim?posMap.y[axisPosition]:rectBound[0],"x"===axisDim?posMap.x[axisPosition]:rectBound[3]];
// Axis rotation
var r={x:0,y:1};layout.rotation=Math.PI/2*r[axisDim];
// Tick and label direction, x y is axisDim
var dirMap={top:-1,bottom:1,left:-1,right:1};layout.labelDirection=layout.tickDirection=layout.nameDirection=dirMap[rawAxisPosition],axis.onZero&&(layout.labelOffset=posMap[axisDim][rawAxisPosition]-posMap[axisDim].onZero),axisModel.getModel("axisTick").get("inside")&&(layout.tickDirection=-layout.tickDirection),axisModel.getModel("axisLabel").get("inside")&&(layout.labelDirection=-layout.labelDirection);
// Special label rotation
var labelRotation=axisModel.getModel("axisLabel").get("rotate");
// label interval when auto mode.
// Over splitLine and splitArea
return layout.labelRotation="top"===axisPosition?-labelRotation:labelRotation,layout.labelInterval=axis.getLabelInterval(),layout.z2=1,layout}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),AxisBuilder=__webpack_require__(126),ifIgnoreOnTick=AxisBuilder.ifIgnoreOnTick,getInterval=AxisBuilder.getInterval,axisBuilderAttrs=["axisLine","axisLabel","axisTick","axisName"],selfBuilderAttrs=["splitLine","splitArea"],AxisView=__webpack_require__(1).extendComponentView({type:"axis",render:function(axisModel,ecModel){if(this.group.removeAll(),axisModel.get("show")){var gridModel=ecModel.getComponent("grid",axisModel.get("gridIndex")),layout=layoutAxis(gridModel,axisModel),axisBuilder=new AxisBuilder(axisModel,layout);zrUtil.each(axisBuilderAttrs,axisBuilder.add,axisBuilder),this.group.add(axisBuilder.getGroup()),zrUtil.each(selfBuilderAttrs,function(name){axisModel.get(name+".show")&&this["_"+name](axisModel,gridModel,layout.labelInterval)},this)}},/**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @param {number|Function} labelInterval
	         * @private
	         */
_splitLine:function(axisModel,gridModel,labelInterval){var axis=axisModel.axis,splitLineModel=axisModel.getModel("splitLine"),lineStyleModel=splitLineModel.getModel("lineStyle"),lineWidth=lineStyleModel.get("width"),lineColors=lineStyleModel.get("color"),lineInterval=getInterval(splitLineModel,labelInterval);lineColors=zrUtil.isArray(lineColors)?lineColors:[lineColors];for(var gridRect=gridModel.coordinateSystem.getRect(),isHorizontal=axis.isHorizontal(),splitLines=[],lineCount=0,ticksCoords=axis.getTicksCoords(),p1=[],p2=[],i=0;i<ticksCoords.length;i++)if(!ifIgnoreOnTick(axis,i,lineInterval)){var tickCoord=axis.toGlobalCoord(ticksCoords[i]);isHorizontal?(p1[0]=tickCoord,p1[1]=gridRect.y,p2[0]=tickCoord,p2[1]=gridRect.y+gridRect.height):(p1[0]=gridRect.x,p1[1]=tickCoord,p2[0]=gridRect.x+gridRect.width,p2[1]=tickCoord);var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[],splitLines[colorIndex].push(new graphic.Line(graphic.subPixelOptimizeLine({shape:{x1:p1[0],y1:p1[1],x2:p2[0],y2:p2[1]},style:{lineWidth:lineWidth},silent:!0})))}for(var lineStyle=lineStyleModel.getLineStyle(),i=0;i<splitLines.length;i++)this.group.add(graphic.mergePath(splitLines[i],{style:zrUtil.defaults({stroke:lineColors[i%lineColors.length]},lineStyle),silent:!0}))},/**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @param {number|Function} labelInterval
	         * @private
	         */
_splitArea:function(axisModel,gridModel,labelInterval){var axis=axisModel.axis,splitAreaModel=axisModel.getModel("splitArea"),areaStyleModel=splitAreaModel.getModel("areaStyle"),areaColors=areaStyleModel.get("color"),gridRect=gridModel.coordinateSystem.getRect(),ticksCoords=axis.getTicksCoords(),prevX=axis.toGlobalCoord(ticksCoords[0]),prevY=axis.toGlobalCoord(ticksCoords[0]),splitAreaRects=[],count=0,areaInterval=getInterval(splitAreaModel,labelInterval);areaColors=zrUtil.isArray(areaColors)?areaColors:[areaColors];for(var i=1;i<ticksCoords.length;i++)if(!ifIgnoreOnTick(axis,i,areaInterval)){var x,y,width,height,tickCoord=axis.toGlobalCoord(ticksCoords[i]);axis.isHorizontal()?(x=prevX,y=gridRect.y,width=tickCoord-x,height=gridRect.height):(x=gridRect.x,y=prevY,width=gridRect.width,height=tickCoord-y);var colorIndex=count++%areaColors.length;splitAreaRects[colorIndex]=splitAreaRects[colorIndex]||[],splitAreaRects[colorIndex].push(new graphic.Rect({shape:{x:x,y:y,width:width,height:height},silent:!0})),prevX=x+width,prevY=y+height}for(var areaStyle=areaStyleModel.getAreaStyle(),i=0;i<splitAreaRects.length;i++)this.group.add(graphic.mergePath(splitAreaRects[i],{style:zrUtil.defaults({fill:areaColors[i%areaColors.length]},areaStyle),silent:!0}))}});AxisView.extend({type:"xAxis"}),AxisView.extend({type:"yAxis"})},/* 126 */
/***/
function(module,exports,__webpack_require__){function makeAxisEventDataBase(axisModel){var eventData={componentType:axisModel.mainType};return eventData[axisModel.mainType+"Index"]=axisModel.componentIndex,eventData}/**
	     * @inner
	     */
function innerTextLayout(opt,textRotation,direction){var textAlign,verticalAlign,rotationDiff=remRadian(textRotation-opt.rotation);// Label is parallel with axis line.
// Label is inverse parallel with axis line.
return isRadianAroundZero(rotationDiff)?(verticalAlign=direction>0?"top":"bottom",textAlign="center"):isRadianAroundZero(rotationDiff-PI)?(verticalAlign=direction>0?"bottom":"top",textAlign="center"):(verticalAlign="middle",textAlign=rotationDiff>0&&PI>rotationDiff?direction>0?"right":"left":direction>0?"left":"right"),{rotation:rotationDiff,textAlign:textAlign,verticalAlign:verticalAlign}}/**
	     * @inner
	     */
function endTextLayout(opt,textPosition,extent){var textAlign,verticalAlign,rotationDiff=remRadian(-opt.rotation),inverse=extent[0]>extent[1],onLeft="start"===textPosition&&!inverse||"start"!==textPosition&&inverse;return isRadianAroundZero(rotationDiff-PI/2)?(verticalAlign=onLeft?"bottom":"top",textAlign="center"):isRadianAroundZero(rotationDiff-1.5*PI)?(verticalAlign=onLeft?"top":"bottom",textAlign="center"):(verticalAlign="middle",textAlign=1.5*PI>rotationDiff&&rotationDiff>PI/2?onLeft?"left":"right":onLeft?"right":"left"),{rotation:rotationDiff,textAlign:textAlign,verticalAlign:verticalAlign}}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),Model=__webpack_require__(8),numberUtil=__webpack_require__(7),remRadian=numberUtil.remRadian,isRadianAroundZero=numberUtil.isRadianAroundZero,PI=Math.PI,AxisBuilder=function(axisModel,opt){/**
	         * @readOnly
	         */
this.opt=opt,/**
	         * @readOnly
	         */
this.axisModel=axisModel,
// Default value
zrUtil.defaults(opt,{labelOffset:0,nameDirection:1,tickDirection:1,labelDirection:1,silent:!0}),/**
	         * @readOnly
	         */
this.group=new graphic.Group({position:opt.position.slice(),rotation:opt.rotation})};AxisBuilder.prototype={constructor:AxisBuilder,hasBuilder:function(name){return!!builders[name]},add:function(name){builders[name].call(this)},getGroup:function(){return this.group}};var builders={/**
	         * @private
	         */
axisLine:function(){var opt=this.opt,axisModel=this.axisModel;if(axisModel.get("axisLine.show")){var extent=this.axisModel.axis.getExtent();this.group.add(new graphic.Line({shape:{x1:extent[0],y1:0,x2:extent[1],y2:0},style:zrUtil.extend({lineCap:"round"},axisModel.getModel("axisLine.lineStyle").getLineStyle()),strokeContainThreshold:opt.strokeContainThreshold,silent:!!opt.axisLineSilent,z2:1}))}},/**
	         * @private
	         */
axisTick:function(){var axisModel=this.axisModel;if(axisModel.get("axisTick.show")){for(var axis=axisModel.axis,tickModel=axisModel.getModel("axisTick"),opt=this.opt,lineStyleModel=tickModel.getModel("lineStyle"),tickLen=tickModel.get("length"),tickInterval=getInterval(tickModel,opt.labelInterval),ticksCoords=axis.getTicksCoords(),tickLines=[],i=0;i<ticksCoords.length;i++)
// Only ordinal scale support tick interval
if(!ifIgnoreOnTick(axis,i,tickInterval)){var tickCoord=ticksCoords[i];
// Tick line
tickLines.push(new graphic.Line(graphic.subPixelOptimizeLine({shape:{x1:tickCoord,y1:0,x2:tickCoord,y2:opt.tickDirection*tickLen},style:{lineWidth:lineStyleModel.get("width")},silent:!0})))}this.group.add(graphic.mergePath(tickLines,{style:lineStyleModel.getLineStyle(),z2:2,silent:!0}))}},/**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @private
	         */
axisLabel:function(){function isTwoLabelOverlapped(current,next){var firstRect=current&&current.getBoundingRect().clone(),nextRect=next&&next.getBoundingRect().clone();return firstRect&&nextRect?(firstRect.applyTransform(current.getLocalTransform()),nextRect.applyTransform(next.getLocalTransform()),firstRect.intersect(nextRect)):void 0}var axisModel=this.axisModel;if(axisModel.get("axisLabel.show")){var opt=this.opt,axis=axisModel.axis,labelModel=axisModel.getModel("axisLabel"),textStyleModel=labelModel.getModel("textStyle"),labelMargin=labelModel.get("margin"),ticks=axis.scale.getTicks(),labels=axisModel.getFormattedLabels(),labelRotation=opt.labelRotation;null==labelRotation&&(labelRotation=labelModel.get("rotate")||0),
// To radian.
labelRotation=labelRotation*PI/180;for(var labelLayout=innerTextLayout(opt,labelRotation,opt.labelDirection),categoryData=axisModel.get("data"),textEls=[],isSilent=axisModel.get("silent"),i=0;i<ticks.length;i++)if(!ifIgnoreOnTick(axis,i,opt.labelInterval)){var itemTextStyleModel=textStyleModel;categoryData&&categoryData[i]&&categoryData[i].textStyle&&(itemTextStyleModel=new Model(categoryData[i].textStyle,textStyleModel,axisModel.ecModel));var textColor=itemTextStyleModel.getTextColor(),tickCoord=axis.dataToCoord(ticks[i]),pos=[tickCoord,opt.labelOffset+opt.labelDirection*labelMargin],labelBeforeFormat=axis.scale.getLabel(ticks[i]),textEl=new graphic.Text({style:{text:labels[i],textAlign:itemTextStyleModel.get("align",!0)||labelLayout.textAlign,textVerticalAlign:itemTextStyleModel.get("baseline",!0)||labelLayout.verticalAlign,textFont:itemTextStyleModel.getFont(),fill:"function"==typeof textColor?textColor(labelBeforeFormat):textColor},position:pos,rotation:labelLayout.rotation,silent:isSilent,z2:10});
// Pack data for mouse event
textEl.eventData=makeAxisEventDataBase(axisModel),textEl.eventData.targetType="axisLabel",textEl.eventData.value=labelBeforeFormat,textEls.push(textEl),this.group.add(textEl)}if("category"!==axis.type){
// If min or max are user set, we need to check
// If the tick on min(max) are overlap on their neighbour tick
// If they are overlapped, we need to hide the min(max) tick label
if(axisModel.getMin?axisModel.getMin():axisModel.get("min")){var firstLabel=textEls[0],nextLabel=textEls[1];isTwoLabelOverlapped(firstLabel,nextLabel)&&(firstLabel.ignore=!0)}if(axisModel.getMax?axisModel.getMax():axisModel.get("max")){var lastLabel=textEls[textEls.length-1],prevLabel=textEls[textEls.length-2];isTwoLabelOverlapped(prevLabel,lastLabel)&&(lastLabel.ignore=!0)}}}},/**
	         * @private
	         */
axisName:function(){var opt=this.opt,axisModel=this.axisModel,name=this.opt.axisName;if(
// If name is '', do not get name from axisMode.
null==name&&(name=axisModel.get("name")),name){var labelLayout,nameLocation=axisModel.get("nameLocation"),nameDirection=opt.nameDirection,textStyleModel=axisModel.getModel("nameTextStyle"),gap=axisModel.get("nameGap")||0,extent=this.axisModel.axis.getExtent(),gapSignal=extent[0]>extent[1]?-1:1,pos=["start"===nameLocation?extent[0]-gapSignal*gap:"end"===nameLocation?extent[1]+gapSignal*gap:(extent[0]+extent[1])/2,"middle"===nameLocation?opt.labelOffset+nameDirection*gap:0];labelLayout="middle"===nameLocation?innerTextLayout(opt,opt.rotation,nameDirection):endTextLayout(opt,nameLocation,extent);var textEl=new graphic.Text({style:{text:name,textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor()||axisModel.get("axisLine.lineStyle.color"),textAlign:labelLayout.textAlign,textVerticalAlign:labelLayout.verticalAlign},position:pos,rotation:labelLayout.rotation,silent:axisModel.get("silent"),z2:1});textEl.eventData=makeAxisEventDataBase(axisModel),textEl.eventData.targetType="axisName",textEl.eventData.name=name,this.group.add(textEl)}}},ifIgnoreOnTick=AxisBuilder.ifIgnoreOnTick=function(axis,i,interval){var rawTick,scale=axis.scale;return"ordinal"===scale.type&&("function"==typeof interval?(rawTick=scale.getTicks()[i],!interval(rawTick,scale.getLabel(rawTick))):i%(interval+1))},getInterval=AxisBuilder.getInterval=function(model,labelInterval){var interval=model.get("interval");return null!=interval&&"auto"!=interval||(interval=labelInterval),interval};module.exports=AxisBuilder},/* 127 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3);__webpack_require__(107),__webpack_require__(128),__webpack_require__(129);var barLayoutGrid=__webpack_require__(131),echarts=__webpack_require__(1);echarts.registerLayout(zrUtil.curry(barLayoutGrid,"bar")),
// Visual coding for legend
echarts.registerVisualCoding("chart",function(ecModel){ecModel.eachSeriesByType("bar",function(seriesModel){var data=seriesModel.getData();data.setVisual("legendSymbol","roundRect")})}),
// In case developer forget to include grid component
__webpack_require__(106)},/* 128 */
/***/
function(module,exports,__webpack_require__){"use strict";var SeriesModel=__webpack_require__(27),createListFromArray=__webpack_require__(93);module.exports=SeriesModel.extend({type:"series.bar",dependencies:["grid","polar"],getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel)},getMarkerPosition:function(value){var coordSys=this.coordinateSystem;if(coordSys){var pt=coordSys.dataToPoint(value),data=this.getData(),offset=data.getLayout("offset"),size=data.getLayout("size"),offsetIndex=coordSys.getBaseAxis().isHorizontal()?0:1;return pt[offsetIndex]+=offset+size/2,pt}return[NaN,NaN]},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:"cartesian2d",legendHoverLink:!0,
// stack: null
// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,
// 最小高度改为0
barMinHeight:0,
// barMaxWidth: null,
// 默认自适应
// barWidth: null,
// 柱间距离，默认为柱形宽度的30%，可设固定值
// barGap: '30%',
// 类目间柱形距离，默认为类目间距的20%，可设固定值
// barCategoryGap: '20%',
// label: {
//     normal: {
//         show: false
//         formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
//         // 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
//         //           'inside' | 'insideleft' | 'insideTop' | 'insideRight' | 'insideBottom' |
//         //           'outside' |'left' | 'right'|'top'|'bottom'
//         position:
//         textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
//     }
// },
itemStyle:{normal:{
// color: '各异',
// 柱条边线
barBorderColor:"#fff",
// 柱条边线线宽，单位px，默认为1
barBorderWidth:0},emphasis:{
// color: '各异',
// 柱条边线
barBorderColor:"#fff",
// 柱条边线线宽，单位px，默认为1
barBorderWidth:0}}}})},/* 129 */
/***/
function(module,exports,__webpack_require__){"use strict";function fixLayoutWithLineWidth(layout,lineWidth){var signX=layout.width>0?1:-1,signY=layout.height>0?1:-1;lineWidth=Math.min(lineWidth,Math.abs(layout.width),Math.abs(layout.height)),layout.x+=signX*lineWidth/2,layout.y+=signY*lineWidth/2,layout.width-=signX*lineWidth,layout.height-=signY*lineWidth}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42);zrUtil.extend(__webpack_require__(8).prototype,__webpack_require__(130)),module.exports=__webpack_require__(1).extendChartView({type:"bar",render:function(seriesModel,ecModel,api){var coordinateSystemType=seriesModel.get("coordinateSystem");return"cartesian2d"===coordinateSystemType&&this._renderOnCartesian(seriesModel,ecModel,api),this.group},_renderOnCartesian:function(seriesModel,ecModel,api){function createRect(dataIndex,isUpdate){var layout=data.getItemLayout(dataIndex),lineWidth=data.getItemModel(dataIndex).get(barBorderWidthQuery)||0;fixLayoutWithLineWidth(layout,lineWidth);var rect=new graphic.Rect({shape:zrUtil.extend({},layout)});
// Animation
if(enableAnimation){var rectShape=rect.shape,animateProperty=isHorizontal?"height":"width",animateTarget={};rectShape[animateProperty]=0,animateTarget[animateProperty]=layout[animateProperty],graphic[isUpdate?"updateProps":"initProps"](rect,{shape:animateTarget},seriesModel)}return rect}var group=this.group,data=seriesModel.getData(),oldData=this._data,cartesian=seriesModel.coordinateSystem,baseAxis=cartesian.getBaseAxis(),isHorizontal=baseAxis.isHorizontal(),enableAnimation=seriesModel.get("animation"),barBorderWidthQuery=["itemStyle","normal","barBorderWidth"];data.diff(oldData).add(function(dataIndex){
// 空数据
if(data.hasValue(dataIndex)){var rect=createRect(dataIndex);data.setItemGraphicEl(dataIndex,rect),group.add(rect)}}).update(function(newIndex,oldIndex){var rect=oldData.getItemGraphicEl(oldIndex);
// 空数据
if(!data.hasValue(newIndex))return void group.remove(rect);rect||(rect=createRect(newIndex,!0));var layout=data.getItemLayout(newIndex),lineWidth=data.getItemModel(newIndex).get(barBorderWidthQuery)||0;fixLayoutWithLineWidth(layout,lineWidth),graphic.updateProps(rect,{shape:layout},seriesModel),data.setItemGraphicEl(newIndex,rect),
// Add back
group.add(rect)}).remove(function(idx){var rect=oldData.getItemGraphicEl(idx);rect&&(
// Not show text when animating
rect.style.text="",graphic.updateProps(rect,{shape:{width:0}},seriesModel,function(){group.remove(rect)}))}).execute(),this._updateStyle(seriesModel,data,isHorizontal),this._data=data},_updateStyle:function(seriesModel,data,isHorizontal){function setLabel(style,model,color,labelText,labelPositionOutside){graphic.setText(style,model,color),style.text=labelText,"outside"===style.textPosition&&(style.textPosition=labelPositionOutside)}data.eachItemGraphicEl(function(rect,idx){var itemModel=data.getItemModel(idx),color=data.getItemVisual(idx,"color"),opacity=data.getItemVisual(idx,"opacity"),layout=data.getItemLayout(idx),itemStyleModel=itemModel.getModel("itemStyle.normal"),hoverStyle=itemModel.getModel("itemStyle.emphasis").getBarItemStyle();rect.setShape("r",itemStyleModel.get("barBorderRadius")||0),rect.setStyle(zrUtil.defaults({fill:color,opacity:opacity},itemStyleModel.getBarItemStyle()));var labelPositionOutside=isHorizontal?layout.height>0?"bottom":"top":layout.width>0?"left":"right",labelModel=itemModel.getModel("label.normal"),hoverLabelModel=itemModel.getModel("label.emphasis"),rectStyle=rect.style;labelModel.get("show")?setLabel(rectStyle,labelModel,color,zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"normal"),seriesModel.getRawValue(idx)),labelPositionOutside):rectStyle.text="",hoverLabelModel.get("show")?setLabel(hoverStyle,hoverLabelModel,color,zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"emphasis"),seriesModel.getRawValue(idx)),labelPositionOutside):hoverStyle.text="",graphic.setHoverStyle(rect,hoverStyle)})},remove:function(ecModel,api){var group=this.group;ecModel.get("animation")?this._data&&this._data.eachItemGraphicEl(function(el){
// Not show text when animating
el.style.text="",graphic.updateProps(el,{shape:{width:0}},ecModel,function(){group.remove(el)})}):group.removeAll()}})},/* 130 */
/***/
function(module,exports,__webpack_require__){module.exports={getBarItemStyle:__webpack_require__(11)([["fill","color"],["stroke","borderColor"],["lineWidth","borderWidth"],
// Compatitable with 2
["stroke","barBorderColor"],["lineWidth","barBorderWidth"],["opacity"],["shadowBlur"],["shadowOffsetX"],["shadowOffsetY"],["shadowColor"]])}},/* 131 */
/***/
function(module,exports,__webpack_require__){"use strict";function getSeriesStackId(seriesModel){return seriesModel.get("stack")||"__ec_stack_"+seriesModel.seriesIndex}function calBarWidthAndOffset(barSeries,api){
// Columns info on each category axis. Key is cartesian name
var columnsMap={};zrUtil.each(barSeries,function(seriesModel,idx){var cartesian=seriesModel.coordinateSystem,baseAxis=cartesian.getBaseAxis(),columnsOnAxis=columnsMap[baseAxis.index]||{remainedWidth:baseAxis.getBandWidth(),autoWidthCount:0,categoryGap:"20%",gap:"30%",axis:baseAxis,stacks:{}},stacks=columnsOnAxis.stacks;columnsMap[baseAxis.index]=columnsOnAxis;var stackId=getSeriesStackId(seriesModel);stacks[stackId]||columnsOnAxis.autoWidthCount++,stacks[stackId]=stacks[stackId]||{width:0,maxWidth:0};var barWidth=seriesModel.get("barWidth"),barMaxWidth=seriesModel.get("barMaxWidth"),barGap=seriesModel.get("barGap"),barCategoryGap=seriesModel.get("barCategoryGap");
// TODO
barWidth&&!stacks[stackId].width&&(barWidth=Math.min(columnsOnAxis.remainedWidth,barWidth),stacks[stackId].width=barWidth,columnsOnAxis.remainedWidth-=barWidth),barMaxWidth&&(stacks[stackId].maxWidth=barMaxWidth),null!=barGap&&(columnsOnAxis.gap=barGap),null!=barCategoryGap&&(columnsOnAxis.categoryGap=barCategoryGap)});var result={};return zrUtil.each(columnsMap,function(columnsOnAxis,coordSysName){result[coordSysName]={};var stacks=columnsOnAxis.stacks,baseAxis=columnsOnAxis.axis,bandWidth=baseAxis.getBandWidth(),categoryGap=parsePercent(columnsOnAxis.categoryGap,bandWidth),barGapPercent=parsePercent(columnsOnAxis.gap,1),remainedWidth=columnsOnAxis.remainedWidth,autoWidthCount=columnsOnAxis.autoWidthCount,autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent);autoWidth=Math.max(autoWidth,0),zrUtil.each(stacks,function(column,stack){var maxWidth=column.maxWidth;!column.width&&maxWidth&&autoWidth>maxWidth&&(maxWidth=Math.min(maxWidth,remainedWidth),remainedWidth-=maxWidth,column.width=maxWidth,autoWidthCount--)}),autoWidth=(remainedWidth-categoryGap)/(autoWidthCount+(autoWidthCount-1)*barGapPercent),autoWidth=Math.max(autoWidth,0);var lastColumn,widthSum=0;zrUtil.each(stacks,function(column,idx){column.width||(column.width=autoWidth),lastColumn=column,widthSum+=column.width*(1+barGapPercent)}),lastColumn&&(widthSum-=lastColumn.width*barGapPercent);var offset=-widthSum/2;zrUtil.each(stacks,function(column,stackId){result[coordSysName][stackId]=result[coordSysName][stackId]||{offset:offset,width:column.width},offset+=column.width*(1+barGapPercent)})}),result}/**
	     * @param {string} seriesType
	     * @param {module:echarts/model/Global} ecModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
function barLayoutGrid(seriesType,ecModel,api){var barWidthAndOffset=calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType),function(seriesModel){return!ecModel.isSeriesFiltered(seriesModel)&&seriesModel.coordinateSystem&&"cartesian2d"===seriesModel.coordinateSystem.type})),lastStackCoords={};ecModel.eachSeriesByType(seriesType,function(seriesModel){var data=seriesModel.getData(),cartesian=seriesModel.coordinateSystem,baseAxis=cartesian.getBaseAxis(),stackId=getSeriesStackId(seriesModel),columnLayoutInfo=barWidthAndOffset[baseAxis.index][stackId],columnOffset=columnLayoutInfo.offset,columnWidth=columnLayoutInfo.width,valueAxis=cartesian.getOtherAxis(baseAxis),barMinHeight=seriesModel.get("barMinHeight")||0,valueAxisStart=baseAxis.onZero?valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)):valueAxis.getGlobalExtent()[0],coords=cartesian.dataToPoints(data,!0);lastStackCoords[stackId]=lastStackCoords[stackId]||[],data.setLayout({offset:columnOffset,size:columnWidth}),data.each(valueAxis.dim,function(value,idx){
// 空数据
if(!isNaN(value)){lastStackCoords[stackId][idx]||(lastStackCoords[stackId][idx]={
// Positive stack
p:valueAxisStart,
// Negative stack
n:valueAxisStart});var x,y,width,height,sign=value>=0?"p":"n",coord=coords[idx],lastCoord=lastStackCoords[stackId][idx][sign];valueAxis.isHorizontal()?(x=lastCoord,y=coord[1]+columnOffset,width=coord[0]-lastCoord,height=columnWidth,Math.abs(width)<barMinHeight&&(width=(0>width?-1:1)*barMinHeight),lastStackCoords[stackId][idx][sign]+=width):(x=coord[0]+columnOffset,y=lastCoord,width=columnWidth,height=coord[1]-lastCoord,Math.abs(height)<barMinHeight&&(height=(0>=height?-1:1)*barMinHeight),lastStackCoords[stackId][idx][sign]+=height),data.setItemLayout(idx,{x:x,y:y,width:width,height:height})}},!0)},this)}var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),parsePercent=numberUtil.parsePercent;module.exports=barLayoutGrid},/* 132 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);__webpack_require__(133),__webpack_require__(135),__webpack_require__(136)("pie",[{type:"pieToggleSelect",event:"pieselectchanged",method:"toggleSelected"},{type:"pieSelect",event:"pieselected",method:"select"},{type:"pieUnSelect",event:"pieunselected",method:"unSelect"}]),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(137),"pie")),echarts.registerLayout(zrUtil.curry(__webpack_require__(138),"pie")),echarts.registerProcessor("filter",zrUtil.curry(__webpack_require__(140),"pie"))},/* 133 */
/***/
function(module,exports,__webpack_require__){"use strict";var List=__webpack_require__(94),zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),completeDimensions=__webpack_require__(96),dataSelectableMixin=__webpack_require__(134),PieSeries=__webpack_require__(1).extendSeriesModel({type:"series.pie",
// Overwrite
init:function(option){PieSeries.superApply(this,"init",arguments),
// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this._dataBeforeProcessed},this.updateSelectedMap(),this._defaultLabelLine(option)},
// Overwrite
mergeOption:function(newOption){PieSeries.superCall(this,"mergeOption",newOption),this.updateSelectedMap()},getInitialData:function(option,ecModel){var dimensions=completeDimensions(["value"],option.data),list=new List(dimensions,this);return list.initData(option.data),list},
// Overwrite
getDataParams:function(dataIndex){var data=this._data,params=PieSeries.superCall(this,"getDataParams",dataIndex),sum=data.getSum("value");
// FIXME toFixed?
//
// Percent is 0 if sum is 0
return params.percent=sum?+(data.get("value",dataIndex)/sum*100).toFixed(2):0,params.$vars.push("percent"),params},_defaultLabelLine:function(option){
// Extend labelLine emphasis
modelUtil.defaultEmphasis(option.labelLine,["show"]);var labelLineNormalOpt=option.labelLine.normal,labelLineEmphasisOpt=option.labelLine.emphasis;
// Not show label line if `label.normal.show = false`
labelLineNormalOpt.show=labelLineNormalOpt.show&&option.label.normal.show,labelLineEmphasisOpt.show=labelLineEmphasisOpt.show&&option.label.emphasis.show},defaultOption:{zlevel:0,z:2,legendHoverLink:!0,hoverAnimation:!0,
// 默认全局居中
center:["50%","50%"],radius:[0,"75%"],
// 默认顺时针
clockwise:!0,startAngle:90,
// 最小角度改为0
minAngle:0,
// 选中是扇区偏移量
selectedOffset:10,
// If use strategy to avoid label overlapping
avoidLabelOverlap:!0,
// 选择模式，默认关闭，可选single，multiple
// selectedMode: false,
// 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
// roseType: null,
label:{normal:{
// If rotate around circle
rotate:!1,show:!0,
// 'outer', 'inside', 'center'
position:"outer"},emphasis:{}},
// Enabled when label.normal.position is 'outer'
labelLine:{normal:{show:!0,
// 引导线两段中的第一段长度
length:15,
// 引导线两段中的第二段长度
length2:15,smooth:!1,lineStyle:{
// color: 各异,
width:1,type:"solid"}}},itemStyle:{normal:{
// color: 各异,
borderColor:"rgba(0,0,0,0)",borderWidth:1},emphasis:{
// color: 各异,
borderColor:"rgba(0,0,0,0)",borderWidth:1}},animationEasing:"cubicOut",data:[]}});zrUtil.mixin(PieSeries,dataSelectableMixin),module.exports=PieSeries},/* 134 */
/***/
function(module,exports,__webpack_require__){/**
	 * Data selectable mixin for chart series.
	 * To eanble data select, option of series must have `selectedMode`.
	 * And each data item will use `selected` to toggle itself selected status
	 *
	 * @module echarts/chart/helper/DataSelectable
	 */
var zrUtil=__webpack_require__(3);module.exports={updateSelectedMap:function(){var option=this.option;this._dataOptMap=zrUtil.reduce(option.data,function(dataOptMap,dataOpt){return dataOptMap[dataOpt.name]=dataOpt,dataOptMap},{})},/**
	         * @param {string} name
	         */
// PENGING If selectedMode is null ?
select:function(name){var dataOptMap=this._dataOptMap,dataOpt=dataOptMap[name],selectedMode=this.get("selectedMode");"single"===selectedMode&&zrUtil.each(dataOptMap,function(dataOpt){dataOpt.selected=!1}),dataOpt&&(dataOpt.selected=!0)},/**
	         * @param {string} name
	         */
unSelect:function(name){var dataOpt=this._dataOptMap[name];
// var selectedMode = this.get('selectedMode');
// selectedMode !== 'single' && dataOpt && (dataOpt.selected = false);
dataOpt&&(dataOpt.selected=!1)},/**
	         * @param {string} name
	         */
toggleSelected:function(name){var dataOpt=this._dataOptMap[name];return null!=dataOpt?(this[dataOpt.selected?"unSelect":"select"](name),dataOpt.selected):void 0},/**
	         * @param {string} name
	         */
isSelected:function(name){var dataOpt=this._dataOptMap[name];return dataOpt&&dataOpt.selected}}},/* 135 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {module:echarts/model/Series} seriesModel
	     * @param {boolean} hasAnimation
	     * @inner
	     */
function updateDataSelected(uid,seriesModel,hasAnimation,api){var data=seriesModel.getData(),dataIndex=this.dataIndex,name=data.getName(dataIndex),selectedOffset=seriesModel.get("selectedOffset");api.dispatchAction({type:"pieToggleSelect",from:uid,name:name,seriesId:seriesModel.id}),data.each(function(idx){toggleItemSelected(data.getItemGraphicEl(idx),data.getItemLayout(idx),seriesModel.isSelected(data.getName(idx)),selectedOffset,hasAnimation)})}/**
	     * @param {module:zrender/graphic/Sector} el
	     * @param {Object} layout
	     * @param {boolean} isSelected
	     * @param {number} selectedOffset
	     * @param {boolean} hasAnimation
	     * @inner
	     */
function toggleItemSelected(el,layout,isSelected,selectedOffset,hasAnimation){var midAngle=(layout.startAngle+layout.endAngle)/2,dx=Math.cos(midAngle),dy=Math.sin(midAngle),offset=isSelected?selectedOffset:0,position=[dx*offset,dy*offset];hasAnimation?el.animate().when(200,{position:position}).start("bounceOut"):el.attr("position",position)}/**
	     * Piece of pie including Sector, Label, LabelLine
	     * @constructor
	     * @extends {module:zrender/graphic/Group}
	     */
function PiePiece(data,idx){
// Hover to change label and labelLine
function onEmphasis(){polyline.ignore=polyline.hoverIgnore,text.ignore=text.hoverIgnore}function onNormal(){polyline.ignore=polyline.normalIgnore,text.ignore=text.normalIgnore}graphic.Group.call(this);var sector=new graphic.Sector({z2:2}),polyline=new graphic.Polyline,text=new graphic.Text;this.add(sector),this.add(polyline),this.add(text),this.updateData(data,idx,!0),this.on("emphasis",onEmphasis).on("normal",onNormal).on("mouseover",onEmphasis).on("mouseout",onNormal)}function getLabelStyle(data,idx,state,labelModel,labelPosition){var textStyleModel=labelModel.getModel("textStyle"),isLabelInside="inside"===labelPosition||"inner"===labelPosition;return{fill:textStyleModel.getTextColor()||(isLabelInside?"#fff":data.getItemVisual(idx,"color")),textFont:textStyleModel.getFont(),text:zrUtil.retrieve(data.hostModel.getFormattedLabel(idx,state),data.getName(idx))}}var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),piePieceProto=PiePiece.prototype;piePieceProto.updateData=function(data,idx,firstCreate){function onEmphasis(){
// Sector may has animation of updating data. Force to move to the last frame
// Or it may stopped on the wrong shape
sector.stopAnimation(!0),sector.animateTo({shape:{r:layout.r+10}},300,"elasticOut")}function onNormal(){sector.stopAnimation(!0),sector.animateTo({shape:{r:layout.r}},300,"elasticOut")}var sector=this.childAt(0),seriesModel=data.hostModel,itemModel=data.getItemModel(idx),layout=data.getItemLayout(idx),sectorShape=zrUtil.extend({},layout);sectorShape.label=null,firstCreate?(sector.setShape(sectorShape),sector.shape.endAngle=layout.startAngle,graphic.updateProps(sector,{shape:{endAngle:layout.endAngle}},seriesModel)):graphic.updateProps(sector,{shape:sectorShape},seriesModel);
// Update common style
var itemStyleModel=itemModel.getModel("itemStyle"),visualColor=data.getItemVisual(idx,"color");sector.setStyle(zrUtil.defaults({fill:visualColor},itemStyleModel.getModel("normal").getItemStyle())),sector.hoverStyle=itemStyleModel.getModel("emphasis").getItemStyle(),
// Toggle selected
toggleItemSelected(this,data.getItemLayout(idx),itemModel.get("selected"),seriesModel.get("selectedOffset"),seriesModel.get("animation")),sector.off("mouseover").off("mouseout").off("emphasis").off("normal"),itemModel.get("hoverAnimation")&&sector.on("mouseover",onEmphasis).on("mouseout",onNormal).on("emphasis",onEmphasis).on("normal",onNormal),this._updateLabel(data,idx),graphic.setHoverStyle(this)},piePieceProto._updateLabel=function(data,idx){var labelLine=this.childAt(1),labelText=this.childAt(2),seriesModel=data.hostModel,itemModel=data.getItemModel(idx),layout=data.getItemLayout(idx),labelLayout=layout.label,visualColor=data.getItemVisual(idx,"color");graphic.updateProps(labelLine,{shape:{points:labelLayout.linePoints||[[labelLayout.x,labelLayout.y],[labelLayout.x,labelLayout.y],[labelLayout.x,labelLayout.y]]}},seriesModel),graphic.updateProps(labelText,{style:{x:labelLayout.x,y:labelLayout.y}},seriesModel),labelText.attr({style:{textVerticalAlign:labelLayout.verticalAlign,textAlign:labelLayout.textAlign,textFont:labelLayout.font},rotation:labelLayout.rotation,origin:[labelLayout.x,labelLayout.y],z2:10});var labelModel=itemModel.getModel("label.normal"),labelHoverModel=itemModel.getModel("label.emphasis"),labelLineModel=itemModel.getModel("labelLine.normal"),labelLineHoverModel=itemModel.getModel("labelLine.emphasis"),labelPosition=labelModel.get("position")||labelHoverModel.get("position");labelText.setStyle(getLabelStyle(data,idx,"normal",labelModel,labelPosition)),labelText.ignore=labelText.normalIgnore=!labelModel.get("show"),labelText.hoverIgnore=!labelHoverModel.get("show"),labelLine.ignore=labelLine.normalIgnore=!labelLineModel.get("show"),labelLine.hoverIgnore=!labelLineHoverModel.get("show"),
// Default use item visual color
labelLine.setStyle({stroke:visualColor}),labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle()),labelText.hoverStyle=getLabelStyle(data,idx,"emphasis",labelHoverModel,labelPosition),labelLine.hoverStyle=labelLineHoverModel.getModel("lineStyle").getLineStyle();var smooth=labelLineModel.get("smooth");smooth&&smooth===!0&&(smooth=.4),labelLine.setShape({smooth:smooth})},zrUtil.inherits(PiePiece,graphic.Group);
// Pie view
var Pie=__webpack_require__(41).extend({type:"pie",init:function(){var sectorGroup=new graphic.Group;this._sectorGroup=sectorGroup},render:function(seriesModel,ecModel,api,payload){if(!payload||payload.from!==this.uid){var data=seriesModel.getData(),oldData=this._data,group=this.group,hasAnimation=ecModel.get("animation"),isFirstRender=!oldData,onSectorClick=zrUtil.curry(updateDataSelected,this.uid,seriesModel,hasAnimation,api),selectedMode=seriesModel.get("selectedMode");if(data.diff(oldData).add(function(idx){var piePiece=new PiePiece(data,idx);isFirstRender&&piePiece.eachChild(function(child){child.stopAnimation(!0)}),selectedMode&&piePiece.on("click",onSectorClick),data.setItemGraphicEl(idx,piePiece),group.add(piePiece)}).update(function(newIdx,oldIdx){var piePiece=oldData.getItemGraphicEl(oldIdx);piePiece.updateData(data,newIdx),piePiece.off("click"),selectedMode&&piePiece.on("click",onSectorClick),group.add(piePiece),data.setItemGraphicEl(newIdx,piePiece)}).remove(function(idx){var piePiece=oldData.getItemGraphicEl(idx);group.remove(piePiece)}).execute(),hasAnimation&&isFirstRender&&data.count()>0){var shape=data.getItemLayout(0),r=Math.max(api.getWidth(),api.getHeight())/2,removeClipPath=zrUtil.bind(group.removeClipPath,group);group.setClipPath(this._createClipPath(shape.cx,shape.cy,r,shape.startAngle,shape.clockwise,removeClipPath,seriesModel))}this._data=data}},_createClipPath:function(cx,cy,r,startAngle,clockwise,cb,seriesModel){var clipPath=new graphic.Sector({shape:{cx:cx,cy:cy,r0:0,r:r,startAngle:startAngle,endAngle:startAngle,clockwise:clockwise}});return graphic.initProps(clipPath,{shape:{endAngle:startAngle+(clockwise?1:-1)*Math.PI*2}},seriesModel,cb),clipPath}});module.exports=Pie},/* 136 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1),zrUtil=__webpack_require__(3);module.exports=function(seriesType,actionInfos){zrUtil.each(actionInfos,function(actionInfo){actionInfo.update="updateView",/**
	             * @payload
	             * @property {string} seriesName
	             * @property {string} name
	             */
echarts.registerAction(actionInfo,function(payload,ecModel){var selected={};return ecModel.eachComponent({mainType:"series",subType:seriesType,query:payload},function(seriesModel){seriesModel[actionInfo.method]&&seriesModel[actionInfo.method](payload.name);var data=seriesModel.getData();
// Create selected map
data.each(function(idx){var name=data.getName(idx);selected[name]=seriesModel.isSelected(name)||!1})}),{name:payload.name,selected:selected}})})}},/* 137 */
/***/
function(module,exports){
// Pick color from palette for each data item
module.exports=function(seriesType,ecModel){var globalColorList=ecModel.get("color"),offset=0;ecModel.eachRawSeriesByType(seriesType,function(seriesModel){var colorList=seriesModel.get("color",!0),dataAll=seriesModel.getRawData();if(!ecModel.isSeriesFiltered(seriesModel)){var data=seriesModel.getData();data.each(function(idx){var itemModel=data.getItemModel(idx),rawIdx=data.getRawIndex(idx),singleDataColor=data.getItemVisual(idx,"color",!0);if(singleDataColor)
// Set data all color for legend
dataAll.setItemVisual(rawIdx,"color",singleDataColor);else{var paletteColor=colorList?colorList[rawIdx%colorList.length]:globalColorList[(rawIdx+offset)%globalColorList.length],color=itemModel.get("itemStyle.normal.color")||paletteColor;
// Legend may use the visual info in data before processed
dataAll.setItemVisual(rawIdx,"color",color),data.setItemVisual(idx,"color",color)}})}offset+=dataAll.count()})}},/* 138 */
/***/
function(module,exports,__webpack_require__){
// TODO minAngle
var numberUtil=__webpack_require__(7),parsePercent=numberUtil.parsePercent,labelLayout=__webpack_require__(139),zrUtil=__webpack_require__(3),PI2=2*Math.PI,RADIAN=Math.PI/180;module.exports=function(seriesType,ecModel,api){ecModel.eachSeriesByType(seriesType,function(seriesModel){var center=seriesModel.get("center"),radius=seriesModel.get("radius");zrUtil.isArray(radius)||(radius=[0,radius]),zrUtil.isArray(center)||(center=[center,center]);var width=api.getWidth(),height=api.getHeight(),size=Math.min(width,height),cx=parsePercent(center[0],width),cy=parsePercent(center[1],height),r0=parsePercent(radius[0],size/2),r=parsePercent(radius[1],size/2),data=seriesModel.getData(),startAngle=-seriesModel.get("startAngle")*RADIAN,minAngle=seriesModel.get("minAngle")*RADIAN,sum=data.getSum("value"),unitRadian=Math.PI/(sum||data.count())*2,clockwise=seriesModel.get("clockwise"),roseType=seriesModel.get("roseType"),extent=data.getDataExtent("value");extent[0]=0;
// In the case some sector angle is smaller than minAngle
var restAngle=PI2,valueSumLargerThanMinAngle=0,currentAngle=startAngle,dir=clockwise?1:-1;
// Some sector is constrained by minAngle
// Rest sectors needs recalculate angle
if(data.each("value",function(value,idx){var angle;
// FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？
angle="area"!==roseType?0===sum?unitRadian:value*unitRadian:PI2/(data.count()||1),minAngle>angle?(angle=minAngle,restAngle-=minAngle):valueSumLargerThanMinAngle+=value;var endAngle=currentAngle+dir*angle;data.setItemLayout(idx,{angle:angle,startAngle:currentAngle,endAngle:endAngle,clockwise:clockwise,cx:cx,cy:cy,r0:r0,r:roseType?numberUtil.linearMap(value,extent,[r0,r]):r}),currentAngle=endAngle},!0),PI2>restAngle)
// Average the angle if rest angle is not enough after all angles is
// Constrained by minAngle
if(.001>=restAngle){var angle=PI2/data.count();data.each(function(idx){var layout=data.getItemLayout(idx);layout.startAngle=startAngle+dir*idx*angle,layout.endAngle=startAngle+dir*(idx+1)*angle})}else unitRadian=restAngle/valueSumLargerThanMinAngle,currentAngle=startAngle,data.each("value",function(value,idx){var layout=data.getItemLayout(idx),angle=layout.angle===minAngle?minAngle:value*unitRadian;layout.startAngle=currentAngle,layout.endAngle=currentAngle+dir*angle,currentAngle+=angle});labelLayout(seriesModel,r,width,height)})}},/* 139 */
/***/
function(module,exports,__webpack_require__){"use strict";function adjustSingleSide(list,cx,cy,r,dir,viewWidth,viewHeight){
// 压
function shiftDown(start,end,delta,dir){for(var j=start;end>j;j++)if(list[j].y+=delta,j>start&&end>j+1&&list[j+1].y>list[j].y+list[j].height)return void shiftUp(j,delta/2);shiftUp(end-1,delta/2)}
// 弹
function shiftUp(end,delta){for(var j=end;j>=0&&(list[j].y-=delta,!(j>0&&list[j].y>list[j-1].y+list[j-1].height));j--);}function changeX(list,isDownList,cx,cy,r,dir){// 上
for(var lastDeltaX=dir>0?isDownList?Number.MAX_VALUE:0:isDownList?Number.MAX_VALUE:0,i=0,l=list.length;l>i;i++)
// Not change x for center label
if("center"!==list[i].position){var deltaY=Math.abs(list[i].y-cy),length=list[i].len,length2=list[i].len2,deltaX=r+length>deltaY?Math.sqrt((r+length+length2)*(r+length+length2)-deltaY*deltaY):Math.abs(list[i].x-cx);isDownList&&deltaX>=lastDeltaX&&(
// 右下，左下
deltaX=lastDeltaX-10),!isDownList&&lastDeltaX>=deltaX&&(
// 右上，左上
deltaX=lastDeltaX+10),list[i].x=cx+deltaX*dir,lastDeltaX=deltaX}}list.sort(function(a,b){return a.y-b.y});for(var delta,lastY=0,len=list.length,upList=[],downList=[],i=0;len>i;i++)delta=list[i].y-lastY,0>delta&&shiftDown(i,len,-delta,dir),lastY=list[i].y+list[i].height;0>viewHeight-lastY&&shiftUp(len-1,lastY-viewHeight);for(var i=0;len>i;i++)list[i].y>=cy?downList.push(list[i]):upList.push(list[i]);changeX(upList,!1,cx,cy,r,dir),changeX(downList,!0,cx,cy,r,dir)}function avoidOverlap(labelLayoutList,cx,cy,r,viewWidth,viewHeight){for(var leftList=[],rightList=[],i=0;i<labelLayoutList.length;i++)labelLayoutList[i].x<cx?leftList.push(labelLayoutList[i]):rightList.push(labelLayoutList[i]);adjustSingleSide(rightList,cx,cy,r,1,viewWidth,viewHeight),adjustSingleSide(leftList,cx,cy,r,-1,viewWidth,viewHeight);for(var i=0;i<labelLayoutList.length;i++){var linePoints=labelLayoutList[i].linePoints;if(linePoints){var dist=linePoints[1][0]-linePoints[2][0];labelLayoutList[i].x<cx?linePoints[2][0]=labelLayoutList[i].x+3:linePoints[2][0]=labelLayoutList[i].x-3,linePoints[1][1]=linePoints[2][1]=labelLayoutList[i].y,linePoints[1][0]=linePoints[2][0]+dist}}}
// FIXME emphasis label position is not same with normal label position
var textContain=__webpack_require__(14);module.exports=function(seriesModel,r,viewWidth,viewHeight){var cx,cy,data=seriesModel.getData(),labelLayoutList=[],hasLabelRotate=!1;data.each(function(idx){var textX,textY,linePoints,textAlign,layout=data.getItemLayout(idx),itemModel=data.getItemModel(idx),labelModel=itemModel.getModel("label.normal"),labelPosition=labelModel.get("position")||itemModel.get("label.emphasis.position"),labelLineModel=itemModel.getModel("labelLine.normal"),labelLineLen=labelLineModel.get("length"),labelLineLen2=labelLineModel.get("length2"),midAngle=(layout.startAngle+layout.endAngle)/2,dx=Math.cos(midAngle),dy=Math.sin(midAngle);cx=layout.cx,cy=layout.cy;var isLabelInside="inside"===labelPosition||"inner"===labelPosition;if("center"===labelPosition)textX=layout.cx,textY=layout.cy,textAlign="center";else{var x1=(isLabelInside?(layout.r+layout.r0)/2*dx:layout.r*dx)+cx,y1=(isLabelInside?(layout.r+layout.r0)/2*dy:layout.r*dy)+cy;if(textX=x1+3*dx,textY=y1+3*dy,!isLabelInside){
// For roseType
var x2=x1+dx*(labelLineLen+r-layout.r),y2=y1+dy*(labelLineLen+r-layout.r),x3=x2+(0>dx?-1:1)*labelLineLen2,y3=y2;textX=x3+(0>dx?-5:5),textY=y3,linePoints=[[x1,y1],[x2,y2],[x3,y3]]}textAlign=isLabelInside?"center":dx>0?"left":"right"}var font=labelModel.getModel("textStyle").getFont(),labelRotate=labelModel.get("rotate")?0>dx?-midAngle+Math.PI:-midAngle:0,text=seriesModel.getFormattedLabel(idx,"normal")||data.getName(idx),textRect=textContain.getBoundingRect(text,font,textAlign,"top");hasLabelRotate=!!labelRotate,layout.label={x:textX,y:textY,position:labelPosition,height:textRect.height,len:labelLineLen,len2:labelLineLen2,linePoints:linePoints,textAlign:textAlign,verticalAlign:"middle",font:font,rotation:labelRotate},isLabelInside||labelLayoutList.push(layout.label)}),!hasLabelRotate&&seriesModel.get("avoidLabelOverlap")&&avoidOverlap(labelLayoutList,cx,cy,r,viewWidth,viewHeight)}},/* 140 */
/***/
function(module,exports){module.exports=function(seriesType,ecModel){var legendModels=ecModel.findComponents({mainType:"legend"});legendModels&&legendModels.length&&ecModel.eachSeriesByType(seriesType,function(series){var data=series.getData();data.filterSelf(function(idx){
// If in any legend component the status is not selected.
for(var name=data.getName(idx),i=0;i<legendModels.length;i++)if(!legendModels[i].isSelected(name))return!1;return!0},this)},this)}},/* 141 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);__webpack_require__(142),__webpack_require__(143),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(103),"scatter","circle",null)),echarts.registerLayout(zrUtil.curry(__webpack_require__(104),"scatter")),
// In case developer forget to include grid component
__webpack_require__(106)},/* 142 */
/***/
function(module,exports,__webpack_require__){"use strict";var createListFromArray=__webpack_require__(93),SeriesModel=__webpack_require__(27);module.exports=SeriesModel.extend({type:"series.scatter",dependencies:["grid","polar"],getInitialData:function(option,ecModel){var list=createListFromArray(option.data,this,ecModel);return list},defaultOption:{coordinateSystem:"cartesian2d",zlevel:0,z:2,legendHoverLink:!0,hoverAnimation:!0,
// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,
// Polar coordinate system
polarIndex:0,
// Geo coordinate system
geoIndex:0,
// symbol: null,        // 图形类型
symbolSize:10,// 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
// symbolRotate: null,  // 图形旋转控制
large:!1,
// Available when large is true
largeThreshold:2e3,
// label: {
// normal: {
// show: false
// distance: 5,
// formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
// position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
//           'inside'|'left'|'right'|'top'|'bottom'
// textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
//     }
// },
itemStyle:{normal:{opacity:.8}}}})},/* 143 */
/***/
function(module,exports,__webpack_require__){var SymbolDraw=__webpack_require__(98),LargeSymbolDraw=__webpack_require__(144);__webpack_require__(1).extendChartView({type:"scatter",init:function(){this._normalSymbolDraw=new SymbolDraw,this._largeSymbolDraw=new LargeSymbolDraw},render:function(seriesModel,ecModel,api){var data=seriesModel.getData(),largeSymbolDraw=this._largeSymbolDraw,normalSymbolDraw=this._normalSymbolDraw,group=this.group,symbolDraw=seriesModel.get("large")&&data.count()>seriesModel.get("largeThreshold")?largeSymbolDraw:normalSymbolDraw;this._symbolDraw=symbolDraw,symbolDraw.updateData(data),group.add(symbolDraw.group),group.remove(symbolDraw===largeSymbolDraw?normalSymbolDraw.group:largeSymbolDraw.group)},updateLayout:function(seriesModel){this._symbolDraw.updateLayout(seriesModel)},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove(api,!0)}})},/* 144 */
/***/
function(module,exports,__webpack_require__){function LargeSymbolDraw(){this.group=new graphic.Group,this._symbolEl=new LargeSymbolPath({silent:!0})}var graphic=__webpack_require__(42),symbolUtil=__webpack_require__(100),zrUtil=__webpack_require__(3),LargeSymbolPath=graphic.extendShape({shape:{points:null,sizes:null},symbolProxy:null,buildPath:function(path,shape){for(var points=shape.points,sizes=shape.sizes,symbolProxy=this.symbolProxy,symbolProxyShape=symbolProxy.shape,i=0;i<points.length;i++){var pt=points[i],size=sizes[i];size[0]<4?
// Optimize for small symbol
path.rect(pt[0]-size[0]/2,pt[1]-size[1]/2,size[0],size[1]):(symbolProxyShape.x=pt[0]-size[0]/2,symbolProxyShape.y=pt[1]-size[1]/2,symbolProxyShape.width=size[0],symbolProxyShape.height=size[1],symbolProxy.buildPath(path,symbolProxyShape))}}}),largeSymbolProto=LargeSymbolDraw.prototype;/**
	     * Update symbols draw by new data
	     * @param {module:echarts/data/List} data
	     */
largeSymbolProto.updateData=function(data){this.group.removeAll();var symbolEl=this._symbolEl,seriesModel=data.hostModel;symbolEl.setShape({points:data.mapArray(data.getItemLayout),sizes:data.mapArray(function(idx){var size=data.getItemVisual(idx,"symbolSize");return zrUtil.isArray(size)||(size=[size,size]),size})}),
// Create symbolProxy to build path for each data
symbolEl.symbolProxy=symbolUtil.createSymbol(data.getVisual("symbol"),0,0,0,0),
// Use symbolProxy setColor method
symbolEl.setColor=symbolEl.symbolProxy.setColor,symbolEl.setStyle(seriesModel.getModel("itemStyle.normal").getItemStyle(["color"]));var visualColor=data.getVisual("color");visualColor&&symbolEl.setColor(visualColor),
// Add back
this.group.add(this._symbolEl)},largeSymbolProto.updateLayout=function(seriesModel){var data=seriesModel.getData();this._symbolEl.setShape({points:data.mapArray(data.getItemLayout)})},largeSymbolProto.remove=function(){this.group.removeAll()},module.exports=LargeSymbolDraw},/* 145 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);
// Must use radar component
__webpack_require__(146),__webpack_require__(151),__webpack_require__(152),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(137),"radar")),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(103),"radar","circle",null)),echarts.registerLayout(__webpack_require__(153)),echarts.registerProcessor("filter",zrUtil.curry(__webpack_require__(140),"radar")),echarts.registerPreprocessor(__webpack_require__(154))},/* 146 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(147),__webpack_require__(149),__webpack_require__(150)},/* 147 */
/***/
function(module,exports,__webpack_require__){function Radar(radarModel,ecModel,api){this._model=radarModel,/**
	         * Radar dimensions
	         * @type {Array.<string>}
	         */
this.dimensions=[],this._indicatorAxes=zrUtil.map(radarModel.getIndicatorModels(),function(indicatorModel,idx){var dim="indicator_"+idx,indicatorAxis=new IndicatorAxis(dim,new IntervalScale);
// Inject model and axis
return indicatorAxis.name=indicatorModel.get("name"),indicatorAxis.model=indicatorModel,indicatorModel.axis=indicatorAxis,this.dimensions.push(dim),indicatorAxis},this),this.resize(radarModel,api),/**
	         * @type {number}
	         * @readOnly
	         */
this.cx,/**
	         * @type {number}
	         * @readOnly
	         */
this.cy,/**
	         * @type {number}
	         * @readOnly
	         */
this.r,/**
	         * @type {number}
	         * @readOnly
	         */
this.startAngle}
// TODO clockwise
var zrUtil=__webpack_require__(3),IndicatorAxis=__webpack_require__(148),IntervalScale=__webpack_require__(111),numberUtil=__webpack_require__(7),axisHelper=__webpack_require__(108);Radar.prototype.getIndicatorAxes=function(){return this._indicatorAxes},Radar.prototype.dataToPoint=function(value,indicatorIndex){var indicatorAxis=this._indicatorAxes[indicatorIndex];return this.coordToPoint(indicatorAxis.dataToCoord(value),indicatorIndex)},Radar.prototype.coordToPoint=function(coord,indicatorIndex){var indicatorAxis=this._indicatorAxes[indicatorIndex],angle=indicatorAxis.angle,x=this.cx+coord*Math.cos(angle),y=this.cy-coord*Math.sin(angle);return[x,y]},Radar.prototype.pointToData=function(pt){var dx=pt[0]-this.cx,dy=pt[1]-this.cy,radius=Math.sqrt(dx*dx+dy*dy);dx/=radius,dy/=radius;for(var closestAxis,radian=Math.atan2(-dy,dx),minRadianDiff=1/0,closestAxisIdx=-1,i=0;i<this._indicatorAxes.length;i++){var indicatorAxis=this._indicatorAxes[i],diff=Math.abs(radian-indicatorAxis.angle);minRadianDiff>diff&&(closestAxis=indicatorAxis,closestAxisIdx=i,minRadianDiff=diff)}return[closestAxisIdx,+(closestAxis&&closestAxis.coodToData(radius))]},Radar.prototype.resize=function(radarModel,api){var center=radarModel.get("center"),viewWidth=api.getWidth(),viewHeight=api.getHeight(),viewSize=Math.min(viewWidth,viewHeight)/2;this.cx=numberUtil.parsePercent(center[0],viewWidth),this.cy=numberUtil.parsePercent(center[1],viewHeight),this.startAngle=radarModel.get("startAngle")*Math.PI/180,this.r=numberUtil.parsePercent(radarModel.get("radius"),viewSize),zrUtil.each(this._indicatorAxes,function(indicatorAxis,idx){indicatorAxis.setExtent(0,this.r);var angle=this.startAngle+idx*Math.PI*2/this._indicatorAxes.length;angle=Math.atan2(Math.sin(angle),Math.cos(angle)),indicatorAxis.angle=angle},this)},Radar.prototype.update=function(ecModel,api){function increaseInterval(interval){var exp10=Math.pow(10,Math.floor(Math.log(interval)/Math.LN10)),f=interval/exp10;// f is 2 or 5
return 2===f?f=5:f*=2,f*exp10}var indicatorAxes=this._indicatorAxes,radarModel=this._model;zrUtil.each(indicatorAxes,function(indicatorAxis){indicatorAxis.scale.setExtent(1/0,-(1/0))}),ecModel.eachSeriesByType("radar",function(radarSeries,idx){if("radar"===radarSeries.get("coordinateSystem")&&ecModel.getComponent("radar",radarSeries.get("radarIndex"))===radarModel){var data=radarSeries.getData();zrUtil.each(indicatorAxes,function(indicatorAxis){indicatorAxis.scale.unionExtent(data.getDataExtent(indicatorAxis.dim))})}},this);var splitNumber=radarModel.get("splitNumber");
// Force all the axis fixing the maxSplitNumber.
zrUtil.each(indicatorAxes,function(indicatorAxis,idx){var rawExtent=axisHelper.getScaleExtent(indicatorAxis,indicatorAxis.model);axisHelper.niceScaleExtent(indicatorAxis,indicatorAxis.model);var axisModel=indicatorAxis.model,scale=indicatorAxis.scale,fixedMin=axisModel.get("min"),fixedMax=axisModel.get("max"),interval=scale.getInterval();if(null!=fixedMin&&null!=fixedMax)
// User set min, max, divide to get new interval
// FIXME precision
scale.setInterval((fixedMax-fixedMin)/splitNumber);else if(null!=fixedMin){var max;
// User set min, expand extent on the other side
do max=fixedMin+interval*splitNumber,scale.setExtent(+fixedMin,max),scale.setInterval(interval),interval=increaseInterval(interval);while(max<rawExtent[1]&&isFinite(max)&&isFinite(rawExtent[1]))}else if(null!=fixedMax){var min;
// User set min, expand extent on the other side
do min=fixedMax-interval*splitNumber,scale.setExtent(min,+fixedMax),scale.setInterval(interval),interval=increaseInterval(interval);while(min>rawExtent[0]&&isFinite(min)&&isFinite(rawExtent[0]))}else{var nicedSplitNumber=scale.getTicks().length-1;nicedSplitNumber>splitNumber&&(interval=increaseInterval(interval));
// PENDING
var center=Math.round((rawExtent[0]+rawExtent[1])/2/interval)*interval,halfSplitNumber=Math.round(splitNumber/2);scale.setExtent(numberUtil.round(center-halfSplitNumber*interval),numberUtil.round(center+(splitNumber-halfSplitNumber)*interval)),scale.setInterval(interval)}})},/**
	     * Radar dimensions is based on the data
	     * @type {Array}
	     */
Radar.dimensions=[],Radar.create=function(ecModel,api){var radarList=[];return ecModel.eachComponent("radar",function(radarModel){var radar=new Radar(radarModel,ecModel,api);radarList.push(radar),radarModel.coordinateSystem=radar}),ecModel.eachSeriesByType("radar",function(radarSeries){"radar"===radarSeries.get("coordinateSystem")&&(
// Inject coordinate system
radarSeries.coordinateSystem=radarList[radarSeries.get("radarIndex")||0])}),radarList},__webpack_require__(25).register("radar",Radar),module.exports=Radar},/* 148 */
/***/
function(module,exports,__webpack_require__){function IndicatorAxis(dim,scale,radiusExtent){Axis.call(this,dim,scale,radiusExtent),/**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
this.type="value",this.angle=0,/**
	         * Indicator name
	         * @type {string}
	         */
this.name="",/**
	         * @type {module:echarts/model/Model}
	         */
this.model}var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117);zrUtil.inherits(IndicatorAxis,Axis),module.exports=IndicatorAxis},/* 149 */
/***/
function(module,exports,__webpack_require__){function defaultsShow(opt,show){return zrUtil.defaults({show:show},opt)}var axisDefault=__webpack_require__(122),valueAxisDefault=axisDefault.valueAxis,Model=__webpack_require__(8),zrUtil=__webpack_require__(3),axisModelCommonMixin=__webpack_require__(123),RadarModel=__webpack_require__(1).extendComponentModel({type:"radar",optionUpdated:function(){var boundaryGap=this.get("boundaryGap"),splitNumber=this.get("splitNumber"),scale=this.get("scale"),axisLine=this.get("axisLine"),axisTick=this.get("axisTick"),axisLabel=this.get("axisLabel"),nameTextStyle=this.get("name.textStyle"),showName=this.get("name.show"),nameFormatter=this.get("name.formatter"),nameGap=this.get("nameGap"),indicatorModels=zrUtil.map(this.get("indicator")||[],function(indicatorOpt){
// PENDING
// Use same configuration
return null!=indicatorOpt.max&&indicatorOpt.max>0?indicatorOpt.min=0:null!=indicatorOpt.min&&indicatorOpt.min<0&&(indicatorOpt.max=0),indicatorOpt=zrUtil.merge(zrUtil.clone(indicatorOpt),{boundaryGap:boundaryGap,splitNumber:splitNumber,scale:scale,axisLine:axisLine,axisTick:axisTick,axisLabel:axisLabel,
// Competitable with 2 and use text
name:indicatorOpt.text,nameLocation:"end",nameGap:nameGap,
// min: 0,
nameTextStyle:nameTextStyle},!1),showName||(indicatorOpt.name=""),"string"==typeof nameFormatter?indicatorOpt.name=nameFormatter.replace("{value}",indicatorOpt.name):"function"==typeof nameFormatter&&(indicatorOpt.name=nameFormatter(indicatorOpt.name,indicatorOpt)),zrUtil.extend(new Model(indicatorOpt,null,this.ecModel),axisModelCommonMixin)},this);this.getIndicatorModels=function(){return indicatorModels}},defaultOption:{zlevel:0,z:0,center:["50%","50%"],radius:"75%",startAngle:90,name:{show:!0},boundaryGap:[0,0],splitNumber:5,nameGap:15,scale:!1,
// Polygon or circle
shape:"polygon",axisLine:zrUtil.merge({lineStyle:{color:"#bbb"}},valueAxisDefault.axisLine),axisLabel:defaultsShow(valueAxisDefault.axisLabel,!1),axisTick:defaultsShow(valueAxisDefault.axisTick,!1),splitLine:defaultsShow(valueAxisDefault.splitLine,!0),splitArea:defaultsShow(valueAxisDefault.splitArea,!0),
// {text, min, max}
indicator:[]}});module.exports=RadarModel},/* 150 */
/***/
function(module,exports,__webpack_require__){var AxisBuilder=__webpack_require__(126),zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),axisBuilderAttrs=["axisLine","axisLabel","axisTick","axisName"];module.exports=__webpack_require__(1).extendComponentView({type:"radar",render:function(radarModel,ecModel,api){var group=this.group;group.removeAll(),this._buildAxes(radarModel),this._buildSplitLineAndArea(radarModel)},_buildAxes:function(radarModel){var radar=radarModel.coordinateSystem,indicatorAxes=radar.getIndicatorAxes(),axisBuilders=zrUtil.map(indicatorAxes,function(indicatorAxis){var axisBuilder=new AxisBuilder(indicatorAxis.model,{position:[radar.cx,radar.cy],rotation:indicatorAxis.angle,labelDirection:-1,tickDirection:-1,nameDirection:1});return axisBuilder});zrUtil.each(axisBuilders,function(axisBuilder){zrUtil.each(axisBuilderAttrs,axisBuilder.add,axisBuilder),this.group.add(axisBuilder.getGroup())},this)},_buildSplitLineAndArea:function(radarModel){function getColorIndex(areaOrLine,areaOrLineColorList,idx){var colorIndex=idx%areaOrLineColorList.length;return areaOrLine[colorIndex]=areaOrLine[colorIndex]||[],colorIndex}var radar=radarModel.coordinateSystem,splitNumber=radarModel.get("splitNumber"),indicatorAxes=radar.getIndicatorAxes();if(indicatorAxes.length){var shape=radarModel.get("shape"),splitLineModel=radarModel.getModel("splitLine"),splitAreaModel=radarModel.getModel("splitArea"),lineStyleModel=splitLineModel.getModel("lineStyle"),areaStyleModel=splitAreaModel.getModel("areaStyle"),showSplitLine=splitLineModel.get("show"),showSplitArea=splitAreaModel.get("show"),splitLineColors=lineStyleModel.get("color"),splitAreaColors=areaStyleModel.get("color");splitLineColors=zrUtil.isArray(splitLineColors)?splitLineColors:[splitLineColors],splitAreaColors=zrUtil.isArray(splitAreaColors)?splitAreaColors:[splitAreaColors];var splitLines=[],splitAreas=[];if("circle"===shape)for(var ticksRadius=indicatorAxes[0].getTicksCoords(),cx=radar.cx,cy=radar.cy,i=0;i<ticksRadius.length;i++){if(showSplitLine){var colorIndex=getColorIndex(splitLines,splitLineColors,i);splitLines[colorIndex].push(new graphic.Circle({shape:{cx:cx,cy:cy,r:ticksRadius[i]}}))}if(showSplitArea&&i<ticksRadius.length-1){var colorIndex=getColorIndex(splitAreas,splitAreaColors,i);splitAreas[colorIndex].push(new graphic.Ring({shape:{cx:cx,cy:cy,r0:ticksRadius[i],r:ticksRadius[i+1]}}))}}else for(var axesTicksPoints=zrUtil.map(indicatorAxes,function(indicatorAxis,idx){var ticksCoords=indicatorAxis.getTicksCoords();return zrUtil.map(ticksCoords,function(tickCoord){return radar.coordToPoint(tickCoord,idx)})}),prevPoints=[],i=0;splitNumber>=i;i++){for(var points=[],j=0;j<indicatorAxes.length;j++)points.push(axesTicksPoints[j][i]);if(
// Close
points.push(points[0].slice()),showSplitLine){var colorIndex=getColorIndex(splitLines,splitLineColors,i);splitLines[colorIndex].push(new graphic.Polyline({shape:{points:points}}))}if(showSplitArea&&prevPoints){var colorIndex=getColorIndex(splitAreas,splitAreaColors,i-1);splitAreas[colorIndex].push(new graphic.Polygon({shape:{points:points.concat(prevPoints)}}))}prevPoints=points.slice().reverse()}var lineStyle=lineStyleModel.getLineStyle(),areaStyle=areaStyleModel.getAreaStyle();
// Add splitArea before splitLine
zrUtil.each(splitAreas,function(splitAreas,idx){this.group.add(graphic.mergePath(splitAreas,{style:zrUtil.defaults({stroke:"none",fill:splitAreaColors[idx%splitAreaColors.length]},areaStyle),silent:!0}))},this),zrUtil.each(splitLines,function(splitLines,idx){this.group.add(graphic.mergePath(splitLines,{style:zrUtil.defaults({fill:"none",stroke:splitLineColors[idx%splitLineColors.length]},lineStyle),silent:!0}))},this)}}})},/* 151 */
/***/
function(module,exports,__webpack_require__){"use strict";var SeriesModel=__webpack_require__(27),List=__webpack_require__(94),completeDimensions=__webpack_require__(96),zrUtil=__webpack_require__(3),formatUtil=__webpack_require__(6),RadarSeries=SeriesModel.extend({type:"series.radar",dependencies:["radar"],
// Overwrite
init:function(option){RadarSeries.superApply(this,"init",arguments),
// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this._dataBeforeProcessed}},getInitialData:function(option,ecModel){var data=option.data||[],dimensions=completeDimensions([],data,[],"indicator_"),list=new List(dimensions,this);return list.initData(data),list},formatTooltip:function(dataIndex){var value=this.getRawValue(dataIndex),coordSys=this.coordinateSystem,indicatorAxes=coordSys.getIndicatorAxes();return this._data.getName(dataIndex)+"<br />"+zrUtil.map(indicatorAxes,function(axis,idx){return axis.name+" : "+value[idx]}).join("<br />")},getFormattedLabel:function(dataIndex,status,formatter,indicatorIndex){status=status||"normal";var data=this.getData(),itemModel=data.getItemModel(dataIndex),params=this.getDataParams(dataIndex);
// Get value of specified indicator
return null==formatter&&(formatter=itemModel.get(["label",status,"formatter"])),params.value=params.value[indicatorIndex||0],"function"==typeof formatter?(params.status=status,formatter(params)):"string"==typeof formatter?formatUtil.formatTpl(formatter,params):void 0},defaultOption:{zlevel:0,z:2,coordinateSystem:"radar",legendHoverLink:!0,radarIndex:0,lineStyle:{normal:{width:2,type:"solid"}},label:{normal:{position:"top"}},
// areaStyle: {
// },
// itemStyle: {}
symbol:"emptyCircle",symbolSize:4}});module.exports=RadarSeries},/* 152 */
/***/
function(module,exports,__webpack_require__){function normalizeSymbolSize(symbolSize){return zrUtil.isArray(symbolSize)||(symbolSize=[+symbolSize,+symbolSize]),symbolSize}var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),symbolUtil=__webpack_require__(100);module.exports=__webpack_require__(1).extendChartView({type:"radar",render:function(seriesModel,ecModel,api){function createSymbol(data,idx){var symbolType=data.getItemVisual(idx,"symbol")||"circle",color=data.getItemVisual(idx,"color");if("none"!==symbolType){var symbolPath=symbolUtil.createSymbol(symbolType,-.5,-.5,1,1,color);return symbolPath.attr({style:{strokeNoScale:!0},z2:100,scale:normalizeSymbolSize(data.getItemVisual(idx,"symbolSize"))}),symbolPath}}function updateSymbols(oldPoints,newPoints,symbolGroup,data,idx,isInit){
// Simply rerender all
symbolGroup.removeAll();for(var i=0;i<newPoints.length-1;i++){var symbolPath=createSymbol(data,idx);symbolPath&&(symbolPath.__dimIdx=i,oldPoints[i]?(symbolPath.attr("position",oldPoints[i]),graphic[isInit?"initProps":"updateProps"](symbolPath,{position:newPoints[i]},seriesModel)):symbolPath.attr("position",newPoints[i]),symbolGroup.add(symbolPath))}}function getInitialPoints(points){return zrUtil.map(points,function(pt){return[polar.cx,polar.cy]})}var polar=seriesModel.coordinateSystem,group=this.group,data=seriesModel.getData(),oldData=this._data;data.diff(oldData).add(function(idx){var points=data.getItemLayout(idx);if(points){var polygon=new graphic.Polygon,polyline=new graphic.Polyline,target={shape:{points:points}};polygon.shape.points=getInitialPoints(points),polyline.shape.points=getInitialPoints(points),graphic.initProps(polygon,target,seriesModel),graphic.initProps(polyline,target,seriesModel);var itemGroup=new graphic.Group,symbolGroup=new graphic.Group;itemGroup.add(polyline),itemGroup.add(polygon),itemGroup.add(symbolGroup),updateSymbols(polyline.shape.points,points,symbolGroup,data,idx,!0),data.setItemGraphicEl(idx,itemGroup)}}).update(function(newIdx,oldIdx){var itemGroup=oldData.getItemGraphicEl(oldIdx),polyline=itemGroup.childAt(0),polygon=itemGroup.childAt(1),symbolGroup=itemGroup.childAt(2),target={shape:{points:data.getItemLayout(newIdx)}};target.shape.points&&(updateSymbols(polyline.shape.points,target.shape.points,symbolGroup,data,newIdx,!1),graphic.updateProps(polyline,target,seriesModel),graphic.updateProps(polygon,target,seriesModel),data.setItemGraphicEl(newIdx,itemGroup))}).remove(function(idx){group.remove(oldData.getItemGraphicEl(idx))}).execute(),data.eachItemGraphicEl(function(itemGroup,idx){function onEmphasis(){polygon.attr("ignore",hoverPolygonIgnore)}function onNormal(){polygon.attr("ignore",polygonIgnore)}var itemModel=data.getItemModel(idx),polyline=itemGroup.childAt(0),polygon=itemGroup.childAt(1),symbolGroup=itemGroup.childAt(2),color=data.getItemVisual(idx,"color");group.add(itemGroup),polyline.setStyle(zrUtil.extend(itemModel.getModel("lineStyle.normal").getLineStyle(),{stroke:color})),polyline.hoverStyle=itemModel.getModel("lineStyle.emphasis").getLineStyle();var areaStyleModel=itemModel.getModel("areaStyle.normal"),hoverAreaStyleModel=itemModel.getModel("areaStyle.emphasis"),polygonIgnore=areaStyleModel.isEmpty()&&areaStyleModel.parentModel.isEmpty(),hoverPolygonIgnore=hoverAreaStyleModel.isEmpty()&&hoverAreaStyleModel.parentModel.isEmpty();hoverPolygonIgnore=hoverPolygonIgnore&&polygonIgnore,polygon.ignore=polygonIgnore,polygon.setStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(),{fill:color,opacity:.7})),polygon.hoverStyle=hoverAreaStyleModel.getAreaStyle();var itemStyle=itemModel.getModel("itemStyle.normal").getItemStyle(["color"]),itemHoverStyle=itemModel.getModel("itemStyle.emphasis").getItemStyle(),labelModel=itemModel.getModel("label.normal"),labelHoverModel=itemModel.getModel("label.emphasis");symbolGroup.eachChild(function(symbolPath){symbolPath.setStyle(itemStyle),symbolPath.hoverStyle=zrUtil.clone(itemHoverStyle);var defaultText=data.get(data.dimensions[symbolPath.__dimIdx],idx);graphic.setText(symbolPath.style,labelModel,color),symbolPath.setStyle({text:labelModel.get("show")?zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"normal",null,symbolPath.__dimIdx),defaultText):""}),graphic.setText(symbolPath.hoverStyle,labelHoverModel,color),symbolPath.hoverStyle.text=labelHoverModel.get("show")?zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"emphasis",null,symbolPath.__dimIdx),defaultText):""}),itemGroup.off("mouseover").off("mouseout").off("normal").off("emphasis"),itemGroup.on("emphasis",onEmphasis).on("mouseover",onEmphasis).on("normal",onNormal).on("mouseout",onNormal),graphic.setHoverStyle(itemGroup)}),this._data=data},remove:function(){this.group.removeAll(),this._data=null}})},/* 153 */
/***/
function(module,exports){module.exports=function(ecModel,api){ecModel.eachSeriesByType("radar",function(seriesModel){function pointsConverter(val,idx){points[idx]=points[idx]||[],points[idx][i]=coordSys.dataToPoint(val,i)}var data=seriesModel.getData(),points=[],coordSys=seriesModel.coordinateSystem;if(coordSys){for(var i=0;i<coordSys.getIndicatorAxes().length;i++){var dim=data.dimensions[i];data.each(dim,pointsConverter)}data.each(function(idx){
// Close polygon
points[idx][0]&&points[idx].push(points[idx][0].slice()),data.setItemLayout(idx,points[idx])})}})}},/* 154 */
/***/
function(module,exports,__webpack_require__){
// Backward compat for radar chart in 2
var zrUtil=__webpack_require__(3);module.exports=function(option){var polarOptArr=option.polar;if(polarOptArr){zrUtil.isArray(polarOptArr)||(polarOptArr=[polarOptArr]);var polarNotRadar=[];zrUtil.each(polarOptArr,function(polarOpt,idx){polarOpt.indicator?(polarOpt.type&&!polarOpt.shape&&(polarOpt.shape=polarOpt.type),option.radar=option.radar||[],zrUtil.isArray(option.radar)||(option.radar=[option.radar]),option.radar.push(polarOpt)):polarNotRadar.push(polarOpt)}),option.polar=polarNotRadar}zrUtil.each(option.series,function(seriesOpt){"radar"===seriesOpt.type&&seriesOpt.polarIndex&&(seriesOpt.radarIndex=seriesOpt.polarIndex)})}},/* 155 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(156),__webpack_require__(157),__webpack_require__(161),__webpack_require__(163),echarts.registerLayout(__webpack_require__(173)),echarts.registerVisualCoding("chart",__webpack_require__(174)),echarts.registerProcessor("statistic",__webpack_require__(175)),echarts.registerPreprocessor(__webpack_require__(176)),__webpack_require__(136)("map",[{type:"mapToggleSelect",event:"mapselectchanged",method:"toggleSelected"},{type:"mapSelect",event:"mapselected",method:"select"},{type:"mapUnSelect",event:"mapunselected",method:"unSelect"}])},/* 156 */
/***/
function(module,exports,__webpack_require__){function fillData(dataOpt,geoJson){for(var dataNameMap={},features=geoJson.features,i=0;i<dataOpt.length;i++)dataNameMap[dataOpt[i].name]=dataOpt[i];for(var i=0;i<features.length;i++){var name=features[i].properties.name;dataNameMap[name]||dataOpt.push({value:NaN,name:name})}return dataOpt}var List=__webpack_require__(94),echarts=__webpack_require__(1),SeriesModel=__webpack_require__(27),zrUtil=__webpack_require__(3),completeDimensions=__webpack_require__(96),formatUtil=__webpack_require__(6),encodeHTML=formatUtil.encodeHTML,addCommas=formatUtil.addCommas,dataSelectableMixin=__webpack_require__(134),MapSeries=SeriesModel.extend({type:"series.map",/**
	         * Only first map series of same mapType will drawMap
	         * @type {boolean}
	         */
needsDrawMap:!1,/**
	         * Group of all map series with same mapType
	         * @type {boolean}
	         */
seriesGroup:[],init:function(option){option=this._fillOption(option),this.option=option,MapSeries.superApply(this,"init",arguments),this.updateSelectedMap()},getInitialData:function(option){var dimensions=completeDimensions(["value"],option.data||[]),list=new List(dimensions,this);return list.initData(option.data),list},mergeOption:function(newOption){newOption=this._fillOption(newOption),MapSeries.superCall(this,"mergeOption",newOption),this.updateSelectedMap()},_fillOption:function(option){
// Shallow clone
option=zrUtil.extend({},option);var map=echarts.getMap(option.map),geoJson=map&&map.geoJson;return geoJson&&option.data&&(option.data=fillData(option.data,geoJson)),option},/**
	         * @param {number} zoom
	         */
setRoamZoom:function(zoom){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.zoom=zoom)},/**
	         * @param {number} x
	         * @param {number} y
	         */
setRoamPan:function(x,y){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.x=x,roamDetail.y=y)},getRawValue:function(dataIndex){
// Use value stored in data instead because it is calculated from multiple series
// FIXME Provide all value of multiple series ?
return this._data.get("value",dataIndex)},/**
	         * Map tooltip formatter
	         *
	         * @param {number} dataIndex
	         */
formatTooltip:function(dataIndex){for(var data=this._data,formattedValue=addCommas(this.getRawValue(dataIndex)),name=data.getName(dataIndex),seriesGroup=this.seriesGroup,seriesNames=[],i=0;i<seriesGroup.length;i++)isNaN(seriesGroup[i].getRawValue(dataIndex))||seriesNames.push(encodeHTML(seriesGroup[i].name));return seriesNames.join(", ")+"<br />"+name+" : "+formattedValue},defaultOption:{
// 一级层叠
zlevel:0,
// 二级层叠
z:2,coordinateSystem:"geo",
// 各省的 map 暂时都用中文
map:"china",
// 'center' | 'left' | 'right' | 'x%' | {number}
left:"center",
// 'center' | 'top' | 'bottom' | 'x%' | {number}
top:"center",
// right
// bottom
// width:
// height   // 自适应
// 数值合并方式，默认加和，可选为：
// 'sum' | 'average' | 'max' | 'min'
// mapValueCalculation: 'sum',
// 地图数值计算结果小数精度
// mapValuePrecision: 0,
// 显示图例颜色标识（系列标识的小圆点），图例开启时有效
showLegendSymbol:!0,
// 选择模式，默认关闭，可选single，multiple
// selectedMode: false,
dataRangeHoverLink:!0,
// 是否开启缩放及漫游模式
// roam: false,
// 在 roam 开启的时候使用
roamDetail:{x:0,y:0,zoom:1},scaleLimit:null,label:{normal:{show:!1,textStyle:{color:"#000"}},emphasis:{show:!1,textStyle:{color:"#000"}}},
// scaleLimit: null,
itemStyle:{normal:{
// color: 各异,
borderWidth:.5,borderColor:"#444",areaColor:"#eee"},
// 也是选中样式
emphasis:{areaColor:"rgba(255,215, 0, 0.8)"}}}});zrUtil.mixin(MapSeries,dataSelectableMixin),module.exports=MapSeries},/* 157 */
/***/
function(module,exports,__webpack_require__){
// var zrUtil = require('zrender/lib/core/util');
var graphic=__webpack_require__(42),MapDraw=__webpack_require__(158);__webpack_require__(1).extendChartView({type:"map",render:function(mapModel,ecModel,api,payload){
// Not render if it is an toggleSelect action from self
if(!payload||"mapToggleSelect"!==payload.type||payload.from!==this.uid){var group=this.group;
// Not update map if it is an roam action from self
if(group.removeAll(),payload&&"geoRoam"===payload.type&&"series"===payload.component&&payload.name===mapModel.name){var mapDraw=this._mapDraw;mapDraw&&group.add(mapDraw.group)}else if(mapModel.needsDrawMap){var mapDraw=this._mapDraw||new MapDraw(api,!0);group.add(mapDraw.group),mapDraw.draw(mapModel,ecModel,api,this),this._mapDraw=mapDraw}else
// Remove drawed map
this._mapDraw&&this._mapDraw.remove(),this._mapDraw=null;mapModel.get("showLegendSymbol")&&ecModel.getComponent("legend")&&this._renderSymbols(mapModel,ecModel,api)}},remove:function(){this._mapDraw&&this._mapDraw.remove(),this._mapDraw=null,this.group.removeAll()},_renderSymbols:function(mapModel,ecModel,api){var data=mapModel.getData(),group=this.group;data.each("value",function(value,idx){if(!isNaN(value)){var layout=data.getItemLayout(idx);if(layout&&layout.point){var point=layout.point,offset=layout.offset,circle=new graphic.Circle({style:{fill:data.getVisual("color")},shape:{cx:point[0]+9*offset,cy:point[1],r:3},silent:!0,z2:10});
// First data on the same region
if(!offset){var labelText=data.getName(idx),itemModel=data.getItemModel(idx),labelModel=itemModel.getModel("label.normal"),hoverLabelModel=itemModel.getModel("label.emphasis"),textStyleModel=labelModel.getModel("textStyle"),hoverTextStyleModel=hoverLabelModel.getModel("textStyle"),polygonGroups=data.getItemGraphicEl(idx);circle.setStyle({textPosition:"bottom"});var onEmphasis=function(){circle.setStyle({text:hoverLabelModel.get("show")?labelText:"",textFill:hoverTextStyleModel.getTextColor(),textFont:hoverTextStyleModel.getFont()})},onNormal=function(){circle.setStyle({text:labelModel.get("show")?labelText:"",textFill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()})};polygonGroups.on("mouseover",onEmphasis).on("mouseout",onNormal).on("emphasis",onEmphasis).on("normal",onNormal),onNormal()}group.add(circle)}}})}})},/* 158 */
/***/
function(module,exports,__webpack_require__){function getFixedItemStyle(model,scale){var itemStyle=model.getItemStyle(),areaColor=model.get("areaColor");return areaColor&&(itemStyle.fill=areaColor),itemStyle}function updateMapSelectHandler(mapOrGeoModel,data,group,api,fromView){group.off("click"),mapOrGeoModel.get("selectedMode")&&group.on("click",function(e){var dataIndex=e.target.dataIndex;if(null!=dataIndex){var name=data.getName(dataIndex);api.dispatchAction({type:"mapToggleSelect",seriesIndex:mapOrGeoModel.seriesIndex,name:name,from:fromView.uid}),updateMapSelected(mapOrGeoModel,data,api)}})}function updateMapSelected(mapOrGeoModel,data){data.eachItemGraphicEl(function(el,idx){var name=data.getName(idx);el.trigger(mapOrGeoModel.isSelected(name)?"emphasis":"normal")})}/**
	     * @alias module:echarts/component/helper/MapDraw
	     * @param {module:echarts/ExtensionAPI} api
	     * @param {boolean} updateGroup
	     */
function MapDraw(api,updateGroup){var group=new graphic.Group;/**
	         * @type {module:echarts/component/helper/RoamController}
	         * @private
	         */
this._controller=new RoamController(api.getZr(),updateGroup?group:null,null),/**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
this.group=group,/**
	         * @type {boolean}
	         * @private
	         */
this._updateGroup=updateGroup}/**
	 * @module echarts/component/helper/MapDraw
	 */
var RoamController=__webpack_require__(159),graphic=__webpack_require__(42),zrUtil=__webpack_require__(3);MapDraw.prototype={constructor:MapDraw,draw:function(mapOrGeoModel,ecModel,api,fromView){
// geoModel has no data
var data=mapOrGeoModel.getData&&mapOrGeoModel.getData(),geo=mapOrGeoModel.coordinateSystem,group=this.group;group.removeAll();var scale=geo.scale;group.position=geo.position.slice(),group.scale=scale.slice();var itemStyleModel,hoverItemStyleModel,itemStyle,hoverItemStyle,labelModel,hoverLabelModel,itemStyleAccessPath=["itemStyle","normal"],hoverItemStyleAccessPath=["itemStyle","emphasis"],labelAccessPath=["label","normal"],hoverLabelAccessPath=["label","emphasis"];data||(itemStyleModel=mapOrGeoModel.getModel(itemStyleAccessPath),hoverItemStyleModel=mapOrGeoModel.getModel(hoverItemStyleAccessPath),itemStyle=getFixedItemStyle(itemStyleModel,scale),hoverItemStyle=getFixedItemStyle(hoverItemStyleModel,scale),labelModel=mapOrGeoModel.getModel(labelAccessPath),hoverLabelModel=mapOrGeoModel.getModel(hoverLabelAccessPath)),zrUtil.each(geo.regions,function(region){var dataIdx,regionGroup=new graphic.Group;
// Use the itemStyle in data if has data
if(data){
// FIXME If dataIdx < 0
dataIdx=data.indexOfName(region.name);var itemModel=data.getItemModel(dataIdx),visualColor=data.getItemVisual(dataIdx,"color",!0);itemStyleModel=itemModel.getModel(itemStyleAccessPath),hoverItemStyleModel=itemModel.getModel(hoverItemStyleAccessPath),itemStyle=getFixedItemStyle(itemStyleModel,scale),hoverItemStyle=getFixedItemStyle(hoverItemStyleModel,scale),labelModel=itemModel.getModel(labelAccessPath),hoverLabelModel=itemModel.getModel(hoverLabelAccessPath),visualColor&&(itemStyle.fill=visualColor)}var textStyleModel=labelModel.getModel("textStyle"),hoverTextStyleModel=hoverLabelModel.getModel("textStyle");zrUtil.each(region.contours,function(contour){var polygon=new graphic.Polygon({shape:{points:contour},style:{strokeNoScale:!0},culling:!0});polygon.setStyle(itemStyle),regionGroup.add(polygon)});
// Label
var showLabel=labelModel.get("show"),hoverShowLabel=hoverLabelModel.get("show"),isDataNaN=data&&isNaN(data.get("value",dataIdx)),itemLayout=data&&data.getItemLayout(dataIdx);
// In the following cases label will be drawn
// 1. In map series and data value is NaN
// 2. In geo component
// 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout
if(!data||isDataNaN&&(showLabel||hoverShowLabel)||itemLayout&&itemLayout.showLabel){var query=data?dataIdx:region.name,formattedStr=mapOrGeoModel.getFormattedLabel(query,"normal"),hoverFormattedStr=mapOrGeoModel.getFormattedLabel(query,"emphasis"),text=new graphic.Text({style:{text:showLabel?formattedStr||region.name:"",fill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont(),textAlign:"center",textVerticalAlign:"middle"},hoverStyle:{text:hoverShowLabel?hoverFormattedStr||region.name:"",fill:hoverTextStyleModel.getTextColor(),textFont:hoverTextStyleModel.getFont()},position:region.center.slice(),scale:[1/scale[0],1/scale[1]],z2:10,silent:!0});regionGroup.add(text)}
// setItemGraphicEl, setHoverStyle after all polygons and labels
// are added to the rigionGroup
data&&data.setItemGraphicEl(dataIdx,regionGroup),graphic.setHoverStyle(regionGroup,hoverItemStyle),group.add(regionGroup)}),this._updateController(mapOrGeoModel,ecModel,api),data&&updateMapSelectHandler(mapOrGeoModel,data,group,api,fromView),data&&updateMapSelected(mapOrGeoModel,data)},remove:function(){this.group.removeAll(),this._controller.dispose()},_updateController:function(mapOrGeoModel,ecModel,api){var geo=mapOrGeoModel.coordinateSystem,controller=this._controller;controller.zoomLimit=mapOrGeoModel.get("scaleLimit"),
// Update zoom from model
controller.zoom=mapOrGeoModel.get("roamDetail.zoom"),
// roamType is will be set default true if it is null
controller.enable(mapOrGeoModel.get("roam")||!1);
// FIXME mainType, subType 作为 component 的属性？
var mainType=mapOrGeoModel.type.split(".")[0];controller.off("pan").on("pan",function(dx,dy){api.dispatchAction({type:"geoRoam",component:mainType,name:mapOrGeoModel.name,dx:dx,dy:dy})}),controller.off("zoom").on("zoom",function(zoom,mouseX,mouseY){if(api.dispatchAction({type:"geoRoam",component:mainType,name:mapOrGeoModel.name,zoom:zoom,originX:mouseX,originY:mouseY}),this._updateGroup){var group=this.group,scale=group.scale;group.traverse(function(el){"text"===el.type&&el.attr("scale",[1/scale[0],1/scale[1]])})}},this),controller.rect=geo.getViewRect()}},module.exports=MapDraw},/* 159 */
/***/
function(module,exports,__webpack_require__){function mousedown(e){if(!e.target||!e.target.draggable){var x=e.offsetX,y=e.offsetY,rect=this.rect;rect&&rect.contain(x,y)&&(this._x=x,this._y=y,this._dragging=!0)}}function mousemove(e){if(this._dragging&&(eventTool.stop(e.event),"pinch"!==e.gestureEvent)){if(interactionMutex.isTaken("globalPan",this._zr))return;var x=e.offsetX,y=e.offsetY,dx=x-this._x,dy=y-this._y;this._x=x,this._y=y;var target=this.target;if(target){var pos=target.position;pos[0]+=dx,pos[1]+=dy,target.dirty()}eventTool.stop(e.event),this.trigger("pan",dx,dy)}}function mouseup(e){this._dragging=!1}function mousewheel(e){eventTool.stop(e.event);
// Convenience:
// Mac and VM Windows on Mac: scroll up: zoom out.
// Windows: scroll up: zoom in.
var zoomDelta=e.wheelDelta>0?1.1:1/1.1;zoom.call(this,e,zoomDelta,e.offsetX,e.offsetY)}function pinch(e){if(!interactionMutex.isTaken("globalPan",this._zr)){eventTool.stop(e.event);var zoomDelta=e.pinchScale>1?1.1:1/1.1;zoom.call(this,e,zoomDelta,e.pinchX,e.pinchY)}}function zoom(e,zoomDelta,zoomX,zoomY){var rect=this.rect;if(rect&&rect.contain(zoomX,zoomY)){var target=this.target,zoomLimit=this.zoomLimit;if(target){var pos=target.position,scale=target.scale,newZoom=this.zoom=this.zoom||1;newZoom*=zoomDelta,zoomLimit&&(newZoom=Math.max(Math.min(zoomLimit.max,newZoom),zoomLimit.min));var zoomScale=newZoom/this.zoom;this.zoom=newZoom,
// Keep the mouse center when scaling
pos[0]-=(zoomX-pos[0])*(zoomScale-1),pos[1]-=(zoomY-pos[1])*(zoomScale-1),scale[0]*=zoomScale,scale[1]*=zoomScale,target.dirty()}this.trigger("zoom",zoomDelta,zoomX,zoomY)}}/**
	     * @alias module:echarts/component/helper/RoamController
	     * @constructor
	     * @mixin {module:zrender/mixin/Eventful}
	     *
	     * @param {module:zrender/zrender~ZRender} zr
	     * @param {module:zrender/Element} target
	     * @param {module:zrender/core/BoundingRect} rect
	     */
function RoamController(zr,target,rect){/**
	         * @type {module:zrender/Element}
	         */
this.target=target,/**
	         * @type {module:zrender/core/BoundingRect}
	         */
this.rect=rect,/**
	         * { min: 1, max: 2 }
	         * @type {Object}
	         */
this.zoomLimit,/**
	         * @type {number}
	         */
this.zoom,/**
	         * @type {module:zrender}
	         */
this._zr=zr;
// Avoid two roamController bind the same handler
var bind=zrUtil.bind,mousedownHandler=bind(mousedown,this),mousemoveHandler=bind(mousemove,this),mouseupHandler=bind(mouseup,this),mousewheelHandler=bind(mousewheel,this),pinchHandler=bind(pinch,this);Eventful.call(this),/**
	         * Notice: only enable needed types. For example, if 'zoom'
	         * is not needed, 'zoom' should not be enabled, otherwise
	         * default mousewheel behaviour (scroll page) will be disabled.
	         *
	         * @param  {boolean|string} [controlType=true] Specify the control type,
	         *                          which can be null/undefined or true/false
	         *                          or 'pan/move' or 'zoom'/'scale'
	         */
this.enable=function(controlType){
// Disable previous first
this.disable(),null==controlType&&(controlType=!0),controlType!==!0&&"move"!==controlType&&"pan"!==controlType||(zr.on("mousedown",mousedownHandler),zr.on("mousemove",mousemoveHandler),zr.on("mouseup",mouseupHandler)),controlType!==!0&&"scale"!==controlType&&"zoom"!==controlType||(zr.on("mousewheel",mousewheelHandler),zr.on("pinch",pinchHandler))},this.disable=function(){zr.off("mousedown",mousedownHandler),zr.off("mousemove",mousemoveHandler),zr.off("mouseup",mouseupHandler),zr.off("mousewheel",mousewheelHandler),zr.off("pinch",pinchHandler)},this.dispose=this.disable,this.isDragging=function(){return this._dragging},this.isPinching=function(){return this._pinching}}/**
	 * @module echarts/component/helper/RoamController
	 */
var Eventful=__webpack_require__(32),zrUtil=__webpack_require__(3),eventTool=__webpack_require__(80),interactionMutex=__webpack_require__(160);zrUtil.mixin(RoamController,Eventful),module.exports=RoamController},/* 160 */
/***/
function(module,exports){function getStore(zr){return zr[ATTR]||(zr[ATTR]={})}var ATTR="\x00_ec_interaction_mutex",interactionMutex={take:function(key,zr){getStore(zr)[key]=!0},release:function(key,zr){getStore(zr)[key]=!1},isTaken:function(key,zr){return!!getStore(zr)[key]}};module.exports=interactionMutex},/* 161 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),roamHelper=__webpack_require__(162),echarts=__webpack_require__(1),actionInfo={type:"geoRoam",event:"geoRoam",update:"updateLayout"};/**
	     * @payload
	     * @property {string} [component=series]
	     * @property {string} name Component name
	     * @property {number} [dx]
	     * @property {number} [dy]
	     * @property {number} [zoom]
	     * @property {number} [originX]
	     * @property {number} [originY]
	     */
echarts.registerAction(actionInfo,function(payload,ecModel){var componentType=payload.component||"series";ecModel.eachComponent(componentType,function(componentModel){if(componentModel.name===payload.name){var geo=componentModel.coordinateSystem;if("geo"!==geo.type)return;var roamDetailModel=componentModel.getModel("roamDetail"),res=roamHelper.calcPanAndZoom(roamDetailModel,payload,componentModel.get("scaleLimit"));componentModel.setRoamPan&&componentModel.setRoamPan(res.x,res.y),componentModel.setRoamZoom&&componentModel.setRoamZoom(res.zoom),geo&&geo.setPan(res.x,res.y),geo&&geo.setZoom(res.zoom),
// All map series with same `map` use the same geo coordinate system
// So the roamDetail must be in sync. Include the series not selected by legend
"series"===componentType&&zrUtil.each(componentModel.seriesGroup,function(seriesModel){seriesModel.setRoamPan(res.x,res.y),seriesModel.setRoamZoom(res.zoom)})}})})},/* 162 */
/***/
function(module,exports){var roamHelper={};/**
	     * Calculate pan and zoom which from roamDetail model
	     * @param {module:echarts/model/Model} roamDetailModel
	     * @param {Object} payload
	     * @param {Object} [zoomLimit]
	     */
roamHelper.calcPanAndZoom=function(roamDetailModel,payload,zoomLimit){var dx=payload.dx,dy=payload.dy,zoom=payload.zoom,panX=roamDetailModel.get("x")||0,panY=roamDetailModel.get("y")||0,previousZoom=roamDetailModel.get("zoom")||1;if(null!=dx&&null!=dy&&(panX+=dx,panY+=dy),null!=zoom){zoomLimit&&(zoom=Math.max(Math.min(previousZoom*zoom,zoomLimit.max),zoomLimit.min)/previousZoom);var fixX=(payload.originX-panX)*(zoom-1),fixY=(payload.originY-panY)*(zoom-1);panX-=fixX,panY-=fixY}return{x:panX,y:panY,zoom:(zoom||1)*previousZoom}},module.exports=roamHelper},/* 163 */
/***/
function(module,exports,__webpack_require__){/**
	     * Resize method bound to the geo
	     * @param {module:echarts/coord/geo/GeoModel|module:echarts/chart/map/MapModel} geoModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
function resizeGeo(geoModel,api){var rect=this.getBoundingRect(),boxLayoutOption=geoModel.getBoxLayoutParams();
// 0.75 rate
boxLayoutOption.aspect=rect.width/rect.height*.75;var viewRect=layout.getLayoutRect(boxLayoutOption,{width:api.getWidth(),height:api.getHeight()});this.setViewRect(viewRect.x,viewRect.y,viewRect.width,viewRect.height);var roamDetailModel=geoModel.getModel("roamDetail"),panX=roamDetailModel.get("x")||0,panY=roamDetailModel.get("y")||0,zoom=roamDetailModel.get("zoom")||1;this.setPan(panX,panY),this.setZoom(zoom)}/**
	     * @param {module:echarts/coord/Geo} geo
	     * @param {module:echarts/model/Model} model
	     * @inner
	     */
function setGeoCoords(geo,model){zrUtil.each(model.get("geoCoord"),function(geoCoord,name){geo.addGeoCoord(name,geoCoord)})}function mapNotExistsError(name){console.error("Map "+name+" not exists")}__webpack_require__(164);var Geo=__webpack_require__(165),layout=__webpack_require__(21),zrUtil=__webpack_require__(3),mapDataStores={},geoCreator={
// For deciding which dimensions to use when creating list data
dimensions:Geo.prototype.dimensions,create:function(ecModel,api){var geoList=[];
// FIXME Create each time may be slow
ecModel.eachComponent("geo",function(geoModel,idx){var name=geoModel.get("map"),mapData=mapDataStores[name];mapData||mapNotExistsError(name);var geo=new Geo(name+idx,name,mapData&&mapData.geoJson,mapData&&mapData.specialAreas,geoModel.get("nameMap"));geo.zoomLimit=geoModel.get("scaleLimit"),geoList.push(geo),setGeoCoords(geo,geoModel),geoModel.coordinateSystem=geo,geo.model=geoModel,
// Inject resize method
geo.resize=resizeGeo,geo.resize(geoModel,api)}),ecModel.eachSeries(function(seriesModel){var coordSys=seriesModel.get("coordinateSystem");if("geo"===coordSys){var geoIndex=seriesModel.get("geoIndex")||0;seriesModel.coordinateSystem=geoList[geoIndex]}});
// If has map series
var mapModelGroupBySeries={};return ecModel.eachSeriesByType("map",function(seriesModel){var mapType=seriesModel.get("map");mapModelGroupBySeries[mapType]=mapModelGroupBySeries[mapType]||[],mapModelGroupBySeries[mapType].push(seriesModel)}),zrUtil.each(mapModelGroupBySeries,function(mapSeries,mapType){var mapData=mapDataStores[mapType];mapData||mapNotExistsError(name);var nameMapList=zrUtil.map(mapSeries,function(singleMapSeries){return singleMapSeries.get("nameMap")}),geo=new Geo(mapType,mapType,mapData&&mapData.geoJson,mapData&&mapData.specialAreas,zrUtil.mergeAll(nameMapList));geo.zoomLimit=zrUtil.retrieve.apply(null,zrUtil.map(mapSeries,function(singleMapSeries){return singleMapSeries.get("scaleLimit")})),geoList.push(geo),
// Inject resize method
geo.resize=resizeGeo,geo.resize(mapSeries[0],api),zrUtil.each(mapSeries,function(singleMapSeries){singleMapSeries.coordinateSystem=geo,setGeoCoords(geo,singleMapSeries)})}),geoList},/**
	         * @param {string} mapName
	         * @param {Object|string} geoJson
	         * @param {Object} [specialAreas]
	         *
	         * @example
	         *     $.get('USA.json', function (geoJson) {
	         *         echarts.registerMap('USA', geoJson);
	         *         // Or
	         *         echarts.registerMap('USA', {
	         *             geoJson: geoJson,
	         *             specialAreas: {}
	         *         })
	         *     });
	         */
registerMap:function(mapName,geoJson,specialAreas){geoJson.geoJson&&!geoJson.features&&(specialAreas=geoJson.specialAreas,geoJson=geoJson.geoJson),"string"==typeof geoJson&&(geoJson="undefined"!=typeof JSON&&JSON.parse?JSON.parse(geoJson):new Function("return ("+geoJson+");")()),mapDataStores[mapName]={geoJson:geoJson,specialAreas:specialAreas}},/**
	         * @param {string} mapName
	         * @return {Object}
	         */
getMap:function(mapName){return mapDataStores[mapName]}},echarts=__webpack_require__(1);echarts.registerMap=geoCreator.registerMap,echarts.getMap=geoCreator.getMap,
// TODO
echarts.loadMap=function(){},echarts.registerCoordinateSystem("geo",geoCreator)},/* 164 */
/***/
function(module,exports,__webpack_require__){"use strict";var modelUtil=__webpack_require__(5),ComponentModel=__webpack_require__(19);ComponentModel.extend({type:"geo",/**
	         * @type {module:echarts/coord/geo/Geo}
	         */
coordinateSystem:null,init:function(option){ComponentModel.prototype.init.apply(this,arguments),
// Default label emphasis `position` and `show`
modelUtil.defaultEmphasis(option.label,["position","show","textStyle","distance","formatter"])},defaultOption:{zlevel:0,z:0,show:!0,left:"center",top:"center",
// 自适应
// width:,
// height:,
// right
// bottom
// Map type
map:"",
// 在 roam 开启的时候使用
roamDetail:{x:0,y:0,zoom:1},scaleLimit:null,label:{normal:{show:!1,textStyle:{color:"#000"}},emphasis:{show:!0,textStyle:{color:"rgb(100,0,0)"}}},itemStyle:{normal:{
// color: 各异,
borderWidth:.5,borderColor:"#444",color:"#eee"},emphasis:{// 也是选中样式
color:"rgba(255,215,0,0.8)"}}},/**
	         * Format label
	         * @param {string} name Region name
	         * @param {string} [status='normal'] 'normal' or 'emphasis'
	         * @return {string}
	         */
getFormattedLabel:function(name,status){var formatter=this.get("label."+status+".formatter"),params={name:name};return"function"==typeof formatter?(params.status=status,formatter(params)):"string"==typeof formatter?formatter.replace("{a}",params.seriesName):void 0},setRoamZoom:function(zoom){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.zoom=zoom)},setRoamPan:function(x,y){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.x=x,roamDetail.y=y)}})},/* 165 */
/***/
function(module,exports,__webpack_require__){/**
	     * [Geo description]
	     * @param {string} name Geo name
	     * @param {string} map Map type
	     * @param {Object} geoJson
	     * @param {Object} [specialAreas]
	     *        Specify the positioned areas by left, top, width, height
	     * @param {Object.<string, string>} [nameMap]
	     *        Specify name alias
	     */
function Geo(name,map,geoJson,specialAreas,nameMap){View.call(this,name),/**
	         * Map type
	         * @type {string}
	         */
this.map=map,this._nameCoordMap={},this.loadGeoJson(geoJson,specialAreas,nameMap)}var parseGeoJson=__webpack_require__(166),zrUtil=__webpack_require__(3),BoundingRect=__webpack_require__(15),View=__webpack_require__(169),geoFixFuncs=[__webpack_require__(170),__webpack_require__(171),__webpack_require__(172)];Geo.prototype={constructor:Geo,type:"geo",/**
	         * @param {Array.<string>}
	         * @readOnly
	         */
dimensions:["lng","lat"],/**
	         * @param {Object} geoJson
	         * @param {Object} [specialAreas]
	         *        Specify the positioned areas by left, top, width, height
	         * @param {Object.<string, string>} [nameMap]
	         *        Specify name alias
	         */
loadGeoJson:function(geoJson,specialAreas,nameMap){
// https://jsperf.com/try-catch-performance-overhead
try{this.regions=geoJson?parseGeoJson(geoJson):[]}catch(e){throw"Invalid geoJson format\n"+e}specialAreas=specialAreas||{},nameMap=nameMap||{};for(var regions=this.regions,regionsMap={},i=0;i<regions.length;i++){var regionName=regions[i].name;
// Try use the alias in nameMap
regionName=nameMap[regionName]||regionName,regions[i].name=regionName,regionsMap[regionName]=regions[i],
// Add geoJson
this.addGeoCoord(regionName,regions[i].center);
// Some area like Alaska in USA map needs to be tansformed
// to look better
var specialArea=specialAreas[regionName];specialArea&&regions[i].transformTo(specialArea.left,specialArea.top,specialArea.width,specialArea.height)}this._regionsMap=regionsMap,this._rect=null,zrUtil.each(geoFixFuncs,function(fixFunc){fixFunc(this)},this)},
// Overwrite
transformTo:function(x,y,width,height){var rect=this.getBoundingRect();rect=rect.clone(),rect.y=-rect.y-rect.height;var viewTransform=this._viewTransform;viewTransform.transform=rect.calculateTransform(new BoundingRect(x,y,width,height)),viewTransform.decomposeTransform();var scale=viewTransform.scale;scale[1]=-scale[1],viewTransform.updateTransform(),this._updateTransform()},/**
	         * @param {string} name
	         * @return {module:echarts/coord/geo/Region}
	         */
getRegion:function(name){return this._regionsMap[name]},/**
	         * Add geoCoord for indexing by name
	         * @param {string} name
	         * @param {Array.<number>} geoCoord
	         */
addGeoCoord:function(name,geoCoord){this._nameCoordMap[name]=geoCoord},/**
	         * Get geoCoord by name
	         * @param {string} name
	         * @return {Array.<number>}
	         */
getGeoCoord:function(name){return this._nameCoordMap[name]},
// Overwrite
getBoundingRect:function(){if(this._rect)return this._rect;for(var rect,regions=this.regions,i=0;i<regions.length;i++){var regionRect=regions[i].getBoundingRect();rect=rect||regionRect.clone(),rect.union(regionRect)}
// FIXME Always return new ?
return this._rect=rect||new BoundingRect(0,0,0,0)},/**
	         * Convert series data to a list of points
	         * @param {module:echarts/data/List} data
	         * @param {boolean} stack
	         * @return {Array}
	         *  Return list of points. For example:
	         *  `[[10, 10], [20, 20], [30, 30]]`
	         */
dataToPoints:function(data){var item=[];return data.mapArray(["lng","lat"],function(lon,lat){return item[0]=lon,item[1]=lat,this.dataToPoint(item)},this)},
// Overwrite
/**
	         * @param {string|Array.<number>} data
	         * @return {Array.<number>}
	         */
dataToPoint:function(data){
// Map area name to geoCoord
return"string"==typeof data&&(data=this.getGeoCoord(data)),data?View.prototype.dataToPoint.call(this,data):void 0}},zrUtil.mixin(Geo,View),module.exports=Geo},/* 166 */
/***/
function(module,exports,__webpack_require__){function decode(json){if(!json.UTF8Encoding)return json;for(var features=json.features,f=0;f<features.length;f++)for(var feature=features[f],geometry=feature.geometry,coordinates=geometry.coordinates,encodeOffsets=geometry.encodeOffsets,c=0;c<coordinates.length;c++){var coordinate=coordinates[c];if("Polygon"===geometry.type)coordinates[c]=decodePolygon(coordinate,encodeOffsets[c]);else if("MultiPolygon"===geometry.type)for(var c2=0;c2<coordinate.length;c2++){var polygon=coordinate[c2];coordinate[c2]=decodePolygon(polygon,encodeOffsets[c][c2])}}
// Has been decoded
return json.UTF8Encoding=!1,json}function decodePolygon(coordinate,encodeOffsets){for(var result=[],prevX=encodeOffsets[0],prevY=encodeOffsets[1],i=0;i<coordinate.length;i+=2){var x=coordinate.charCodeAt(i)-64,y=coordinate.charCodeAt(i+1)-64;
// ZigZag decoding
x=x>>1^-(1&x),y=y>>1^-(1&y),
// Delta deocding
x+=prevX,y+=prevY,prevX=x,prevY=y,
// Dequantize
result.push([x/1024,y/1024])}return result}/**
	     * @inner
	     */
function flattern2D(array){for(var ret=[],i=0;i<array.length;i++)for(var k=0;k<array[i].length;k++)ret.push(array[i][k]);return ret}/**
	 * Parse and decode geo json
	 * @module echarts/coord/geo/parseGeoJson
	 */
var zrUtil=__webpack_require__(3),Region=__webpack_require__(167);/**
	     * @alias module:echarts/coord/geo/parseGeoJson
	     * @param {Object} geoJson
	     * @return {module:zrender/container/Group}
	     */
module.exports=function(geoJson){return decode(geoJson),zrUtil.map(zrUtil.filter(geoJson.features,function(featureObj){
// Output of mapshaper may have geometry null
return featureObj.geometry&&featureObj.properties}),function(featureObj){var properties=featureObj.properties,geometry=featureObj.geometry,coordinates=geometry.coordinates;return"MultiPolygon"===geometry.type&&(coordinates=flattern2D(coordinates)),new Region(properties.name,coordinates,properties.cp)})}},/* 167 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {string} name
	     * @param {Array} contours
	     * @param {Array.<number>} cp
	     */
function Region(name,contours,cp){if(/**
	         * @type {string}
	         * @readOnly
	         */
this.name=name,/**
	         * @type {Array.<Array>}
	         * @readOnly
	         */
this.contours=contours,cp)cp=[cp[0],cp[1]];else{var rect=this.getBoundingRect();cp=[rect.x+rect.width/2,rect.y+rect.height/2]}/**
	         * @type {Array.<number>}
	         */
this.center=cp}/**
	 * @module echarts/coord/geo/Region
	 */
var polygonContain=__webpack_require__(168),BoundingRect=__webpack_require__(15),bbox=__webpack_require__(50),vec2=__webpack_require__(16);Region.prototype={constructor:Region,/**
	         * @return {module:zrender/core/BoundingRect}
	         */
getBoundingRect:function(){var rect=this._rect;if(rect)return rect;for(var MAX_NUMBER=Number.MAX_VALUE,min=[MAX_NUMBER,MAX_NUMBER],max=[-MAX_NUMBER,-MAX_NUMBER],min2=[],max2=[],contours=this.contours,i=0;i<contours.length;i++)bbox.fromPoints(contours[i],min2,max2),vec2.min(min,min,min2),vec2.max(max,max,max2);
// No data
return 0===i&&(min[0]=min[1]=max[0]=max[1]=0),this._rect=new BoundingRect(min[0],min[1],max[0]-min[0],max[1]-min[1])},/**
	         * @param {<Array.<number>} coord
	         * @return {boolean}
	         */
contain:function(coord){var rect=this.getBoundingRect(),contours=this.contours;if(rect.contain(coord[0],coord[1]))for(var i=0,len=contours.length;len>i;i++)if(polygonContain.contain(contours[i],coord[0],coord[1]))return!0;return!1},transformTo:function(x,y,width,height){var rect=this.getBoundingRect(),aspect=rect.width/rect.height;width?height||(height=width/aspect):width=aspect*height;for(var target=new BoundingRect(x,y,width,height),transform=rect.calculateTransform(target),contours=this.contours,i=0;i<contours.length;i++)for(var p=0;p<contours[i].length;p++)vec2.applyTransform(contours[i][p],contours[i][p],transform);rect=this._rect,rect.copy(target),this.center=[rect.x+rect.width/2,rect.y+rect.height/2]}},module.exports=Region},/* 168 */
/***/
function(module,exports,__webpack_require__){function isAroundEqual(a,b){return Math.abs(a-b)<EPSILON}function contain(points,x,y){var w=0,p=points[0];if(!p)return!1;for(var i=1;i<points.length;i++){var p2=points[i];w+=windingLine(p[0],p[1],p2[0],p2[1],x,y),p=p2}
// Close polygon
var p0=points[0];return isAroundEqual(p[0],p0[0])&&isAroundEqual(p[1],p0[1])||(w+=windingLine(p[0],p[1],p0[0],p0[1],x,y)),0!==w}var windingLine=__webpack_require__(57),EPSILON=1e-8;module.exports={contain:contain}},/* 169 */
/***/
function(module,exports,__webpack_require__){
// Dummy transform node
function TransformDummy(){Transformable.call(this)}function View(name){/**
	         * @type {string}
	         */
this.name=name,/**
	         * @type {Array.<number>}
	         */
this.zoomLimit,Transformable.call(this),this._roamTransform=new TransformDummy,this._viewTransform=new TransformDummy}/**
	 * Simple view coordinate system
	 * Mapping given x, y to transformd view x, y
	 */
var vector=__webpack_require__(16),matrix=__webpack_require__(17),Transformable=__webpack_require__(33),zrUtil=__webpack_require__(3),BoundingRect=__webpack_require__(15),v2ApplyTransform=vector.applyTransform;zrUtil.mixin(TransformDummy,Transformable),View.prototype={constructor:View,type:"view",/**
	         * @param {Array.<string>}
	         * @readOnly
	         */
dimensions:["x","y"],/**
	         * Set bounding rect
	         * @param {number} x
	         * @param {number} y
	         * @param {number} width
	         * @param {number} height
	         */
// PENDING to getRect
setBoundingRect:function(x,y,width,height){return this._rect=new BoundingRect(x,y,width,height),this._rect},/**
	         * @return {module:zrender/core/BoundingRect}
	         */
// PENDING to getRect
getBoundingRect:function(){return this._rect},/**
	         * @param {number} x
	         * @param {number} y
	         * @param {number} width
	         * @param {number} height
	         */
setViewRect:function(x,y,width,height){this.transformTo(x,y,width,height),this._viewRect=new BoundingRect(x,y,width,height)},/**
	         * Transformed to particular position and size
	         * @param {number} x
	         * @param {number} y
	         * @param {number} width
	         * @param {number} height
	         */
transformTo:function(x,y,width,height){var rect=this.getBoundingRect(),viewTransform=this._viewTransform;viewTransform.transform=rect.calculateTransform(new BoundingRect(x,y,width,height)),viewTransform.decomposeTransform(),this._updateTransform()},/**
	         * @param {number} x
	         * @param {number} y
	         */
setPan:function(x,y){this._roamTransform.position=[x,y],this._updateTransform()},/**
	         * @param {number} zoom
	         */
setZoom:function(zoom){var zoomLimit=this.zoomLimit;zoomLimit&&(zoom=Math.max(Math.min(zoom,zoomLimit.max),zoomLimit.min)),this._roamTransform.scale=[zoom,zoom],this._updateTransform()},/**
	         * @return {Array.<number}
	         */
getRoamTransform:function(){return this._roamTransform.transform},/**
	         * Update transform from roam and mapLocation
	         * @private
	         */
_updateTransform:function(){var roamTransform=this._roamTransform,viewTransform=this._viewTransform;
// var scale = this.scale;
viewTransform.parent=roamTransform,roamTransform.updateTransform(),viewTransform.updateTransform(),viewTransform.transform&&matrix.copy(this.transform||(this.transform=[]),viewTransform.transform),this.decomposeTransform()},/**
	         * @return {module:zrender/core/BoundingRect}
	         */
getViewRect:function(){return this._viewRect},/**
	         * Convert a single (lon, lat) data item to (x, y) point.
	         * @param {Array.<number>} data
	         * @return {Array.<number>}
	         */
dataToPoint:function(data){var transform=this.transform;return transform?v2ApplyTransform([],data,transform):[data[0],data[1]]},/**
	         * Convert a (x, y) point to (lon, lat) data
	         * @param {Array.<number>} point
	         * @return {Array.<number>}
	         */
pointToData:function(point){var invTransform=this.invTransform;return invTransform?v2ApplyTransform([],point,invTransform):[point[0],point[1]]}},zrUtil.mixin(View,Transformable),module.exports=View},/* 170 */
/***/
function(module,exports,__webpack_require__){for(var Region=__webpack_require__(167),geoCoord=[126,25],points=[[[0,3.5],[7,11.2],[15,11.9],[30,7],[42,.7],[52,.7],[56,7.7],[59,.7],[64,.7],[64,0],[5,0],[0,3.5]],[[13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]],[[12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]],[[16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]],[[6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]],[[23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]],[[37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]],[[48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]],[[51,35],[51,28.7],[53,28.7],[53,35],[51,35]],[[52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]],[[58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]],[[0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],[1,92.4],[1,3.5],[0,3.5]]],i=0;i<points.length;i++)for(var k=0;k<points[i].length;k++)points[i][k][0]/=10.5,points[i][k][1]/=-14,points[i][k][0]+=geoCoord[0],points[i][k][1]+=geoCoord[1];module.exports=function(geo){"china"===geo.map&&geo.regions.push(new Region("南海诸岛",points,geoCoord))}},/* 171 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),coordsOffsetMap={"南海诸岛":[32,80],
// 全国
"广东":[0,-10],"香港":[10,5],"澳门":[-10,10],
//'北京': [-10, 0],
"天津":[5,5]};module.exports=function(geo){zrUtil.each(geo.regions,function(region){var coordFix=coordsOffsetMap[region.name];if(coordFix){var cp=region.center;cp[0]+=coordFix[0]/10.5,cp[1]+=-coordFix[1]/14}})}},/* 172 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),geoCoordMap={Russia:[100,60],"United States of America":[-99,38]};module.exports=function(geo){zrUtil.each(geo.regions,function(region){var geoCoord=geoCoordMap[region.name];if(geoCoord){var cp=region.center;cp[0]=geoCoord[0],cp[1]=geoCoord[1]}})}},/* 173 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3);module.exports=function(ecModel){var processedMapType={};ecModel.eachSeriesByType("map",function(mapSeries){var mapType=mapSeries.get("map");if(!processedMapType[mapType]){var mapSymbolOffsets={};zrUtil.each(mapSeries.seriesGroup,function(subMapSeries){var geo=subMapSeries.coordinateSystem,data=subMapSeries.getData();subMapSeries.get("showLegendSymbol")&&ecModel.getComponent("legend")&&data.each("value",function(value,idx){var name=data.getName(idx),region=geo.getRegion(name);
// No region or no value
// In MapSeries data regions will be filled with NaN
// If they are not in the series.data array.
// So here must validate if value is NaN
if(region&&!isNaN(value)){var offset=mapSymbolOffsets[name]||0,point=geo.dataToPoint(region.center);mapSymbolOffsets[name]=offset+1,data.setItemLayout(idx,{point:point,offset:offset})}})});
// Show label of those region not has legendSymbol(which is offset 0)
var data=mapSeries.getData();data.each(function(idx){var name=data.getName(idx),layout=data.getItemLayout(idx)||{};layout.showLabel=!mapSymbolOffsets[name],data.setItemLayout(idx,layout)}),processedMapType[mapType]=!0}})}},/* 174 */
/***/
function(module,exports){module.exports=function(ecModel){ecModel.eachSeriesByType("map",function(seriesModel){var colorList=seriesModel.get("color"),itemStyleModel=seriesModel.getModel("itemStyle.normal"),areaColor=itemStyleModel.get("areaColor"),color=itemStyleModel.get("color")||colorList[seriesModel.seriesIndex%colorList.length];seriesModel.getData().setVisual({areaColor:areaColor,color:color})})}},/* 175 */
/***/
function(module,exports,__webpack_require__){
// FIXME 公用？
/**
	     * @param {Array.<module:echarts/data/List>} datas
	     * @param {string} statisticsType 'average' 'sum'
	     * @inner
	     */
function dataStatistics(datas,statisticsType){for(var dataNameMap={},dims=["value"],i=0;i<datas.length;i++)datas[i].each(dims,function(value,idx){var name=datas[i].getName(idx);dataNameMap[name]=dataNameMap[name]||[],isNaN(value)||dataNameMap[name].push(value)});return datas[0].map(dims,function(value,idx){for(var name=datas[0].getName(idx),sum=0,min=1/0,max=-(1/0),len=dataNameMap[name].length,i=0;len>i;i++)min=Math.min(min,dataNameMap[name][i]),max=Math.max(max,dataNameMap[name][i]),sum+=dataNameMap[name][i];var result;return result="min"===statisticsType?min:"max"===statisticsType?max:"average"===statisticsType?sum/len:sum,0===len?NaN:result})}var zrUtil=__webpack_require__(3);module.exports=function(ecModel){var seriesGroupByMapType={};ecModel.eachSeriesByType("map",function(seriesModel){var mapType=seriesModel.get("map");seriesGroupByMapType[mapType]=seriesGroupByMapType[mapType]||[],seriesGroupByMapType[mapType].push(seriesModel)}),zrUtil.each(seriesGroupByMapType,function(seriesList,mapType){var data=dataStatistics(zrUtil.map(seriesList,function(seriesModel){return seriesModel.getData()}),seriesList[0].get("mapValueCalculation"));seriesList[0].seriesGroup=[],seriesList[0].setData(data);
// FIXME Put where?
for(var i=0;i<seriesList.length;i++)seriesList[i].seriesGroup=seriesList,seriesList[i].needsDrawMap=0===i})}},/* 176 */
/***/
function(module,exports,__webpack_require__){function createGeoFromMap(mapSeriesOpt){var geoOpt={};return zrUtil.each(geoProps,function(propName){null!=mapSeriesOpt[propName]&&(geoOpt[propName]=mapSeriesOpt[propName])}),geoOpt}var zrUtil=__webpack_require__(3),geoProps=["x","y","x2","y2","width","height","map","roam","roamDetail","label","itemStyle"],geoCoordsMap={};module.exports=function(option){
// Save geoCoord
var mapSeries=[];zrUtil.each(option.series,function(seriesOpt){"map"===seriesOpt.type&&mapSeries.push(seriesOpt),zrUtil.extend(geoCoordsMap,seriesOpt.geoCoord)});var newCreatedGeoOptMap={};zrUtil.each(mapSeries,function(seriesOpt){if(seriesOpt.map=seriesOpt.map||seriesOpt.mapType,
// Put x, y, width, height, x2, y2 in the top level
zrUtil.defaults(seriesOpt,seriesOpt.mapLocation),seriesOpt.markPoint){var markPoint=seriesOpt.markPoint;
// Convert map series which only has markPoint without data to scatter series
// FIXME
if(
// Convert name or geoCoord in markPoint to lng and lat
// For example
// { name: 'xxx', value: 10} Or
// { geoCoord: [lng, lat], value: 10} to
// { name: 'xxx', value: [lng, lat, 10]}
markPoint.data=zrUtil.map(markPoint.data,function(dataOpt){if(!zrUtil.isArray(dataOpt.value)){var geoCoord;dataOpt.geoCoord?geoCoord=dataOpt.geoCoord:dataOpt.name&&(geoCoord=geoCoordsMap[dataOpt.name]);var newValue=geoCoord?[geoCoord[0],geoCoord[1]]:[NaN,NaN];null!=dataOpt.value&&newValue.push(dataOpt.value),dataOpt.value=newValue}return dataOpt}),!seriesOpt.data||!seriesOpt.data.length){option.geo||(option.geo=[]);
// Use same geo if multiple map series has same map type
var geoOpt=newCreatedGeoOptMap[seriesOpt.map];geoOpt||(geoOpt=newCreatedGeoOptMap[seriesOpt.map]=createGeoFromMap(seriesOpt),option.geo.push(geoOpt));var scatterSeries=seriesOpt.markPoint;scatterSeries.type=option.effect&&option.effect.show?"effectScatter":"scatter",scatterSeries.coordinateSystem="geo",scatterSeries.geoIndex=zrUtil.indexOf(option.geo,geoOpt),scatterSeries.name=seriesOpt.name,option.series.splice(zrUtil.indexOf(option.series,seriesOpt),1,scatterSeries)}}})}},/* 177 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(178),__webpack_require__(182),__webpack_require__(185),echarts.registerVisualCoding("chart",__webpack_require__(186)),echarts.registerLayout(__webpack_require__(188))},/* 178 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {Object} dataNode
	     */
function completeTreeValue(dataNode,arrValueLength){
// Postorder travel tree.
// If value of none-leaf node is not set,
// calculate it by suming up the value of all children.
var sum=0;zrUtil.each(dataNode.children,function(child){completeTreeValue(child,arrValueLength);var childValue=child.value;zrUtil.isArray(childValue)&&(childValue=childValue[0]),sum+=childValue});var thisValue=dataNode.value;arrValueLength>=0&&(zrUtil.isArray(thisValue)?thisValue=thisValue[0]:dataNode.value=new Array(arrValueLength)),(null==thisValue||isNaN(thisValue))&&(thisValue=sum),
// Value should not less than 0.
0>thisValue&&(thisValue=0),arrValueLength>=0?dataNode.value[0]=thisValue:dataNode.value=thisValue}/**
	     * set default to level configuration
	     */
function setDefault(levels,ecModel){var globalColorList=ecModel.get("color");if(globalColorList){levels=levels||[];var hasColorDefine;if(zrUtil.each(levels,function(levelDefine){var model=new Model(levelDefine),modelColor=model.get("color");(model.get("itemStyle.normal.color")||modelColor&&"none"!==modelColor)&&(hasColorDefine=!0)}),!hasColorDefine){var level0=levels[0]||(levels[0]={});level0.color=globalColorList.slice()}return levels}}var SeriesModel=__webpack_require__(27),Tree=__webpack_require__(179),zrUtil=__webpack_require__(3),Model=__webpack_require__(8),formatUtil=__webpack_require__(6),encodeHTML=(__webpack_require__(181),formatUtil.encodeHTML),addCommas=formatUtil.addCommas;module.exports=SeriesModel.extend({type:"series.treemap",dependencies:["grid","polar"],/**
	         * @type {module:echarts/data/Tree~Node}
	         */
_viewRoot:null,defaultOption:{
// center: ['50%', '50%'],          // not supported in ec3.
// size: ['80%', '80%'],            // deprecated, compatible with ec2.
left:"center",top:"middle",right:null,bottom:null,width:"80%",height:"80%",sort:!0,// Can be null or false or true
// (order by desc default, asc not supported yet (strange effect))
clipWindow:"origin",// Size of clipped window when zooming. 'origin' or 'fullscreen'
squareRatio:.5*(1+Math.sqrt(5)),// golden ratio
leafDepth:null,// Nodes on depth from root are regarded as leaves.
// Count from zero (zero represents only view root).
visualDimension:0,// Can be 0, 1, 2, 3.
zoomToNodeRatio:.1024,// Be effective when using zoomToNode. Specify the proportion of the
// target node area in the view area.
roam:!0,// true, false, 'scale' or 'zoom', 'move'.
nodeClick:"zoomToNode",// Leaf node click behaviour: 'zoomToNode', 'link', false.
// If leafDepth is set and clicking a node which has children but
// be on left depth, the behaviour would be changing root. Otherwise
// use behavious defined above.
animation:!0,animationDurationUpdate:900,animationEasing:"quinticInOut",breadcrumb:{show:!0,height:22,left:"center",top:"bottom",
// right
// bottom
emptyItemWidth:25,// Width of empty node.
itemStyle:{normal:{color:"rgba(0,0,0,0.7)",//'#5793f3',
borderColor:"rgba(255,255,255,0.7)",borderWidth:1,shadowColor:"rgba(150,150,150,1)",shadowBlur:3,shadowOffsetX:0,shadowOffsetY:0,textStyle:{color:"#fff"}},emphasis:{textStyle:{}}}},label:{normal:{show:!0,position:["50%","50%"],// Can be 5, '5%' or position stirng like 'insideTopLeft', ...
textStyle:{align:"center",baseline:"middle",color:"#fff",ellipsis:!0}}},itemStyle:{normal:{color:null,// Can be 'none' if not necessary.
colorAlpha:null,// Can be 'none' if not necessary.
colorSaturation:null,// Can be 'none' if not necessary.
borderWidth:0,gapWidth:0,borderColor:"#fff",borderColorSaturation:null},emphasis:{}},color:"none",// Array. Specify color list of each level.
// level[0].color would be global color list.
colorAlpha:null,// Array. Specify color alpha range of each level, like [0.2, 0.8]
colorSaturation:null,// Array. Specify color saturation of each level, like [0.2, 0.5]
colorMappingBy:"index",// 'value' or 'index' or 'id'.
visibleMin:10,// If area less than this threshold (unit: pixel^2), node will not
// be rendered. Only works when sort is 'asc' or 'desc'.
childrenVisibleMin:null,// If area of a node less than this threshold (unit: pixel^2),
// grandchildren will not show.
// Why grandchildren? If not grandchildren but children,
// some siblings show children and some not,
// the appearance may be mess and not consistent,
levels:[]},/**
	         * @override
	         */
getInitialData:function(option,ecModel){var data=option.data||[],rootName=option.name;null==rootName&&(rootName=option.name);
// Create a virtual root.
var root={name:rootName,children:option.data},value0=(data[0]||{}).value;completeTreeValue(root,zrUtil.isArray(value0)?value0.length:-1);
// FIXME
// sereis.mergeOption 的 getInitData是否放在merge后，从而能直接获取merege后的结果而非手动判断。
var levels=option.levels||[];
// Make sure always a new tree is created when setOption,
// in TreemapView, we check whether oldTree === newTree
// to choose mappings approach among old shapes and new shapes.
return levels=option.levels=setDefault(levels,ecModel),Tree.createTree(root,this,levels).data},optionUpdated:function(){this.resetViewRoot()},/**
	         * @override
	         * @param {number} dataIndex
	         * @param {boolean} [mutipleSeries=false]
	         */
formatTooltip:function(dataIndex){var data=this.getData(),value=this.getRawValue(dataIndex),formattedValue=addCommas(zrUtil.isArray(value)?value[0]:value),name=data.getName(dataIndex);return encodeHTML(name)+": "+formattedValue},/**
	         * Add tree path to tooltip param
	         *
	         * @override
	         * @param {number} dataIndex
	         * @return {Object}
	         */
getDataParams:function(dataIndex){for(var params=SeriesModel.prototype.getDataParams.apply(this,arguments),data=this.getData(),node=data.tree.getNodeByDataIndex(dataIndex),treePathInfo=params.treePathInfo=[];node;){var nodeDataIndex=node.dataIndex;treePathInfo.push({name:node.name,dataIndex:nodeDataIndex,value:this.getRawValue(nodeDataIndex)}),node=node.parentNode}return treePathInfo.reverse(),params},/**
	         * @public
	         * @param {Object} layoutInfo {
	         *                                x: containerGroup x
	         *                                y: containerGroup y
	         *                                width: containerGroup width
	         *                                height: containerGroup height
	         *                            }
	         */
setLayoutInfo:function(layoutInfo){/**
	             * @readOnly
	             * @type {Object}
	             */
this.layoutInfo=this.layoutInfo||{},zrUtil.extend(this.layoutInfo,layoutInfo)},/**
	         * @param  {string} id
	         * @return {number} index
	         */
mapIdToIndex:function(id){
// A feature is implemented:
// index is monotone increasing with the sequence of
// input id at the first time.
// This feature can make sure that each data item and its
// mapped color have the same index between data list and
// color list at the beginning, which is useful for user
// to adjust data-color mapping.
/**
	             * @private
	             * @type {Object}
	             */
var idIndexMap=this._idIndexMap;idIndexMap||(idIndexMap=this._idIndexMap={},this._idIndexMapCount=0);var index=idIndexMap[id];return null==index&&(idIndexMap[id]=index=this._idIndexMapCount++),index},getViewRoot:function(){return this._viewRoot},/**
	         * @param {module:echarts/data/Tree~Node} [viewRoot]
	         * @return {string} direction 'drilldown' or 'rollup'
	         */
resetViewRoot:function(viewRoot){viewRoot?this._viewRoot=viewRoot:viewRoot=this._viewRoot;var root=this.getData().tree.root;viewRoot&&(viewRoot===root||root.contains(viewRoot))||(this._viewRoot=root)}})},/* 179 */
/***/
function(module,exports,__webpack_require__){/**
	     * @constructor
	     * @alias module:echarts/data/Tree
	     * @param {module:echarts/model/Model} hostModel
	     * @param {Array.<Object>} levelOptions
	     */
function Tree(hostModel,levelOptions){/**
	         * @type {module:echarts/data/Tree~TreeNode}
	         * @readOnly
	         */
this.root,/**
	         * @type {module:echarts/data/List}
	         * @readOnly
	         */
this.data,/**
	         * Index of each item is the same as the raw index of coresponding list item.
	         * @private
	         * @type {Array.<module:echarts/data/Tree~TreeNode}
	         */
this._nodes=[],/**
	         * @private
	         * @readOnly
	         * @type {module:echarts/model/Model}
	         */
this.hostModel=hostModel,/**
	         * @private
	         * @readOnly
	         * @type {Array.<module:echarts/model/Model}
	         */
this.levelModels=zrUtil.map(levelOptions||[],function(levelDefine){return new Model(levelDefine,hostModel,hostModel.ecModel)})}/**
	     * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
	     * so this function is not ready and not necessary to be public.
	     *
	     * @param {(module:echarts/data/Tree~TreeNode|Object)} child
	     */
function addChild(child,node){var children=node.children;child.parentNode!==node&&(children.push(child),child.parentNode=node,node.hostTree._nodes.push(child))}/**
	 * Tree data structure
	 *
	 * @module echarts/data/Tree
	 */
var zrUtil=__webpack_require__(3),Model=__webpack_require__(8),List=__webpack_require__(94),linkListHelper=__webpack_require__(180),completeDimensions=__webpack_require__(96),TreeNode=function(name,dataIndex,hostTree){/**
	         * @type {string}
	         */
this.name=name||"",/**
	         * Depth of node
	         *
	         * @type {number}
	         * @readOnly
	         */
this.depth=0,/**
	         * Height of the subtree rooted at this node.
	         * @type {number}
	         * @readOnly
	         */
this.height=0,/**
	         * @type {module:echarts/data/Tree~TreeNode}
	         * @readOnly
	         */
this.parentNode=null,/**
	         * Reference to list item.
	         * Do not persistent dataIndex outside,
	         * besause it may be changed by list.
	         * If dataIndex -1,
	         * this node is logical deleted (filtered) in list.
	         *
	         * @type {Object}
	         * @readOnly
	         */
this.dataIndex=null==dataIndex?-1:dataIndex,/**
	         * @type {Array.<module:echarts/data/Tree~TreeNode>}
	         * @readOnly
	         */
this.children=[],/**
	         * @type {Array.<module:echarts/data/Tree~TreeNode>}
	         * @pubilc
	         */
this.viewChildren=[],/**
	         * @type {moduel:echarts/data/Tree}
	         * @readOnly
	         */
this.hostTree=hostTree};TreeNode.prototype={constructor:TreeNode,/**
	         * The node is removed.
	         * @return {boolean} is removed.
	         */
isRemoved:function(){return this.dataIndex<0},/**
	         * Travel this subtree (include this node).
	         * Usage:
	         *    node.eachNode(function () { ... }); // preorder
	         *    node.eachNode('preorder', function () { ... }); // preorder
	         *    node.eachNode('postorder', function () { ... }); // postorder
	         *    node.eachNode(
	         *        {order: 'postorder', attr: 'viewChildren'},
	         *        function () { ... }
	         *    ); // postorder
	         *
	         * @param {(Object|string)} options If string, means order.
	         * @param {string=} options.order 'preorder' or 'postorder'
	         * @param {string=} options.attr 'children' or 'viewChildren'
	         * @param {Function} cb If in preorder and return false,
	         *                      its subtree will not be visited.
	         * @param {Object} [context]
	         */
eachNode:function(options,cb,context){"function"==typeof options&&(context=cb,cb=options,options=null),options=options||{},zrUtil.isString(options)&&(options={order:options});var suppressVisitSub,order=options.order||"preorder",children=this[options.attr||"children"];"preorder"===order&&(suppressVisitSub=cb.call(context,this));for(var i=0;!suppressVisitSub&&i<children.length;i++)children[i].eachNode(options,cb,context);"postorder"===order&&cb.call(context,this)},/**
	         * Update depth and height of this subtree.
	         *
	         * @param  {number} depth
	         */
updateDepthAndHeight:function(depth){var height=0;this.depth=depth;for(var i=0;i<this.children.length;i++){var child=this.children[i];child.updateDepthAndHeight(depth+1),child.height>height&&(height=child.height)}this.height=height+1},/**
	         * @param  {string} id
	         * @return {module:echarts/data/Tree~TreeNode}
	         */
getNodeById:function(id){if(this.getId()===id)return this;for(var i=0,children=this.children,len=children.length;len>i;i++){var res=children[i].getNodeById(id);if(res)return res}},/**
	         * @param {module:echarts/data/Tree~TreeNode} node
	         * @return {boolean}
	         */
contains:function(node){if(node===this)return!0;for(var i=0,children=this.children,len=children.length;len>i;i++){var res=children[i].contains(node);if(res)return res}},/**
	         * @param {boolean} includeSelf Default false.
	         * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
	         */
getAncestors:function(includeSelf){for(var ancestors=[],node=includeSelf?this:this.parentNode;node;)ancestors.push(node),node=node.parentNode;return ancestors.reverse(),ancestors},/**
	         * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
	         * @return {number} Value.
	         */
getValue:function(dimension){var data=this.hostTree.data;return data.get(data.getDimension(dimension||"value"),this.dataIndex)},/**
	         * @param {Object} layout
	         * @param {boolean=} [merge=false]
	         */
setLayout:function(layout,merge){this.dataIndex>=0&&this.hostTree.data.setItemLayout(this.dataIndex,layout,merge)},/**
	         * @return {Object} layout
	         */
getLayout:function(){return this.hostTree.data.getItemLayout(this.dataIndex)},/**
	         * @param {string} path
	         * @return {module:echarts/model/Model}
	         */
getModel:function(path){if(!(this.dataIndex<0)){var hostTree=this.hostTree,itemModel=hostTree.data.getItemModel(this.dataIndex),levelModel=this.getLevelModel();return itemModel.getModel(path,(levelModel||hostTree.hostModel).getModel(path))}},/**
	         * @return {module:echarts/model/Model}
	         */
getLevelModel:function(){return(this.hostTree.levelModels||[])[this.depth]},/**
	         * @example
	         *  setItemVisual('color', color);
	         *  setItemVisual({
	         *      'color': color
	         *  });
	         */
setVisual:function(key,value){this.dataIndex>=0&&this.hostTree.data.setItemVisual(this.dataIndex,key,value)},/**
	         * @public
	         */
getVisual:function(key,ignoreParent){return this.hostTree.data.getItemVisual(this.dataIndex,key,ignoreParent)},/**
	         * @public
	         * @return {number}
	         */
getRawIndex:function(){return this.hostTree.data.getRawIndex(this.dataIndex)},/**
	         * @public
	         * @return {string}
	         */
getId:function(){return this.hostTree.data.getId(this.dataIndex)}},Tree.prototype={constructor:Tree,type:"tree",/**
	         * Travel this subtree (include this node).
	         * Usage:
	         *    node.eachNode(function () { ... }); // preorder
	         *    node.eachNode('preorder', function () { ... }); // preorder
	         *    node.eachNode('postorder', function () { ... }); // postorder
	         *    node.eachNode(
	         *        {order: 'postorder', attr: 'viewChildren'},
	         *        function () { ... }
	         *    ); // postorder
	         *
	         * @param {(Object|string)} options If string, means order.
	         * @param {string=} options.order 'preorder' or 'postorder'
	         * @param {string=} options.attr 'children' or 'viewChildren'
	         * @param {Function} cb
	         * @param {Object}   [context]
	         */
eachNode:function(options,cb,context){this.root.eachNode(options,cb,context)},/**
	         * @param {number} dataIndex
	         * @return {module:echarts/data/Tree~TreeNode}
	         */
getNodeByDataIndex:function(dataIndex){var rawIndex=this.data.getRawIndex(dataIndex);return this._nodes[rawIndex]},/**
	         * @param {string} name
	         * @return {module:echarts/data/Tree~TreeNode}
	         */
getNodeByName:function(name){return this.root.getNodeByName(name)},/**
	         * Update item available by list,
	         * when list has been performed options like 'filterSelf' or 'map'.
	         */
update:function(){for(var data=this.data,nodes=this._nodes,i=0,len=nodes.length;len>i;i++)nodes[i].dataIndex=-1;for(var i=0,len=data.count();len>i;i++)nodes[data.getRawIndex(i)].dataIndex=i}},/**
	     * data node format:
	     * {
	     *     name: ...
	     *     value: ...
	     *     children: [
	     *         {
	     *             name: ...
	     *             value: ...
	     *             children: ...
	     *         },
	     *         ...
	     *     ]
	     * }
	     *
	     * @static
	     * @param {Objec} dataRoot Root node.
	     * @param {module:echarts/model/Model} hostModel
	     * @param {Array.<Object>} levelOptions
	     * @return module:echarts/data/Tree
	     */
Tree.createTree=function(dataRoot,hostModel,levelOptions){function buildHierarchy(dataNode,parentNode){listData.push(dataNode);var node=new TreeNode(dataNode.name,listData.length-1,tree);parentNode?addChild(node,parentNode):tree.root=node;var children=dataNode.children;if(children)for(var i=0;i<children.length;i++)buildHierarchy(children[i],node)}var tree=new Tree(hostModel,levelOptions),listData=[];buildHierarchy(dataRoot),tree.root.updateDepthAndHeight(0);var dimensions=completeDimensions([{name:"value"}],listData),list=new List(dimensions,hostModel);return list.initData(listData),linkListHelper.linkToTree(list,tree),tree},module.exports=Tree},/* 180 */
/***/
function(module,exports,__webpack_require__){
// Caution:
// In most case, only one of the list and its shallow clones (see list.cloneShallow)
// can be active in echarts process. Considering heap memory consumption,
// we do not clone tree or graph, but share them among list and its shallow clones.
// But in some rare case, we have to keep old list (like do animation in chart). So
// please take care that both the old list and the new list share the same tree/graph.
function linkList(list,target,targetType){return zrUtil.each(listProxyMethods,function(method,methodName){var originMethod=list[methodName];list[methodName]=zrUtil.curry(method,originMethod,target,targetType)}),list[targetType]=target,target.data=list,list}/**
	 * Link list to graph or tree
	 */
var zrUtil=__webpack_require__(3),arraySlice=Array.prototype.slice,listProxyMethods={cloneShallow:function(originMethod,target,targetType){var newList=originMethod.apply(this,arraySlice.call(arguments,3));return linkList(newList,target,targetType)},map:function(originMethod,target,targetType){var newList=originMethod.apply(this,arraySlice.call(arguments,3));return linkList(newList,target,targetType)},filterSelf:function(originMethod,target,targetType){var result=originMethod.apply(this,arraySlice.call(arguments,3));return target.update(),result}};module.exports={linkToGraph:function(list,graph){linkList(list,graph,"graph")},linkToTree:function(list,tree){linkList(list,tree,"tree")}}},/* 181 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),helper={retrieveTargetInfo:function(payload,seriesModel){if(payload&&("treemapZoomToNode"===payload.type||"treemapRootToNode"===payload.type)){var root=seriesModel.getData().tree.root,targetNode=payload.targetNode;if(targetNode&&root.contains(targetNode))return{node:targetNode};var targetNodeId=payload.targetNodeId;if(null!=targetNodeId&&(targetNode=root.getNodeById(targetNodeId)))return{node:targetNode}}},getPathToRoot:function(node){for(var path=[];node;)path.push(node),node=node.parentNode;return path.reverse()},aboveViewRoot:function(viewRoot,node){var viewPath=helper.getPathToRoot(viewRoot);return helper.aboveViewRootByViewPath(viewPath,node)},
// viewPath should obtained from getPathToRoot(viewRoot)
aboveViewRootByViewPath:function(viewPath,node){var index=zrUtil.indexOf(viewPath,node);
// The last one is viewRoot
return index>=0&&index!==viewPath.length-1}};module.exports=helper},/* 182 */
/***/
function(module,exports,__webpack_require__){function createStorage(){return{nodeGroup:[],background:[],content:[]}}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),DataDiffer=__webpack_require__(95),helper=__webpack_require__(181),Breadcrumb=__webpack_require__(183),RoamController=__webpack_require__(159),BoundingRect=__webpack_require__(15),matrix=__webpack_require__(17),animationUtil=__webpack_require__(184),bind=zrUtil.bind,Group=graphic.Group,Rect=graphic.Rect,each=zrUtil.each,DRAG_THRESHOLD=3;module.exports=__webpack_require__(1).extendChartView({type:"treemap",/**
	         * @override
	         */
init:function(o,api){/**
	             * @private
	             * @type {module:zrender/container/Group}
	             */
this._containerGroup,/**
	             * @private
	             * @type {Object.<string, Array.<module:zrender/container/Group>>}
	             */
this._storage=createStorage(),/**
	             * @private
	             * @type {module:echarts/data/Tree}
	             */
this._oldTree,/**
	             * @private
	             * @type {module:echarts/chart/treemap/Breadcrumb}
	             */
this._breadcrumb,/**
	             * @private
	             * @type {module:echarts/component/helper/RoamController}
	             */
this._controller,/**
	             * 'ready', 'animating'
	             * @private
	             */
this._state="ready",/**
	             * @private
	             * @type {boolean}
	             */
this._mayClick},/**
	         * @override
	         */
render:function(seriesModel,ecModel,api,payload){var models=ecModel.findComponents({mainType:"series",subType:"treemap",query:payload});if(!(zrUtil.indexOf(models,seriesModel)<0)){this.seriesModel=seriesModel,this.api=api,this.ecModel=ecModel;var targetInfo=helper.retrieveTargetInfo(payload,seriesModel),payloadType=payload&&payload.type,layoutInfo=seriesModel.layoutInfo,isInit=!this._oldTree,thisStorage=this._storage,reRoot="treemapRootToNode"===payloadType&&targetInfo&&thisStorage?{rootNodeGroup:thisStorage.nodeGroup[targetInfo.node.getRawIndex()],direction:payload.direction}:null,containerGroup=this._giveContainerGroup(layoutInfo),renderResult=this._doRender(containerGroup,seriesModel,reRoot);isInit||payloadType&&"treemapZoomToNode"!==payloadType&&"treemapRootToNode"!==payloadType?renderResult.renderFinally():this._doAnimation(containerGroup,renderResult,seriesModel,reRoot),this._resetController(api),this._renderBreadcrumb(seriesModel,api,targetInfo)}},/**
	         * @private
	         */
_giveContainerGroup:function(layoutInfo){var containerGroup=this._containerGroup;
// FIXME
// 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
return containerGroup||(containerGroup=this._containerGroup=new Group,this._initEvents(containerGroup),this.group.add(containerGroup)),containerGroup.position=[layoutInfo.x,layoutInfo.y],containerGroup},/**
	         * @private
	         */
_doRender:function(containerGroup,seriesModel,reRoot){function dualTravel(thisViewChildren,oldViewChildren,parentGroup,sameTree,viewPathIndex){function getKey(node){
// Identify by name or raw index.
return node.getId()}function processNode(newIndex,oldIndex){var thisNode=null!=newIndex?thisViewChildren[newIndex]:null,oldNode=null!=oldIndex?oldViewChildren[oldIndex]:null;
// Whether under viewRoot.
if(!(!thisNode||isNaN(viewPathIndex)||viewPathIndex<viewPath.length&&viewPath[viewPathIndex]!==thisNode)){var group=renderNode(thisNode,oldNode,parentGroup);group&&dualTravel(thisNode&&thisNode.viewChildren||[],oldNode&&oldNode.viewChildren||[],group,sameTree,viewPathIndex+1)}}
// When 'render' is triggered by action,
// 'this' and 'old' may be the same tree,
// we use rawIndex in that case.
sameTree?(oldViewChildren=thisViewChildren,each(thisViewChildren,function(child,index){!child.isRemoved()&&processNode(index,index)})):new DataDiffer(oldViewChildren,thisViewChildren,getKey,getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode,null)).execute()}function clearStorage(storage){var willDeleteEls=createStorage();return storage&&each(storage,function(store,storageName){var delEls=willDeleteEls[storageName];each(store,function(el){el&&(delEls.push(el),el.__tmWillDelete=storageName)})}),willDeleteEls}function renderFinally(){each(willDeleteEls,function(els){each(els,function(el){el.parent&&el.parent.remove(el)})}),
// Theoritically there is no intersection between willInvisibleEls
// and willVisibleEls have, but we set visible after for robustness.
each(willInvisibleEls,function(el){el.invisible=!0,
// Setting invisible is for optimizing, so no need to set dirty,
// just mark as invisible.
el.dirty()}),each(willVisibleEls,function(el){el.invisible=!1,el.__tmWillVisible=!1,el.dirty()})}var thisTree=seriesModel.getData().tree,oldTree=this._oldTree,lastsForAnimation=createStorage(),thisStorage=createStorage(),oldStorage=this._storage,willInvisibleEls=[],willVisibleEls=[],willDeleteEls=[],renderNode=bind(this._renderNode,this,thisStorage,oldStorage,reRoot,lastsForAnimation,willInvisibleEls,willVisibleEls),viewRoot=seriesModel.getViewRoot(),viewPath=helper.getPathToRoot(viewRoot);
// Notice: when thisTree and oldTree are the same tree (see list.cloneShadow),
// the oldTree is actually losted, so we can not find all of the old graphic
// elements from tree. So we use this stragegy: make element storage, move
// from old storage to new storage, clear old storage.
dualTravel(thisTree.root?[thisTree.root]:[],oldTree&&oldTree.root?[oldTree.root]:[],containerGroup,thisTree===oldTree||!oldTree,0);
// Process all removing.
var willDeleteEls=clearStorage(oldStorage);return this._oldTree=thisTree,this._storage=thisStorage,{lastsForAnimation:lastsForAnimation,willDeleteEls:willDeleteEls,renderFinally:renderFinally}},/**
	         * @private
	         */
_renderNode:function(thisStorage,oldStorage,reRoot,lastsForAnimation,willInvisibleEls,willVisibleEls,thisNode,oldNode,parentGroup){function giveGraphic(storageName,Ctor,z){var element=null!=oldRawIndex&&oldStorage[storageName][oldRawIndex],lasts=lastsForAnimation[storageName];
// Set to thisStorage
// Remove from oldStorage
return element?(oldStorage[storageName][oldRawIndex]=null,prepareAnimationWhenHasOld(lasts,element,storageName)):invisible||(element=new Ctor({z:z}),prepareAnimationWhenNoOld(lasts,element,storageName)),thisStorage[storageName][thisRawIndex]=element}function prepareAnimationWhenHasOld(lasts,element,storageName){var lastCfg=lasts[thisRawIndex]={};lastCfg.old="nodeGroup"===storageName?element.position.slice():zrUtil.extend({},element.shape)}
// If a element is new, we need to find the animation start point carefully,
// otherwise it will looks strange when 'zoomToNode'.
function prepareAnimationWhenNoOld(lasts,element,storageName){
// New background do not animate but delay show.
if("background"===storageName)element.invisible=!0,element.__tmWillVisible=!0,willVisibleEls.push(element);else{var lastCfg=lasts[thisRawIndex]={},parentNode=thisNode.parentNode;if(parentNode&&(!reRoot||"drilldown"===reRoot.direction)){var parentOldX=0,parentOldY=0,parentOldBg=lastsForAnimation.background[parentNode.getRawIndex()];parentOldBg&&parentOldBg.old&&(parentOldX=parentOldBg.old.width/2,parentOldY=parentOldBg.old.height/2),
// When no parent old shape found, its parent is new too,
// so we can just use {x:0, y:0}.
lastCfg.old="nodeGroup"===storageName?[parentOldX,parentOldY]:{x:parentOldX,y:parentOldY,width:0,height:0}}
// Fade in, user can be aware that these nodes are new.
lastCfg.fadein="nodeGroup"!==storageName}}function updateStyle(element,style){invisible?
// Delay invisible setting utill animation finished,
// avoid element vanish suddenly before animation.
!element.invisible&&willInvisibleEls.push(element):(
// If invisible, do not set visual, otherwise the element will
// change immediately before animation. We think it is OK to
// remain its origin color when moving out of the view window.
element.setStyle(style),element.__tmWillVisible||(element.invisible=!1))}var thisRawIndex=thisNode&&thisNode.getRawIndex(),oldRawIndex=oldNode&&oldNode.getRawIndex(),layout=thisNode.getLayout(),thisWidth=layout.width,thisHeight=layout.height,invisible=layout.invisible,group=giveGraphic("nodeGroup",Group);if(group){parentGroup.add(group),group.position=[layout.x,layout.y],group.__tmNodeWidth=thisWidth,group.__tmNodeHeight=thisHeight;
// Background
var bg=giveGraphic("background",Rect,0);bg&&(bg.setShape({x:0,y:0,width:thisWidth,height:thisHeight}),updateStyle(bg,{fill:thisNode.getVisual("borderColor",!0)}),group.add(bg));var thisViewChildren=thisNode.viewChildren;
// No children, render content.
if(!thisViewChildren||!thisViewChildren.length){var borderWidth=layout.borderWidth,content=giveGraphic("content",Rect,3);if(content){var contentWidth=Math.max(thisWidth-2*borderWidth,0),contentHeight=Math.max(thisHeight-2*borderWidth,0),labelModel=thisNode.getModel("label.normal"),textStyleModel=thisNode.getModel("label.normal.textStyle"),hoverStyle=thisNode.getModel("itemStyle.emphasis").getItemStyle(),text=thisNode.getModel().get("name"),textRect=textStyleModel.getTextRect(text),showLabel=labelModel.get("show");!showLabel||textRect.height>contentHeight?text="":textRect.width>contentWidth&&(text=textStyleModel.get("ellipsis")?textStyleModel.ellipsis(text,contentWidth):""),graphic.setHoverStyle(content,hoverStyle),
// For tooltip.
content.dataIndex=thisNode.dataIndex,content.seriesIndex=this.seriesModel.seriesIndex,content.culling=!0,content.setShape({x:borderWidth,y:borderWidth,width:contentWidth,height:contentHeight}),updateStyle(content,{fill:thisNode.getVisual("color",!0),text:text,textPosition:labelModel.get("position"),textFill:textStyleModel.getTextColor(),textAlign:textStyleModel.get("align"),textVerticalAlign:textStyleModel.get("baseline"),textFont:textStyleModel.getFont()}),group.add(content)}}return group}},/**
	         * @private
	         */
_doAnimation:function(containerGroup,renderResult,seriesModel,reRoot){if(seriesModel.get("animation")){var duration=seriesModel.get("animationDurationUpdate"),easing=seriesModel.get("animationEasing"),animationWrap=animationUtil.createWrap();
// Make delete animations.
each(renderResult.willDeleteEls,function(store,storageName){each(store,function(el,rawIndex){var storageName;if(!el.invisible&&(storageName=el.__tmWillDelete)){var target,parent=el.parent;if(reRoot&&"drilldown"===reRoot.direction)parent===reRoot.rootNodeGroup?(target={shape:{x:0,y:0,width:parent.__tmNodeWidth,height:parent.__tmNodeHeight}},el.z=2):(target={style:{opacity:0}},el.z=1);else{var targetX=0,targetY=0;parent.__tmWillDelete||(targetX=parent.__tmNodeWidth/2,targetY=parent.__tmNodeHeight/2),target="nodeGroup"===storageName?{position:[targetX,targetY],style:{opacity:0}}:{shape:{x:targetX,y:targetY,width:0,height:0},style:{opacity:0}}}target&&animationWrap.add(el,target,duration,easing)}})}),
// Make other animations
each(this._storage,function(store,storageName){each(store,function(el,rawIndex){var last=renderResult.lastsForAnimation[storageName][rawIndex],target={};last&&("nodeGroup"===storageName?last.old&&(target.position=el.position.slice(),el.position=last.old):(last.old&&(target.shape=zrUtil.extend({},el.shape),el.setShape(last.old)),last.fadein?(el.setStyle("opacity",0),target.style={opacity:1}):1!==el.style.opacity&&(target.style={opacity:1})),animationWrap.add(el,target,duration,easing))})},this),this._state="animating",animationWrap.done(bind(function(){this._state="ready",renderResult.renderFinally()},this)).start()}},/**
	         * @private
	         */
_resetController:function(api){var controller=this._controller;
// Init controller.
controller||(controller=this._controller=new RoamController(api.getZr()),controller.enable(this.seriesModel.get("roam")),controller.on("pan",bind(this._onPan,this)),controller.on("zoom",bind(this._onZoom,this))),controller.rect=new BoundingRect(0,0,api.getWidth(),api.getHeight())},/**
	         * @private
	         */
_clearController:function(){var controller=this._controller;controller&&(controller.off("pan").off("zoom"),controller=null)},/**
	         * @private
	         */
_onPan:function(dx,dy){if(this._mayClick=!1,"animating"!==this._state&&(Math.abs(dx)>DRAG_THRESHOLD||Math.abs(dy)>DRAG_THRESHOLD)){
// These param must not be cached.
var viewRoot=this.seriesModel.getViewRoot();if(!viewRoot)return;var rootLayout=viewRoot.getLayout();if(!rootLayout)return;this.api.dispatchAction({type:"treemapMove",from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:rootLayout.x+dx,y:rootLayout.y+dy,width:rootLayout.width,height:rootLayout.height}})}},/**
	         * @private
	         */
_onZoom:function(scale,mouseX,mouseY){if(this._mayClick=!1,"animating"!==this._state){
// These param must not be cached.
var viewRoot=this.seriesModel.getViewRoot();if(!viewRoot)return;var rootLayout=viewRoot.getLayout();if(!rootLayout)return;var rect=new BoundingRect(rootLayout.x,rootLayout.y,rootLayout.width,rootLayout.height),layoutInfo=this.seriesModel.layoutInfo;
// Transform mouse coord from global to containerGroup.
mouseX-=layoutInfo.x,mouseY-=layoutInfo.y;
// Scale root bounding rect.
var m=matrix.create();matrix.translate(m,m,[-mouseX,-mouseY]),matrix.scale(m,m,[scale,scale]),matrix.translate(m,m,[mouseX,mouseY]),rect.applyTransform(m),this.api.dispatchAction({type:"treemapRender",from:this.uid,seriesId:this.seriesModel.id,rootRect:{x:rect.x,y:rect.y,width:rect.width,height:rect.height}})}},/**
	         * @private
	         */
_initEvents:function(containerGroup){function onClick(e){var nodeClick=this.seriesModel.get("nodeClick",!0);if(nodeClick){var targetInfo=this.findTarget(e.offsetX,e.offsetY);if(targetInfo){var node=targetInfo.node;if(node.getLayout().isLeafRoot)this._rootToNode(targetInfo);else if("zoomToNode"===nodeClick)this._zoomToNode(targetInfo);else if("link"===nodeClick){var itemModel=node.hostTree.data.getItemModel(node.dataIndex),link=itemModel.get("link",!0),linkTarget=itemModel.get("target",!0)||"blank";link&&window.open(link,linkTarget)}}}}
// FIXME
// 不用click以及silent的原因是，animate时视图设置silent true来避免click生效，
// 但是animate中，按下鼠标，animate结束后（silent设回为false）松开鼠标，
// 还是会触发click，期望是不触发。
// Mousedown occurs when drag start, and mouseup occurs when drag end,
// click event should not be triggered in that case.
containerGroup.on("mousedown",function(e){"ready"===this._state&&(this._mayClick=!0)},this),containerGroup.on("mouseup",function(e){this._mayClick&&(this._mayClick=!1,"ready"===this._state&&onClick.call(this,e))},this)},/**
	         * @private
	         */
_renderBreadcrumb:function(seriesModel,api,targetInfo){function onSelect(node){"animating"!==this._state&&(helper.aboveViewRoot(seriesModel.getViewRoot(),node)?this._rootToNode({node:node}):this._zoomToNode({node:node}))}targetInfo||(targetInfo=this.findTarget(api.getWidth()/2,api.getHeight()/2),targetInfo||(targetInfo={node:seriesModel.getData().tree.root})),(this._breadcrumb||(this._breadcrumb=new Breadcrumb(this.group,bind(onSelect,this)))).render(seriesModel,api,targetInfo.node)},/**
	         * @override
	         */
remove:function(){this._clearController(),this._containerGroup&&this._containerGroup.removeAll(),this._storage=createStorage(),this._state="ready",this._breadcrumb&&this._breadcrumb.remove()},dispose:function(){this._clearController()},/**
	         * @private
	         */
_zoomToNode:function(targetInfo){this.api.dispatchAction({type:"treemapZoomToNode",from:this.uid,seriesId:this.seriesModel.id,targetNode:targetInfo.node})},/**
	         * @private
	         */
_rootToNode:function(targetInfo){this.api.dispatchAction({type:"treemapRootToNode",from:this.uid,seriesId:this.seriesModel.id,targetNode:targetInfo.node})},/**
	         * @public
	         * @param {number} x Global coord x.
	         * @param {number} y Global coord y.
	         * @return {Object} info If not found, return undefined;
	         * @return {number} info.node Target node.
	         * @return {number} info.offsetX x refer to target node.
	         * @return {number} info.offsetY y refer to target node.
	         */
findTarget:function(x,y){var targetInfo,viewRoot=this.seriesModel.getViewRoot();return viewRoot.eachNode({attr:"viewChildren",order:"preorder"},function(node){var bgEl=this._storage.background[node.getRawIndex()];
// If invisible, there might be no element.
if(bgEl){var point=bgEl.transformCoordToLocal(x,y),shape=bgEl.shape;
// For performance consideration, dont use 'getBoundingRect'.
if(!(shape.x<=point[0]&&point[0]<=shape.x+shape.width&&shape.y<=point[1]&&point[1]<=shape.y+shape.height))return!1;targetInfo={node:node,offsetX:point[0],offsetY:point[1]}}},this),targetInfo}})},/* 183 */
/***/
function(module,exports,__webpack_require__){function Breadcrumb(containerGroup,onSelect){/**
	         * @private
	         * @type {module:zrender/container/Group}
	         */
this.group=new graphic.Group,containerGroup.add(this.group),/**
	         * @private
	         * @type {Function}
	         */
this._onSelect=onSelect||zrUtil.noop}function makeItemPoints(x,y,itemWidth,itemHeight,head,tail){var points=[[head?x:x-ARRAY_LENGTH,y],[x+itemWidth,y],[x+itemWidth,y+itemHeight],[head?x:x-ARRAY_LENGTH,y+itemHeight]];return!tail&&points.splice(2,0,[x+itemWidth+ARRAY_LENGTH,y+itemHeight/2]),!head&&points.push([x,y+itemHeight/2]),points}var graphic=__webpack_require__(42),layout=__webpack_require__(21),zrUtil=__webpack_require__(3),TEXT_PADDING=8,ITEM_GAP=8,ARRAY_LENGTH=5;Breadcrumb.prototype={constructor:Breadcrumb,render:function(seriesModel,api,targetNode){var model=seriesModel.getModel("breadcrumb"),thisGroup=this.group;if(thisGroup.removeAll(),model.get("show")&&targetNode){var normalStyleModel=model.getModel("itemStyle.normal"),textStyleModel=normalStyleModel.getModel("textStyle"),layoutParam={pos:{left:model.get("left"),right:model.get("right"),top:model.get("top"),bottom:model.get("bottom")},box:{width:api.getWidth(),height:api.getHeight()},emptyItemWidth:model.get("emptyItemWidth"),totalWidth:0,renderList:[]};this._prepare(model,targetNode,layoutParam,textStyleModel),this._renderContent(model,targetNode,layoutParam,normalStyleModel,textStyleModel),layout.positionGroup(thisGroup,layoutParam.pos,layoutParam.box)}},/**
	         * Prepare render list and total width
	         * @private
	         */
_prepare:function(model,targetNode,layoutParam,textStyleModel){for(var node=targetNode;node;node=node.parentNode){var text=node.getModel().get("name"),textRect=textStyleModel.getTextRect(text),itemWidth=Math.max(textRect.width+2*TEXT_PADDING,layoutParam.emptyItemWidth);layoutParam.totalWidth+=itemWidth+ITEM_GAP,layoutParam.renderList.push({node:node,text:text,width:itemWidth})}},/**
	         * @private
	         */
_renderContent:function(model,targetNode,layoutParam,normalStyleModel,textStyleModel){for(var lastX=0,emptyItemWidth=layoutParam.emptyItemWidth,height=model.get("height"),availableSize=layout.getAvailableSize(layoutParam.pos,layoutParam.box),totalWidth=layoutParam.totalWidth,renderList=layoutParam.renderList,i=renderList.length-1;i>=0;i--){var item=renderList[i],itemWidth=item.width,text=item.text;
// Hdie text and shorten width if necessary.
totalWidth>availableSize.width&&(totalWidth-=itemWidth-emptyItemWidth,itemWidth=emptyItemWidth,text=""),this.group.add(new graphic.Polygon({shape:{points:makeItemPoints(lastX,0,itemWidth,height,i===renderList.length-1,0===i)},style:zrUtil.defaults(normalStyleModel.getItemStyle(),{lineJoin:"bevel",text:text,textFill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()}),z:10,onclick:zrUtil.bind(this._onSelect,this,item.node)})),lastX+=itemWidth+ITEM_GAP}},/**
	         * @override
	         */
remove:function(){this.group.removeAll()}},module.exports=Breadcrumb},/* 184 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {number} [time=500] Time in ms
	     * @param {string} [easing='linear']
	     * @param {number} [delay=0]
	     * @param {Function} [callback]
	     *
	     * @example
	     *  // Animate position
	     *  animation
	     *      .createWrap()
	     *      .add(el1, {position: [10, 10]})
	     *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
	     *      .done(function () { // done })
	     *      .start('cubicOut');
	     */
function createWrap(){var doneCallback,storage=[],elExistsMap={};return{/**
	             * Caution: a el can only be added once, otherwise 'done'
	             * might not be called. This method checks this (by el.id),
	             * suppresses adding and returns false when existing el found.
	             *
	             * @param {modele:zrender/Element} el
	             * @param {Object} target
	             * @param {number} [time=500]
	             * @param {number} [delay=0]
	             * @param {string} [easing='linear']
	             * @return {boolean} Whether adding succeeded.
	             *
	             * @example
	             *     add(el, target, time, delay, easing);
	             *     add(el, target, time, easing);
	             *     add(el, target, time);
	             *     add(el, target);
	             */
add:function(el,target,time,delay,easing){return zrUtil.isString(delay)&&(easing=delay,delay=0),elExistsMap[el.id]?!1:(elExistsMap[el.id]=1,storage.push({el:el,target:target,time:time,delay:delay,easing:easing}),!0)},/**
	             * Only execute when animation finished. Will not execute when any
	             * of 'stop' or 'stopAnimation' called.
	             *
	             * @param {Function} callback
	             */
done:function(callback){return doneCallback=callback,this},/**
	             * Will stop exist animation firstly.
	             */
start:function(){function done(){count--,count||(storage.length=0,elExistsMap={},doneCallback&&doneCallback())}for(var count=storage.length,i=0,len=storage.length;len>i;i++){var item=storage[i];item.el.animateTo(item.target,item.time,item.delay,item.easing,done)}return this}}}var zrUtil=__webpack_require__(3);module.exports={createWrap:createWrap}},/* 185 */
/***/
function(module,exports,__webpack_require__){for(var echarts=__webpack_require__(1),helper=__webpack_require__(181),noop=function(){},actionTypes=["treemapZoomToNode","treemapRender","treemapMove"],i=0;i<actionTypes.length;i++)echarts.registerAction({type:actionTypes[i],update:"updateView"},noop);echarts.registerAction({type:"treemapRootToNode",update:"updateView"},function(payload,ecModel){ecModel.eachComponent({mainType:"series",subType:"treemap",query:payload},function(model,index){var targetInfo=helper.retrieveTargetInfo(payload,model);if(targetInfo){var originViewRoot=model.getViewRoot();originViewRoot&&(payload.direction=helper.aboveViewRoot(originViewRoot,targetInfo.node)?"rollup":"drilldown"),model.resetViewRoot(targetInfo.node)}})})},/* 186 */
/***/
function(module,exports,__webpack_require__){function travelTree(node,designatedVisual,levelItemStyles,seriesItemStyleModel,viewRootAncestors,seriesModel){var nodeModel=node.getModel(),nodeLayout=node.getLayout();
// Optimize
if(!nodeLayout.invisible){var thisNodeColor,nodeItemStyleModel=node.getModel(ITEM_STYLE_NORMAL),levelItemStyle=levelItemStyles[node.depth],visuals=buildVisuals(nodeItemStyleModel,designatedVisual,levelItemStyle,seriesItemStyleModel),borderColor=nodeItemStyleModel.get("borderColor"),borderColorSaturation=nodeItemStyleModel.get("borderColorSaturation");null!=borderColorSaturation&&(thisNodeColor=calculateColor(visuals,node),borderColor=calculateBorderColor(borderColorSaturation,thisNodeColor)),node.setVisual("borderColor",borderColor);var viewChildren=node.viewChildren;if(viewChildren&&viewChildren.length){var mapping=buildVisualMapping(node,nodeModel,nodeLayout,nodeItemStyleModel,visuals,viewChildren);
// Designate visual to children.
zrUtil.each(viewChildren,function(child,index){
// If higher than viewRoot, only ancestors of viewRoot is needed to visit.
if(child.depth>=viewRootAncestors.length||child===viewRootAncestors[child.depth]){var childVisual=mapVisual(nodeModel,visuals,child,index,mapping,seriesModel);travelTree(child,childVisual,levelItemStyles,seriesItemStyleModel,viewRootAncestors,seriesModel)}})}else thisNodeColor=calculateColor(visuals,node),node.setVisual("color",thisNodeColor)}}function buildVisuals(nodeItemStyleModel,designatedVisual,levelItemStyle,seriesItemStyleModel){var visuals=zrUtil.extend({},designatedVisual);return zrUtil.each(["color","colorAlpha","colorSaturation"],function(visualName){
// Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
var val=nodeItemStyleModel.get(visualName,!0);// Ignore parent
null==val&&levelItemStyle&&(val=levelItemStyle[visualName]),null==val&&(val=designatedVisual[visualName]),null==val&&(val=seriesItemStyleModel.get(visualName)),null!=val&&(visuals[visualName]=val)}),visuals}function calculateColor(visuals){var color=getValueVisualDefine(visuals,"color");if(color){var colorAlpha=getValueVisualDefine(visuals,"colorAlpha"),colorSaturation=getValueVisualDefine(visuals,"colorSaturation");return colorSaturation&&(color=zrColor.modifyHSL(color,null,null,colorSaturation)),colorAlpha&&(color=zrColor.modifyAlpha(color,colorAlpha)),color}}function calculateBorderColor(borderColorSaturation,thisNodeColor){return null!=thisNodeColor?zrColor.modifyHSL(thisNodeColor,null,null,borderColorSaturation):null}function getValueVisualDefine(visuals,name){var value=visuals[name];return null!=value&&"none"!==value?value:void 0}function buildVisualMapping(node,nodeModel,nodeLayout,nodeItemStyleModel,visuals,viewChildren){if(viewChildren&&viewChildren.length){var rangeVisual=getRangeVisual(nodeModel,"color")||null!=visuals.color&&"none"!==visuals.color&&(getRangeVisual(nodeModel,"colorAlpha")||getRangeVisual(nodeModel,"colorSaturation"));if(rangeVisual){var colorMappingBy=nodeModel.get("colorMappingBy"),opt={type:rangeVisual.name,dataExtent:nodeLayout.dataExtent,visual:rangeVisual.range};"color"!==opt.type||"index"!==colorMappingBy&&"id"!==colorMappingBy?opt.mappingMethod="linear":(opt.mappingMethod="category",opt.loop=!0);var mapping=new VisualMapping(opt);return mapping.__drColorMappingBy=colorMappingBy,mapping}}}
// Notice: If we dont have the attribute 'colorRange', but only use
// attribute 'color' to represent both concepts of 'colorRange' and 'color',
// (It means 'colorRange' when 'color' is Array, means 'color' when not array),
// this problem will be encountered:
// If a level-1 node dont have children, and its siblings has children,
// and colorRange is set on level-1, then the node can not be colored.
// So we separate 'colorRange' and 'color' to different attributes.
function getRangeVisual(nodeModel,name){
// 'colorRange', 'colorARange', 'colorSRange'.
// If not exsits on this node, fetch from levels and series.
var range=nodeModel.get(name);return isArray(range)&&range.length?{name:name,range:range}:null}function mapVisual(nodeModel,visuals,child,index,mapping,seriesModel){var childVisuals=zrUtil.extend({},visuals);if(mapping){var mappingType=mapping.type,colorMappingBy="color"===mappingType&&mapping.__drColorMappingBy,value="index"===colorMappingBy?index:"id"===colorMappingBy?seriesModel.mapIdToIndex(child.getId()):child.getValue(nodeModel.get("visualDimension"));childVisuals[mappingType]=mapping.mapValueToVisual(value)}return childVisuals}var VisualMapping=__webpack_require__(187),zrColor=__webpack_require__(38),zrUtil=__webpack_require__(3),isArray=zrUtil.isArray,ITEM_STYLE_NORMAL="itemStyle.normal";module.exports=function(ecModel,payload){var condition={mainType:"series",subType:"treemap",query:payload};ecModel.eachComponent(condition,function(seriesModel){var tree=seriesModel.getData().tree,root=tree.root,seriesItemStyleModel=seriesModel.getModel(ITEM_STYLE_NORMAL);if(!root.isRemoved()){var levelItemStyles=zrUtil.map(tree.levelModels,function(levelModel){return levelModel?levelModel.get(ITEM_STYLE_NORMAL):null});travelTree(root,{},levelItemStyles,seriesItemStyleModel,seriesModel.getViewRoot().getAncestors(),seriesModel)}})}},/* 187 */
/***/
function(module,exports,__webpack_require__){function linearMapArray(val,domain,range,clamp){return zrUtil.isArray(val)?zrUtil.map(val,function(v){return linearMap(v,domain,range,clamp)}):linearMap(val,domain,range,clamp)}function preprocessForPiecewise(thisOption){var pieceList=thisOption.pieceList;thisOption.hasSpecialVisual=!1,zrUtil.each(pieceList,function(piece,index){piece.originIndex=index,piece.visual&&(thisOption.hasSpecialVisual=!0)})}function preprocessForCategory(thisOption){
// Hash categories.
var categories=thisOption.categories,visual=thisOption.visual,isVisualArray=zrUtil.isArray(visual);if(!categories){if(isVisualArray)return;
// visual should be array when no categories.
throw new Error}var categoryMap=thisOption.categoryMap={};
// Process visual map input.
if(each(categories,function(cate,index){categoryMap[cate]=index}),!isVisualArray){var visualArr=[];zrUtil.isObject(visual)?each(visual,function(v,cate){var index=categoryMap[cate];visualArr[null!=index?index:CATEGORY_DEFAULT_VISUAL_INDEX]=v}):// Is primary type, represents default visual.
visualArr[CATEGORY_DEFAULT_VISUAL_INDEX]=visual,visual=thisOption.visual=visualArr}
// Remove categories that has no visual,
// then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.
for(var i=categories.length-1;i>=0;i--)null==visual[i]&&(delete categoryMap[categories[i]],categories.pop())}function makePartialColorVisualHandler(applyValue){return{applyVisual:function(value,getter,setter){
// color can be {string} or {Array.<Object>} (for gradient color stops)
var color=getter("color"),isArrayValue=zrUtil.isArray(value);if(value=isArrayValue?[this.mapValueToVisual(value[0]),this.mapValueToVisual(value[1])]:this.mapValueToVisual(value),zrUtil.isArray(color))for(var i=0,len=color.length;len>i;i++)color[i].color=applyValue(color[i].color,isArrayValue?value[i]:value);else
// Must not be array value
setter("color",applyValue(color,value))},mapValueToVisual:function(value){var normalized=this._normalizeData(value),result=this._getSpecifiedVisual(value),visual=this.option.visual;return null==result&&(result=isCategory(this)?getVisualForCategory(this,visual,normalized):linearMapArray(normalized,[0,1],visual,!0)),result}}}function arrayGetByNormalizedValue(arr,normalized){return arr[Math.round(linearMapArray(normalized,[0,1],[0,arr.length-1],!0))]}function defaultApplyColor(value,getter,setter){setter("color",this.mapValueToVisual(value))}function getVisualForCategory(me,visual,normalized){return visual[me.option.loop&&normalized!==CATEGORY_DEFAULT_VISUAL_INDEX?normalized%visual.length:normalized]}function isCategory(me){return"category"===me.option.mappingMethod}/**
	 * @file Visual mapping.
	 */
var zrUtil=__webpack_require__(3),zrColor=__webpack_require__(38),linearMap=__webpack_require__(7).linearMap,each=zrUtil.each,isObject=zrUtil.isObject,CATEGORY_DEFAULT_VISUAL_INDEX=-1,VisualMapping=function(option){var mappingMethod=option.mappingMethod,visualType=option.type;/**
	         * @readOnly
	         * @type {string}
	         */
this.type=visualType,/**
	         * @readOnly
	         * @type {string}
	         */
this.mappingMethod=mappingMethod;/**
	         * @readOnly
	         * @type {Object}
	         */
var thisOption=this.option=zrUtil.clone(option);/**
	         * @private
	         * @type {Function}
	         */
this._normalizeData=normalizers[mappingMethod],/**
	         * @private
	         * @type {Function}
	         */
this._getSpecifiedVisual=zrUtil.bind(specifiedVisualGetters[mappingMethod],this,visualType),zrUtil.extend(this,visualHandlers[visualType]),"piecewise"===mappingMethod&&preprocessForPiecewise(thisOption),"category"===mappingMethod&&preprocessForCategory(thisOption)};VisualMapping.prototype={constructor:VisualMapping,applyVisual:null,isValueActive:null,mapValueToVisual:null,getNormalizer:function(){return zrUtil.bind(this._normalizeData,this)}};var visualHandlers=VisualMapping.visualHandlers={color:{applyVisual:defaultApplyColor,/**
	             * Create a mapper function
	             * @return {Function}
	             */
getColorMapper:function(){var visual=isCategory(this)?this.option.visual:zrUtil.map(this.option.visual,zrColor.parse);return zrUtil.bind(isCategory(this)?function(value,isNormalized){return!isNormalized&&(value=this._normalizeData(value)),getVisualForCategory(this,visual,value)}:function(value,isNormalized,out){
// If output rgb array
// which will be much faster and useful in pixel manipulation
var returnRGBArray=!!out;return!isNormalized&&(value=this._normalizeData(value)),out=zrColor.fastMapToColor(value,visual,out),returnRGBArray?out:zrUtil.stringify(out,"rgba")},this)},
// value:
// (1) {number}
// (2) {Array.<number>} Represents a interval, for colorStops.
// Return type:
// (1) {string} color value like '#444'
// (2) {Array.<Object>} colorStops,
// like [{color: '#fff', offset: 0}, {color: '#444', offset: 1}]
// where offset is between 0 and 1.
mapValueToVisual:function(value){var visual=this.option.visual;if(zrUtil.isArray(value))
// For creating gradient color list.
return value=[this._normalizeData(value[0]),this._normalizeData(value[1])],zrColor.mapIntervalToColor(value,visual);var normalized=this._normalizeData(value),result=this._getSpecifiedVisual(value);return null==result&&(result=isCategory(this)?getVisualForCategory(this,visual,normalized):zrColor.mapToColor(normalized,visual)),result}},colorHue:makePartialColorVisualHandler(function(color,value){return zrColor.modifyHSL(color,value)}),colorSaturation:makePartialColorVisualHandler(function(color,value){return zrColor.modifyHSL(color,null,value)}),colorLightness:makePartialColorVisualHandler(function(color,value){return zrColor.modifyHSL(color,null,null,value)}),colorAlpha:makePartialColorVisualHandler(function(color,value){return zrColor.modifyAlpha(color,value)}),opacity:{applyVisual:function(value,getter,setter){setter("opacity",this.mapValueToVisual(value))},mapValueToVisual:function(value){var normalized=this._normalizeData(value),result=this._getSpecifiedVisual(value),visual=this.option.visual;return null==result&&(result=isCategory(this)?getVisualForCategory(this,visual,normalized):linearMapArray(normalized,[0,1],visual,!0)),result}},symbol:{applyVisual:function(value,getter,setter){var symbolCfg=this.mapValueToVisual(value);if(zrUtil.isString(symbolCfg))setter("symbol",symbolCfg);else if(isObject(symbolCfg))for(var name in symbolCfg)symbolCfg.hasOwnProperty(name)&&setter(name,symbolCfg[name])},mapValueToVisual:function(value){var normalized=this._normalizeData(value),result=this._getSpecifiedVisual(value),visual=this.option.visual;return null==result&&(result=isCategory(this)?getVisualForCategory(this,visual,normalized):arrayGetByNormalizedValue(visual,normalized)||{}),result}},symbolSize:{applyVisual:function(value,getter,setter){setter("symbolSize",this.mapValueToVisual(value))},mapValueToVisual:function(value){var normalized=this._normalizeData(value),result=this._getSpecifiedVisual(value),visual=this.option.visual;return null==result&&(result=isCategory(this)?getVisualForCategory(this,visual,normalized):linearMapArray(normalized,[0,1],visual,!0)),result}}},normalizers={linear:function(value){return linearMapArray(value,this.option.dataExtent,[0,1],!0)},piecewise:function(value){var pieceList=this.option.pieceList,pieceIndex=VisualMapping.findPieceIndex(value,pieceList);return null!=pieceIndex?linearMapArray(pieceIndex,[0,pieceList.length-1],[0,1],!0):void 0},category:function(value){var index=this.option.categories?this.option.categoryMap[value]:value;// ordinal
return null==index?CATEGORY_DEFAULT_VISUAL_INDEX:index}},specifiedVisualGetters={
// Linear do not support this feature.
linear:zrUtil.noop,piecewise:function(visualType,value){var thisOption=this.option,pieceList=thisOption.pieceList;if(thisOption.hasSpecialVisual){var pieceIndex=VisualMapping.findPieceIndex(value,pieceList),piece=pieceList[pieceIndex];if(piece&&piece.visual)return piece.visual[visualType]}},
// Category do not need to support this feature.
// Visual can be set in visualMap.inRange or
// visualMap.outOfRange directly.
category:zrUtil.noop};/**
	     * @public
	     */
VisualMapping.addVisualHandler=function(name,handler){visualHandlers[name]=handler},/**
	     * @public
	     */
VisualMapping.isValidType=function(visualType){return visualHandlers.hasOwnProperty(visualType)},/**
	     * Convinent method.
	     * Visual can be Object or Array or primary type.
	     *
	     * @public
	     */
VisualMapping.eachVisual=function(visual,callback,context){zrUtil.isObject(visual)?zrUtil.each(visual,callback,context):callback.call(context,visual)},VisualMapping.mapVisual=function(visual,callback,context){var isPrimary,newVisual=zrUtil.isArray(visual)?[]:zrUtil.isObject(visual)?{}:(isPrimary=!0,null);return VisualMapping.eachVisual(visual,function(v,key){var newVal=callback.call(context,v,key);isPrimary?newVisual=newVal:newVisual[key]=newVal}),newVisual},/**
	     * @public
	     * @param {Object} obj
	     * @return {Oject} new object containers visual values.
	     *                 If no visuals, return null.
	     */
VisualMapping.retrieveVisuals=function(obj){var hasVisual,ret={};return obj&&each(visualHandlers,function(h,visualType){obj.hasOwnProperty(visualType)&&(ret[visualType]=obj[visualType],hasVisual=!0)}),hasVisual?ret:null},/**
	     * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
	     *
	     * @public
	     * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
	     *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
	     * @return {Array.<string>} Sorted visual types.
	     */
VisualMapping.prepareVisualTypes=function(visualTypes){if(isObject(visualTypes)){var types=[];each(visualTypes,function(item,type){types.push(type)}),visualTypes=types}else{if(!zrUtil.isArray(visualTypes))return[];visualTypes=visualTypes.slice()}return visualTypes.sort(function(type1,type2){
// color should be front of colorSaturation, colorAlpha, ...
// symbol and symbolSize do not matter.
return"color"===type2&&"color"!==type1&&0===type1.indexOf("color")?1:-1}),visualTypes},/**
	     * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
	     * Other visuals are only depends on themself.
	     *
	     * @public
	     * @param {string} visualType1
	     * @param {string} visualType2
	     * @return {boolean}
	     */
VisualMapping.dependsOn=function(visualType1,visualType2){return"color"===visualType2?!(!visualType1||0!==visualType1.indexOf(visualType2)):visualType1===visualType2},/**
	     * Clone a opacity visual mapping to color alpha color mapping.
	     *
	     * @public
	     * @param {module:echarts/visual/VisualMapping} opacityMapping
	     * @return {module:echarts/visual/VisualMapping} alphaMapping
	     */
VisualMapping.cloneOpacityToAlpha=function(opacityMapping){new VisualMapping({})},/**
	     * @public {Array.<Object>} [{value: ..., interval: [min, max]}, ...]
	     * @return {number} index
	     */
VisualMapping.findPieceIndex=function(value,pieceList){
// value has high priority.
for(var i=0,len=pieceList.length;len>i;i++){var piece=pieceList[i];if(null!=piece.value&&piece.value===value)return i}for(var i=0,len=pieceList.length;len>i;i++){var piece=pieceList[i],interval=piece.interval;if(interval)if(interval[0]===-(1/0)){if(value<interval[1])return i}else if(interval[1]===1/0){if(interval[0]<value)return i}else if(piece.interval[0]<=value&&value<=piece.interval[1])return i}},module.exports=VisualMapping},/* 188 */
/***/
function(module,exports,__webpack_require__){/**
	     * @public
	     */
function update(ecModel,api,payload){
// Layout result in each node:
// {x, y, width, height, area, borderWidth}
var condition={mainType:"series",subType:"treemap",query:payload};ecModel.eachComponent(condition,function(seriesModel){var ecWidth=api.getWidth(),ecHeight=api.getHeight(),seriesOption=seriesModel.option,size=seriesOption.size||[],containerWidth=parsePercent(retrieveValue(seriesOption.width,size[0]),ecWidth),containerHeight=parsePercent(retrieveValue(seriesOption.height,size[1]),ecHeight),layoutInfo=layout.getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()}),payloadType=payload&&payload.type,targetInfo=helper.retrieveTargetInfo(payload,seriesModel),rootRect="treemapRender"===payloadType||"treemapMove"===payloadType?payload.rootRect:null,viewRoot=seriesModel.getViewRoot();if("treemapMove"!==payloadType){var rootSize="treemapZoomToNode"===payloadType?estimateRootSize(seriesModel,targetInfo,viewRoot,containerWidth,containerHeight):rootRect?[rootRect.width,rootRect.height]:[containerWidth,containerHeight],sort=seriesOption.sort;sort&&"asc"!==sort&&"desc"!==sort&&(sort="desc");var options={squareRatio:seriesOption.squareRatio,sort:sort,leafDepth:seriesOption.leafDepth};viewRoot.setLayout({x:0,y:0,width:rootSize[0],height:rootSize[1],area:rootSize[0]*rootSize[1]}),squarify(viewRoot,options,!1,0)}
// Set root position
viewRoot.setLayout(calculateRootPosition(layoutInfo,rootRect,targetInfo),!0),seriesModel.setLayoutInfo(layoutInfo),
// Optimize
// FIXME
// 现在没有clip功能，暂时取ec高宽。
prunning(seriesModel.getData().tree.root,
// Transform to base element coordinate system.
new BoundingRect(-layoutInfo.x,-layoutInfo.y,ecWidth,ecHeight),helper.getPathToRoot(viewRoot))})}/**
	     * Layout treemap with squarify algorithm.
	     * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf
	     * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js
	     *
	     * @protected
	     * @param {module:echarts/data/Tree~TreeNode} node
	     * @param {Object} options
	     * @param {string} options.sort 'asc' or 'desc'
	     * @param {number} options.squareRatio
	     * @param {boolean} hideChildren
	     * @param {number} depth
	     */
function squarify(node,options,hideChildren,depth){var width,height;if(!node.isRemoved()){var thisLayout=node.getLayout();width=thisLayout.width,height=thisLayout.height;
// Considering border and gap
var itemStyleModel=node.getModel("itemStyle.normal"),borderWidth=itemStyleModel.get("borderWidth"),halfGapWidth=itemStyleModel.get("gapWidth")/2,layoutOffset=borderWidth-halfGapWidth,nodeModel=node.getModel();node.setLayout({borderWidth:borderWidth},!0),width=mathMax(width-2*layoutOffset,0),height=mathMax(height-2*layoutOffset,0);var totalArea=width*height,viewChildren=initChildren(node,nodeModel,totalArea,options,hideChildren,depth);if(viewChildren.length){var rect={x:layoutOffset,y:layoutOffset,width:width,height:height},rowFixedLength=mathMin(width,height),best=1/0,row=[];row.area=0;for(var i=0,len=viewChildren.length;len>i;){var child=viewChildren[i];row.push(child),row.area+=child.getLayout().area;var score=worst(row,rowFixedLength,options.squareRatio);
// continue with this orientation
best>=score?(i++,best=score):(row.area-=row.pop().getLayout().area,position(row,rowFixedLength,rect,halfGapWidth,!1),rowFixedLength=mathMin(rect.width,rect.height),row.length=row.area=0,best=1/0)}if(row.length&&position(row,rowFixedLength,rect,halfGapWidth,!0),!hideChildren){var childrenVisibleMin=nodeModel.get("childrenVisibleMin");null!=childrenVisibleMin&&childrenVisibleMin>totalArea&&(hideChildren=!0)}for(var i=0,len=viewChildren.length;len>i;i++)squarify(viewChildren[i],options,hideChildren,depth+1)}}}/**
	     * Set area to each child, and calculate data extent for visual coding.
	     */
function initChildren(node,nodeModel,totalArea,options,hideChildren,depth){var viewChildren=node.children||[],orderBy=options.sort;"asc"!==orderBy&&"desc"!==orderBy&&(orderBy=null);var overLeafDepth=null!=options.leafDepth&&options.leafDepth<=depth;
// leafDepth has higher priority.
if(hideChildren&&!overLeafDepth)return node.viewChildren=[];viewChildren=zrUtil.filter(viewChildren,function(child){return!child.isRemoved()}),sort(viewChildren,orderBy);var info=statistic(nodeModel,viewChildren,orderBy);if(0===info.sum)return node.viewChildren=[];if(info.sum=filterByThreshold(nodeModel,totalArea,info.sum,orderBy,viewChildren),0===info.sum)return node.viewChildren=[];
// Set area to each child.
for(var i=0,len=viewChildren.length;len>i;i++){var area=viewChildren[i].getValue()/info.sum*totalArea;
// Do not use setLayout({...}, true), because it is needed to clear last layout.
viewChildren[i].setLayout({area:area})}return overLeafDepth&&(viewChildren.length&&node.setLayout({isLeafRoot:!0},!0),viewChildren.length=0),node.viewChildren=viewChildren,node.setLayout({dataExtent:info.dataExtent},!0),viewChildren}/**
	     * Consider 'visibleMin'. Modify viewChildren and get new sum.
	     */
function filterByThreshold(nodeModel,totalArea,sum,orderBy,orderedChildren){
// visibleMin is not supported yet when no option.sort.
if(!orderBy)return sum;
// Always travel from little value to big value.
for(var visibleMin=nodeModel.get("visibleMin"),len=orderedChildren.length,deletePoint=len,i=len-1;i>=0;i--){var value=orderedChildren["asc"===orderBy?len-i-1:i].getValue();visibleMin>value/sum*totalArea&&(deletePoint=i,sum-=value)}return"asc"===orderBy?orderedChildren.splice(0,len-deletePoint):orderedChildren.splice(deletePoint,len-deletePoint),sum}/**
	     * Sort
	     */
function sort(viewChildren,orderBy){return orderBy&&viewChildren.sort(function(a,b){return"asc"===orderBy?a.getValue()-b.getValue():b.getValue()-a.getValue()}),viewChildren}/**
	     * Statistic
	     */
function statistic(nodeModel,children,orderBy){for(var sum=0,i=0,len=children.length;len>i;i++)sum+=children[i].getValue();
// Statistic data extent for latter visual coding.
// Notice: data extent should be calculate based on raw children
// but not filtered view children, otherwise visual mapping will not
// be stable when zoom (where children is filtered by visibleMin).
var dataExtent,dimension=nodeModel.get("visualDimension");
// The same as area dimension.
if(children&&children.length)if("value"===dimension&&orderBy)dataExtent=[children[children.length-1].getValue(),children[0].getValue()],"asc"===orderBy&&dataExtent.reverse();else{var dataExtent=[1/0,-(1/0)];zrUtil.each(children,function(child){var value=child.getValue(dimension);value<dataExtent[0]&&(dataExtent[0]=value),value>dataExtent[1]&&(dataExtent[1]=value)})}else dataExtent=[NaN,NaN];return{sum:sum,dataExtent:dataExtent}}/**
	     * Computes the score for the specified row,
	     * as the worst aspect ratio.
	     */
function worst(row,rowFixedLength,ratio){for(var area,areaMax=0,areaMin=1/0,i=0,len=row.length;len>i;i++)area=row[i].getLayout().area,area&&(areaMin>area&&(areaMin=area),area>areaMax&&(areaMax=area));var squareArea=row.area*row.area,f=rowFixedLength*rowFixedLength*ratio;return squareArea?mathMax(f*areaMax/squareArea,squareArea/(f*areaMin)):1/0}/**
	     * Positions the specified row of nodes. Modifies `rect`.
	     */
function position(row,rowFixedLength,rect,halfGapWidth,flush){
// When rowFixedLength === rect.width,
// it is horizontal subdivision,
// rowFixedLength is the width of the subdivision,
// rowOtherLength is the height of the subdivision,
// and nodes will be positioned from left to right.
// wh[idx0WhenH] means: when horizontal,
//      wh[idx0WhenH] => wh[0] => 'width'.
//      xy[idx1WhenH] => xy[1] => 'y'.
var idx0WhenH=rowFixedLength===rect.width?0:1,idx1WhenH=1-idx0WhenH,xy=["x","y"],wh=["width","height"],last=rect[xy[idx0WhenH]],rowOtherLength=rowFixedLength?row.area/rowFixedLength:0;(flush||rowOtherLength>rect[wh[idx1WhenH]])&&(rowOtherLength=rect[wh[idx1WhenH]]);for(var i=0,rowLen=row.length;rowLen>i;i++){var node=row[i],nodeLayout={},step=rowOtherLength?node.getLayout().area/rowOtherLength:0,wh1=nodeLayout[wh[idx1WhenH]]=mathMax(rowOtherLength-2*halfGapWidth,0),remain=rect[xy[idx0WhenH]]+rect[wh[idx0WhenH]]-last,modWH=i===rowLen-1||step>remain?remain:step,wh0=nodeLayout[wh[idx0WhenH]]=mathMax(modWH-2*halfGapWidth,0);nodeLayout[xy[idx1WhenH]]=rect[xy[idx1WhenH]]+mathMin(halfGapWidth,wh1/2),nodeLayout[xy[idx0WhenH]]=last+mathMin(halfGapWidth,wh0/2),last+=modWH,node.setLayout(nodeLayout,!0)}rect[xy[idx1WhenH]]+=rowOtherLength,rect[wh[idx1WhenH]]-=rowOtherLength}
// Return [containerWidth, containerHeight] as defualt.
function estimateRootSize(seriesModel,targetInfo,viewRoot,containerWidth,containerHeight){
// If targetInfo.node exists, we zoom to the node,
// so estimate whold width and heigth by target node.
var currNode=(targetInfo||{}).node,defaultSize=[containerWidth,containerHeight];if(!currNode||currNode===viewRoot)return defaultSize;for(var parent,viewArea=containerWidth*containerHeight,area=viewArea*seriesModel.option.zoomToNodeRatio;parent=currNode.parentNode;){for(var sum=0,siblings=parent.children,i=0,len=siblings.length;len>i;i++)sum+=siblings[i].getValue();var currNodeValue=currNode.getValue();if(0===currNodeValue)return defaultSize;area*=sum/currNodeValue;var borderWidth=parent.getModel("itemStyle.normal").get("borderWidth");isFinite(borderWidth)&&(
// Considering border, suppose aspect ratio is 1.
area+=4*borderWidth*borderWidth+4*borderWidth*Math.pow(area,.5)),area>numberUtil.MAX_SAFE_INTEGER&&(area=numberUtil.MAX_SAFE_INTEGER),currNode=parent}viewArea>area&&(area=viewArea);var scale=Math.pow(area/viewArea,.5);return[containerWidth*scale,containerHeight*scale]}
// Root postion base on coord of containerGroup
function calculateRootPosition(layoutInfo,rootRect,targetInfo){if(rootRect)return{x:rootRect.x,y:rootRect.y};var defaultPosition={x:0,y:0};if(!targetInfo)return defaultPosition;
// If targetInfo is fetched by 'retrieveTargetInfo',
// old tree and new tree are the same tree,
// so the node still exists and we can visit it.
var targetNode=targetInfo.node,layout=targetNode.getLayout();if(!layout)return defaultPosition;for(
// Transform coord from local to container.
var targetCenter=[layout.width/2,layout.height/2],node=targetNode;node;){var nodeLayout=node.getLayout();targetCenter[0]+=nodeLayout.x,targetCenter[1]+=nodeLayout.y,node=node.parentNode}return{x:layoutInfo.width/2-targetCenter[0],y:layoutInfo.height/2-targetCenter[1]}}
// Mark invisible nodes for prunning when visual coding and rendering.
// Prunning depends on layout and root position, so we have to do it after them.
function prunning(node,clipRect,viewPath){var nodeLayout=node.getLayout();node.setLayout({invisible:nodeLayout?!clipRect.intersect(nodeLayout):!helper.aboveViewRootByViewPath(viewPath,node)},!0);for(var viewChildren=node.viewChildren||[],i=0,len=viewChildren.length;len>i;i++){
// Transform to child coordinate.
var childClipRect=new BoundingRect(clipRect.x-nodeLayout.x,clipRect.y-nodeLayout.y,clipRect.width,clipRect.height);prunning(viewChildren[i],childClipRect,viewPath)}}var mathMax=Math.max,mathMin=Math.min,zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),layout=__webpack_require__(21),helper=__webpack_require__(181),parsePercent=numberUtil.parsePercent,retrieveValue=zrUtil.retrieve,BoundingRect=__webpack_require__(15),helper=__webpack_require__(181);module.exports=update},/* 189 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1),zrUtil=__webpack_require__(3);__webpack_require__(190),__webpack_require__(193),__webpack_require__(197),echarts.registerProcessor("filter",__webpack_require__(198)),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(103),"graph","circle",null)),echarts.registerVisualCoding("chart",__webpack_require__(199)),echarts.registerLayout(__webpack_require__(200)),echarts.registerLayout(__webpack_require__(202)),echarts.registerLayout(__webpack_require__(204)),
// Graph view coordinate system
echarts.registerCoordinateSystem("graphView",{create:__webpack_require__(206)})},/* 190 */
/***/
function(module,exports,__webpack_require__){"use strict";var List=__webpack_require__(94),zrUtil=__webpack_require__(3),createGraphFromNodeEdge=__webpack_require__(191),GraphSeries=__webpack_require__(1).extendSeriesModel({type:"series.graph",init:function(option){GraphSeries.superApply(this,"init",arguments),
// Provide data for legend select
this.legendDataProvider=function(){return this._categoriesData},this._updateCategoriesData()},mergeOption:function(option){GraphSeries.superApply(this,"mergeOption",arguments),this._updateCategoriesData()},getInitialData:function(option,ecModel){var edges=option.edges||option.links,nodes=option.data||option.nodes;if(nodes&&edges){var graph=createGraphFromNodeEdge(nodes,edges,this,!0),list=graph.data,self=this;
// Overwrite list.getItemModel to
return list.wrapMethod("getItemModel",function(model){var categoriesModels=self._categoriesModels,categoryIdx=model.getShallow("category"),categoryModel=categoriesModels[categoryIdx];return categoryModel&&(categoryModel.parentModel=model.parentModel,model.parentModel=categoryModel),model}),list}},restoreData:function(){GraphSeries.superApply(this,"restoreData",arguments),this.getGraph().restoreData()},/**
	         * @return {module:echarts/data/Graph}
	         */
getGraph:function(){return this.getData().graph},/**
	         * @return {module:echarts/data/List}
	         */
getEdgeData:function(){return this.getGraph().edgeData},/**
	         * @return {module:echarts/data/List}
	         */
getCategoriesData:function(){return this._categoriesData},_updateCategoriesData:function(){var categories=zrUtil.map(this.option.categories||[],function(category){
// Data must has value
return null!=category.value?category:zrUtil.extend({value:0},category)}),categoriesData=new List(["value"],this);categoriesData.initData(categories),this._categoriesData=categoriesData,this._categoriesModels=categoriesData.mapArray(function(idx){return categoriesData.getItemModel(idx,!0)})},/**
	         * @param {number} zoom
	         */
setRoamZoom:function(zoom){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.zoom=zoom)},/**
	         * @param {number} x
	         * @param {number} y
	         */
setRoamPan:function(x,y){var roamDetail=this.option.roamDetail;roamDetail&&(roamDetail.x=x,roamDetail.y=y)},defaultOption:{zlevel:0,z:2,color:["#61a0a8","#d14a61","#fd9c35","#675bba","#fec42c","#dd4444","#fd9c35","#cd4870"],coordinateSystem:"view",legendHoverLink:!0,hoverAnimation:!0,layout:null,
// Configuration of force
force:{initLayout:null,repulsion:50,gravity:.1,edgeLength:30,layoutAnimation:!0},left:"center",top:"center",
// right: null,
// bottom: null,
// width: '80%',
// height: '80%',
symbol:"circle",symbolSize:10,draggable:!1,roam:!1,roamDetail:{x:0,y:0,zoom:1},
// Symbol size scale ratio in roam
nodeScaleRatio:.6,
// Line width scale ratio in roam
// edgeScaleRatio: 0.1,
// categories: [],
// data: []
// Or
// nodes: []
//
// links: []
// Or
// edges: []
label:{normal:{show:!1},emphasis:{show:!0}},itemStyle:{normal:{},emphasis:{}},lineStyle:{normal:{color:"#aaa",width:1,curveness:0,opacity:.5},emphasis:{}}}});module.exports=GraphSeries},/* 191 */
/***/
function(module,exports,__webpack_require__){var List=__webpack_require__(94),Graph=__webpack_require__(192),linkList=__webpack_require__(180),completeDimensions=__webpack_require__(96),zrUtil=__webpack_require__(3);module.exports=function(nodes,edges,hostModel,directed){for(var graph=new Graph(directed),i=0;i<nodes.length;i++)graph.addNode(zrUtil.retrieve(
// Id, name, dataIndex
nodes[i].id,nodes[i].name,i),i);for(var linkNameList=[],validEdges=[],i=0;i<edges.length;i++){var link=edges[i];
// addEdge may fail when source or target not exists
graph.addEdge(link.source,link.target,i)&&(validEdges.push(link),linkNameList.push(zrUtil.retrieve(link.id,link.source+" - "+link.target)))}
// FIXME
var dimensionNames=completeDimensions(["value"],nodes),nodeData=new List(dimensionNames,hostModel),edgeData=new List(["value"],hostModel);
// Update dataIndex of nodes and edges because invalid edge may be removed
return nodeData.initData(nodes),edgeData.initData(validEdges,linkNameList),graph.setEdgeData(edgeData),linkList.linkToGraph(nodeData,graph),graph.update(),graph}},/* 192 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	     * @alias module:echarts/data/Graph.Node
	     */
function Node(id,dataIndex){/**
	        * @type {string}
	        */
this.id=null==id?"":id,/**
	        * @type {Array.<module:echarts/data/Graph.Edge>}
	        */
this.inEdges=[],/**
	        * @type {Array.<module:echarts/data/Graph.Edge>}
	        */
this.outEdges=[],/**
	        * @type {Array.<module:echarts/data/Graph.Edge>}
	        */
this.edges=[],/**
	         * @type {module:echarts/data/Graph}
	         */
this.hostGraph,/**
	         * @type {number}
	         */
this.dataIndex=null==dataIndex?-1:dataIndex}/**
	     * 图边
	     * @alias module:echarts/data/Graph.Edge
	     * @param {module:echarts/data/Graph.Node} n1
	     * @param {module:echarts/data/Graph.Node} n2
	     * @param {number} [dataIndex=-1]
	     */
function Edge(n1,n2,dataIndex){/**
	         * 节点1，如果是有向图则为源节点
	         * @type {module:echarts/data/Graph.Node}
	         */
this.node1=n1,/**
	         * 节点2，如果是有向图则为目标节点
	         * @type {module:echarts/data/Graph.Node}
	         */
this.node2=n2,this.dataIndex=null==dataIndex?-1:dataIndex}/**
	 * Graph data structure
	 *
	 * @module echarts/data/Graph
	 * @author Yi Shen(https://www.github.com/pissang)
	 */
var zrUtil=__webpack_require__(3),Graph=function(directed){/**
	         * 是否是有向图
	         * @type {boolean}
	         * @private
	         */
this._directed=directed||!1,/**
	         * @type {Array.<module:echarts/data/Graph.Node>}
	         * @readOnly
	         */
this.nodes=[],/**
	         * @type {Array.<module:echarts/data/Graph.Edge>}
	         * @readOnly
	         */
this.edges=[],/**
	         * @type {Object.<string, module:echarts/data/Graph.Node>}
	         * @private
	         */
this._nodesMap={},/**
	         * @type {Object.<string, module:echarts/data/Graph.Edge>}
	         * @private
	         */
this._edgesMap={},/**
	         * @type {module:echarts/data/List}
	         * @readOnly
	         */
this.data,/**
	         * @type {module:echarts/data/List}
	         * @readOnly
	         */
this.edgeData},graphProto=Graph.prototype;/**
	     * @type {string}
	     */
graphProto.type="graph",/**
	     * If is directed graph
	     * @return {boolean}
	     */
graphProto.isDirected=function(){return this._directed},/**
	     * Add a new node
	     * @param {string} id
	     * @param {number} [dataIndex]
	     */
graphProto.addNode=function(id,dataIndex){var nodesMap=this._nodesMap;if(!nodesMap[id]){var node=new Node(id,dataIndex);return node.hostGraph=this,this.nodes.push(node),nodesMap[id]=node,node}},/**
	     * Get node by data index
	     * @param  {number} dataIndex
	     * @return {module:echarts/data/Graph~Node}
	     */
graphProto.getNodeByIndex=function(dataIndex){var rawIdx=this.data.getRawIndex(dataIndex);return this.nodes[rawIdx]},/**
	     * Get node by id
	     * @param  {string} id
	     * @return {module:echarts/data/Graph.Node}
	     */
graphProto.getNodeById=function(id){return this._nodesMap[id]},/**
	     * Add a new edge
	     * @param {string|module:echarts/data/Graph.Node} n1
	     * @param {string|module:echarts/data/Graph.Node} n2
	     * @param {number} [dataIndex=-1]
	     * @return {module:echarts/data/Graph.Edge}
	     */
graphProto.addEdge=function(n1,n2,dataIndex){var nodesMap=this._nodesMap,edgesMap=this._edgesMap;if(n1 instanceof Node||(n1=nodesMap[n1]),n2 instanceof Node||(n2=nodesMap[n2]),n1&&n2){var key=n1.id+"-"+n2.id;
// PENDING
if(!edgesMap[key]){var edge=new Edge(n1,n2,dataIndex);return edge.hostGraph=this,this._directed&&(n1.outEdges.push(edge),n2.inEdges.push(edge)),n1.edges.push(edge),n1!==n2&&n2.edges.push(edge),this.edges.push(edge),edgesMap[key]=edge,edge}}},/**
	     * Get edge by data index
	     * @param  {number} dataIndex
	     * @return {module:echarts/data/Graph~Node}
	     */
graphProto.getEdgeByIndex=function(dataIndex){var rawIdx=this.edgeData.getRawIndex(dataIndex);return this.edges[rawIdx]},/**
	     * Get edge by two linked nodes
	     * @param  {module:echarts/data/Graph.Node|string} n1
	     * @param  {module:echarts/data/Graph.Node|string} n2
	     * @return {module:echarts/data/Graph.Edge}
	     */
graphProto.getEdge=function(n1,n2){n1 instanceof Node&&(n1=n1.id),n2 instanceof Node&&(n2=n2.id);var edgesMap=this._edgesMap;return this._directed?edgesMap[n1+"-"+n2]:edgesMap[n1+"-"+n2]||edgesMap[n2+"-"+n1]},/**
	     * Iterate all nodes
	     * @param  {Function} cb
	     * @param  {*} [context]
	     */
graphProto.eachNode=function(cb,context){for(var nodes=this.nodes,len=nodes.length,i=0;len>i;i++)nodes[i].dataIndex>=0&&cb.call(context,nodes[i],i)},/**
	     * Iterate all edges
	     * @param  {Function} cb
	     * @param  {*} [context]
	     */
graphProto.eachEdge=function(cb,context){for(var edges=this.edges,len=edges.length,i=0;len>i;i++)edges[i].dataIndex>=0&&edges[i].node1.dataIndex>=0&&edges[i].node2.dataIndex>=0&&cb.call(context,edges[i],i)},/**
	     * Breadth first traverse
	     * @param {Function} cb
	     * @param {module:echarts/data/Graph.Node} startNode
	     * @param {string} [direction='none'] 'none'|'in'|'out'
	     * @param {*} [context]
	     */
graphProto.breadthFirstTraverse=function(cb,startNode,direction,context){if(startNode instanceof Node||(startNode=this._nodesMap[startNode]),startNode){for(var edgeType="out"===direction?"outEdges":"in"===direction?"inEdges":"edges",i=0;i<this.nodes.length;i++)this.nodes[i].__visited=!1;if(!cb.call(context,startNode,null))for(var queue=[startNode];queue.length;)for(var currentNode=queue.shift(),edges=currentNode[edgeType],i=0;i<edges.length;i++){var e=edges[i],otherNode=e.node1===currentNode?e.node2:e.node1;if(!otherNode.__visited){if(cb.call(otherNode,otherNode,currentNode))
// Stop traversing
return;queue.push(otherNode),otherNode.__visited=!0}}}},
// TODO
// graphProto.depthFirstTraverse = function (
//     cb, startNode, direction, context
// ) {
// };
// Filter update
graphProto.update=function(){for(var data=this.data,edgeData=this.edgeData,nodes=this.nodes,edges=this.edges,i=0,len=nodes.length;len>i;i++)nodes[i].dataIndex=-1;for(var i=0,len=data.count();len>i;i++)nodes[data.getRawIndex(i)].dataIndex=i;edgeData.filterSelf(function(idx){var edge=edges[edgeData.getRawIndex(idx)];return edge.node1.dataIndex>=0&&edge.node2.dataIndex>=0});
// Update edge
for(var i=0,len=edges.length;len>i;i++)edges[i].dataIndex=-1;for(var i=0,len=edgeData.count();len>i;i++)edges[edgeData.getRawIndex(i)].dataIndex=i},/**
	     * Set edge data
	     * @param {module:echarts/data/List} edgeData
	     */
graphProto.setEdgeData=function(edgeData){this.edgeData=edgeData,this._edgeDataSaved=edgeData.cloneShallow()},graphProto.restoreData=function(){this.edgeData=this._edgeDataSaved.cloneShallow()},/**
	     * @return {module:echarts/data/Graph}
	     */
graphProto.clone=function(){for(var graph=new Graph(this._directed),nodes=this.nodes,edges=this.edges,i=0;i<nodes.length;i++)graph.addNode(nodes[i].id,nodes[i].dataIndex);for(var i=0;i<edges.length;i++){var e=edges[i];graph.addEdge(e.node1.id,e.node2.id,e.dataIndex)}return graph},Node.prototype={constructor:Node,/**
	         * @return {number}
	         */
degree:function(){return this.edges.length},/**
	         * @return {number}
	         */
inDegree:function(){return this.inEdges.length},/**
	        * @return {number}
	        */
outDegree:function(){return this.outEdges.length},/**
	         * @param {string} [path]
	         * @return {module:echarts/model/Model}
	         */
getModel:function(path){if(!(this.dataIndex<0)){var graph=this.hostGraph,itemModel=graph.data.getItemModel(this.dataIndex);return itemModel.getModel(path)}}},/**
	     * @param {string} [path]
	     * @return {module:echarts/model/Model}
	     */
Edge.prototype.getModel=function(path){if(!(this.dataIndex<0)){var graph=this.hostGraph,itemModel=graph.edgeData.getItemModel(this.dataIndex);return itemModel.getModel(path)}};var createGraphDataProxyMixin=function(hostName,dataName){return{/**
	             * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
	             * @return {number}
	             */
getValue:function(dimension){var data=this[hostName][dataName];return data.get(data.getDimension(dimension||"value"),this.dataIndex)},/**
	             * @param {Object|string} key
	             * @param {*} [value]
	             */
setVisual:function(key,value){this.dataIndex>=0&&this[hostName][dataName].setItemVisual(this.dataIndex,key,value)},/**
	             * @param {string} key
	             * @return {boolean}
	             */
getVisual:function(key,ignoreParent){return this[hostName][dataName].getItemVisual(this.dataIndex,key,ignoreParent)},/**
	             * @param {Object} layout
	             * @return {boolean} [merge=false]
	             */
setLayout:function(layout,merge){this.dataIndex>=0&&this[hostName][dataName].setItemLayout(this.dataIndex,layout,merge)},/**
	             * @return {Object}
	             */
getLayout:function(){return this[hostName][dataName].getItemLayout(this.dataIndex)},/**
	             * @return {module:zrender/Element}
	             */
getGraphicEl:function(){return this[hostName][dataName].getItemGraphicEl(this.dataIndex)},/**
	             * @return {number}
	             */
getRawIndex:function(){return this[hostName][dataName].getRawIndex(this.dataIndex)}}};zrUtil.mixin(Node,createGraphDataProxyMixin("hostGraph","data")),zrUtil.mixin(Edge,createGraphDataProxyMixin("hostGraph","edgeData")),Graph.Node=Node,Graph.Edge=Edge,module.exports=Graph},/* 193 */
/***/
function(module,exports,__webpack_require__){var SymbolDraw=__webpack_require__(98),LineDraw=__webpack_require__(194),RoamController=__webpack_require__(159),modelUtil=__webpack_require__(5),graphic=__webpack_require__(42);__webpack_require__(1).extendChartView({type:"graph",init:function(ecModel,api){var symbolDraw=new SymbolDraw,lineDraw=new LineDraw,group=this.group,controller=new RoamController(api.getZr(),group);group.add(symbolDraw.group),group.add(lineDraw.group),this._symbolDraw=symbolDraw,this._lineDraw=lineDraw,this._controller=controller,this._firstRender=!0},render:function(seriesModel,ecModel,api){var coordSys=seriesModel.coordinateSystem;
// Only support view and geo coordinate system
if("geo"===coordSys.type||"view"===coordSys.type){var data=seriesModel.getData();this._model=seriesModel;var symbolDraw=this._symbolDraw,lineDraw=this._lineDraw;symbolDraw.updateData(data);var edgeData=data.graph.edgeData,rawOption=seriesModel.option,formatModel=modelUtil.createDataFormatModel(seriesModel,edgeData,rawOption.edges||rawOption.links);formatModel.formatTooltip=function(dataIndex){var params=this.getDataParams(dataIndex),edge=data.graph.getEdgeByIndex(dataIndex),sourceName=data.getName(edge.node1.dataIndex),targetName=data.getName(edge.node2.dataIndex),html=sourceName+" > "+targetName;return params.value&&(html+=" : "+params.value),html},lineDraw.updateData(edgeData,null,null),edgeData.eachItemGraphicEl(function(el){el.traverse(function(child){child.dataModel=formatModel})});
// Save the original lineWidth
// data.graph.eachEdge(function (edge) {
//     edge.__lineWidth = edge.getModel('lineStyle.normal').get('width');
// });
var group=this.group,groupNewProp={position:coordSys.position,scale:coordSys.scale};this._firstRender?group.attr(groupNewProp):graphic.updateProps(group,groupNewProp,seriesModel),this._nodeScaleRatio=seriesModel.get("nodeScaleRatio"),
// this._edgeScaleRatio = seriesModel.get('edgeScaleRatio');
this._updateNodeAndLinkScale(),this._updateController(seriesModel,coordSys,api),clearTimeout(this._layoutTimeout);var forceLayout=seriesModel.forceLayout,layoutAnimation=seriesModel.get("force.layoutAnimation");forceLayout&&this._startForceLayoutIteration(forceLayout,layoutAnimation),
// Update draggable
data.eachItemGraphicEl(function(el,idx){var draggable=data.getItemModel(idx).get("draggable");draggable&&forceLayout?el.on("drag",function(){forceLayout.warmUp(),!this._layouting&&this._startForceLayoutIteration(forceLayout,layoutAnimation),forceLayout.setFixed(idx),
// Write position back to layout
data.setItemLayout(idx,el.position)},this).on("dragend",function(){forceLayout.setUnfixed(idx)},this):el.off("drag"),el.setDraggable(draggable)},this),this._firstRender=!1}},_startForceLayoutIteration:function(forceLayout,layoutAnimation){var self=this;!function step(){forceLayout.step(function(stopped){self.updateLayout(),(self._layouting=!stopped)&&(layoutAnimation?self._layoutTimeout=setTimeout(step,16):step())})}()},_updateController:function(seriesModel,coordSys,api){var controller=this._controller;controller.rect=coordSys.getViewRect(),controller.enable(seriesModel.get("roam")),controller.off("pan").off("zoom").on("pan",function(dx,dy){api.dispatchAction({seriesId:seriesModel.id,type:"graphRoam",dx:dx,dy:dy})}).on("zoom",function(zoom,mouseX,mouseY){api.dispatchAction({seriesId:seriesModel.id,type:"graphRoam",zoom:zoom,originX:mouseX,originY:mouseY})}).on("zoom",this._updateNodeAndLinkScale,this)},_updateNodeAndLinkScale:function(){var seriesModel=this._model,data=seriesModel.getData(),group=this.group,nodeScaleRatio=this._nodeScaleRatio,groupScale=group.scale[0],nodeScale=(groupScale-1)*nodeScaleRatio+1,invScale=[nodeScale/groupScale,nodeScale/groupScale];data.eachItemGraphicEl(function(el,idx){el.attr("scale",invScale)})},updateLayout:function(seriesModel,ecModel){this._symbolDraw.updateLayout(),this._lineDraw.updateLayout()},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove(),this._lineDraw&&this._lineDraw.remove()}})},/* 194 */
/***/
function(module,exports,__webpack_require__){/**
	     * @alias module:echarts/component/marker/LineDraw
	     * @constructor
	     */
function LineDraw(ctor){this._ctor=ctor||LineGroup,this.group=new graphic.Group}/**
	 * @module echarts/chart/helper/LineDraw
	 */
var graphic=__webpack_require__(42),LineGroup=__webpack_require__(195),lineDrawProto=LineDraw.prototype;/**
	     * @param {module:echarts/data/List} lineData
	     * @param {module:echarts/data/List} [fromData]
	     * @param {module:echarts/data/List} [toData]
	     */
lineDrawProto.updateData=function(lineData,fromData,toData){var oldLineData=this._lineData,group=this.group,LineCtor=this._ctor;lineData.diff(oldLineData).add(function(idx){var lineGroup=new LineCtor(lineData,fromData,toData,idx);lineData.setItemGraphicEl(idx,lineGroup),group.add(lineGroup)}).update(function(newIdx,oldIdx){var lineGroup=oldLineData.getItemGraphicEl(oldIdx);lineGroup.updateData(lineData,fromData,toData,newIdx),lineData.setItemGraphicEl(newIdx,lineGroup),group.add(lineGroup)}).remove(function(idx){group.remove(oldLineData.getItemGraphicEl(idx))}).execute(),this._lineData=lineData,this._fromData=fromData,this._toData=toData},lineDrawProto.updateLayout=function(){var lineData=this._lineData;lineData.eachItemGraphicEl(function(el,idx){el.updateLayout(lineData,this._fromData,this._toData,idx)},this)},lineDrawProto.remove=function(){this.group.removeAll()},module.exports=LineDraw},/* 195 */
/***/
function(module,exports,__webpack_require__){/**
	     * @inner
	     */
function createSymbol(name,data,idx){var color=data.getItemVisual(idx,"color"),symbolType=data.getItemVisual(idx,"symbol"),symbolSize=data.getItemVisual(idx,"symbolSize");if("none"!==symbolType){zrUtil.isArray(symbolSize)||(symbolSize=[symbolSize,symbolSize]);var symbolPath=symbolUtil.createSymbol(symbolType,-symbolSize[0]/2,-symbolSize[1]/2,symbolSize[0],symbolSize[1],color);return symbolPath.name=name,symbolPath}}function createLine(points){var line=new LinePath({name:"line",style:{strokeNoScale:!0}});return setLinePoints(line.shape,points),line}function setLinePoints(targetShape,points){var p1=points[0],p2=points[1],cp1=points[2];targetShape.x1=p1[0],targetShape.y1=p1[1],targetShape.x2=p2[0],targetShape.y2=p2[1],targetShape.percent=1,cp1&&(targetShape.cpx1=cp1[0],targetShape.cpy1=cp1[1])}function isSymbolArrow(symbol){return"symbol"===symbol.type&&"arrow"===symbol.shape.symbolType}function updateSymbolBeforeLineUpdate(){var lineGroup=this,line=lineGroup.childOfName("line");
// If line not changed
if(this.__dirty||line.__dirty){var symbolFrom=lineGroup.childOfName("fromSymbol"),symbolTo=lineGroup.childOfName("toSymbol"),label=lineGroup.childOfName("label"),fromPos=line.pointAt(0),toPos=line.pointAt(line.shape.percent),d=vector.sub([],toPos,fromPos);vector.normalize(d,d),symbolFrom&&(symbolFrom.attr("position",fromPos),
// Rotate the arrow
// FIXME Hard coded ?
isSymbolArrow(symbolFrom)&&symbolFrom.attr("rotation",tangentRotation(toPos,fromPos))),symbolTo&&(symbolTo.attr("position",toPos),isSymbolArrow(symbolTo)&&symbolTo.attr("rotation",tangentRotation(fromPos,toPos))),label.attr("position",toPos);var textPosition,textAlign,textVerticalAlign;
// End
"end"===label.__position?(textPosition=[5*d[0]+toPos[0],5*d[1]+toPos[1]],textAlign=d[0]>.8?"left":d[0]<-.8?"right":"center",textVerticalAlign=d[1]>.8?"top":d[1]<-.8?"bottom":"middle"):(textPosition=[5*-d[0]+fromPos[0],5*-d[1]+fromPos[1]],textAlign=d[0]>.8?"right":d[0]<-.8?"left":"center",textVerticalAlign=d[1]>.8?"bottom":d[1]<-.8?"top":"middle"),label.attr({style:{
// Use the user specified text align and baseline first
textVerticalAlign:label.__verticalAlign||textVerticalAlign,textAlign:label.__textAlign||textAlign},position:textPosition})}}function tangentRotation(p1,p2){return-Math.PI/2-Math.atan2(p2[1]-p1[1],p2[0]-p1[0])}/**
	     * @constructor
	     * @extends {module:zrender/graphic/Group}
	     * @alias {module:echarts/chart/helper/Line}
	     */
function Line(lineData,fromData,toData,idx){graphic.Group.call(this),this._createLine(lineData,fromData,toData,idx)}/**
	 * @module echarts/chart/helper/Line
	 */
var symbolUtil=__webpack_require__(100),vector=__webpack_require__(16),LinePath=__webpack_require__(196),graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),lineProto=Line.prototype;
// Update symbol position and rotation
lineProto.beforeUpdate=updateSymbolBeforeLineUpdate,lineProto._createLine=function(lineData,fromData,toData,idx){var seriesModel=lineData.hostModel,linePoints=lineData.getItemLayout(idx),line=createLine(linePoints);line.shape.percent=0,graphic.initProps(line,{shape:{percent:1}},seriesModel),this.add(line);var label=new graphic.Text({name:"label"});if(this.add(label),fromData){var symbolFrom=createSymbol("fromSymbol",fromData,idx);
// symbols must added after line to make sure
// it will be updated after line#update.
// Or symbol position and rotation update in line#beforeUpdate will be one frame slow
this.add(symbolFrom),this._fromSymbolType=fromData.getItemVisual(idx,"symbol")}if(toData){var symbolTo=createSymbol("toSymbol",toData,idx);this.add(symbolTo),this._toSymbolType=toData.getItemVisual(idx,"symbol")}this._updateCommonStl(lineData,fromData,toData,idx)},lineProto.updateData=function(lineData,fromData,toData,idx){var seriesModel=lineData.hostModel,line=this.childOfName("line"),linePoints=lineData.getItemLayout(idx),target={shape:{}};
// Symbol changed
if(setLinePoints(target.shape,linePoints),graphic.updateProps(line,target,seriesModel),fromData){var fromSymbolType=fromData.getItemVisual(idx,"symbol");if(this._fromSymbolType!==fromSymbolType){var symbolFrom=createSymbol("fromSymbol",fromData,idx);this.remove(this.childOfName("fromSymbol")),this.add(symbolFrom)}this._fromSymbolType=fromSymbolType}if(toData){var toSymbolType=toData.getItemVisual(idx,"symbol");
// Symbol changed
if(toSymbolType!==this._toSymbolType){var symbolTo=createSymbol("toSymbol",toData,idx);this.remove(this.childOfName("toSymbol")),this.add(symbolTo)}this._toSymbolType=toSymbolType}this._updateCommonStl(lineData,fromData,toData,idx)},lineProto._updateCommonStl=function(lineData,fromData,toData,idx){var seriesModel=lineData.hostModel,line=this.childOfName("line"),itemModel=lineData.getItemModel(idx),labelModel=itemModel.getModel("label.normal"),textStyleModel=labelModel.getModel("textStyle"),labelHoverModel=itemModel.getModel("label.emphasis"),textStyleHoverModel=labelHoverModel.getModel("textStyle"),defaultText=numberUtil.round(seriesModel.getRawValue(idx));isNaN(defaultText)&&(
// Use name
defaultText=lineData.getName(idx)),line.setStyle(zrUtil.extend({stroke:lineData.getItemVisual(idx,"color")},itemModel.getModel("lineStyle.normal").getLineStyle()));var label=this.childOfName("label");label.setStyle({text:labelModel.get("show")?zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"normal"),defaultText):"",textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor()||lineData.getItemVisual(idx,"color")}),label.hoverStyle={text:labelHoverModel.get("show")?zrUtil.retrieve(seriesModel.getFormattedLabel(idx,"emphasis"),defaultText):"",textFont:textStyleHoverModel.getFont(),fill:textStyleHoverModel.getTextColor()},label.__textAlign=textStyleModel.get("align"),label.__verticalAlign=textStyleModel.get("baseline"),label.__position=labelModel.get("position"),graphic.setHoverStyle(this,itemModel.getModel("lineStyle.emphasis").getLineStyle())},lineProto.updateLayout=function(lineData,fromData,toData,idx){var points=lineData.getItemLayout(idx),linePath=this.childOfName("line");setLinePoints(linePath.shape,points),linePath.dirty(!0)},zrUtil.inherits(Line,graphic.Group),module.exports=Line},/* 196 */
/***/
function(module,exports,__webpack_require__){/**
	 * Line path for bezier and straight line draw
	 */
var graphic=__webpack_require__(42),straightLineProto=graphic.Line.prototype,bezierCurveProto=graphic.BezierCurve.prototype;module.exports=graphic.extendShape({type:"ec-line",style:{stroke:"#000",fill:null},shape:{x1:0,y1:0,x2:0,y2:0,percent:1,cpx1:null,cpy1:null},buildPath:function(ctx,shape){(null==shape.cpx1||null==shape.cpy1?straightLineProto:bezierCurveProto).buildPath(ctx,shape)},pointAt:function(t){var shape=this.shape;return null==shape.cpx1||null==shape.cpy1?straightLineProto.pointAt.call(this,t):bezierCurveProto.pointAt.call(this,t)}})},/* 197 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1),roamHelper=__webpack_require__(162),actionInfo={type:"graphRoam",event:"graphRoam",update:"none"};/**
	     * @payload
	     * @property {string} name Series name
	     * @property {number} [dx]
	     * @property {number} [dy]
	     * @property {number} [zoom]
	     * @property {number} [originX]
	     * @property {number} [originY]
	     */
echarts.registerAction(actionInfo,function(payload,ecModel){ecModel.eachComponent({mainType:"series",query:payload},function(seriesModel){var coordSys=seriesModel.coordinateSystem,roamDetailModel=seriesModel.getModel("roamDetail"),res=roamHelper.calcPanAndZoom(roamDetailModel,payload);seriesModel.setRoamPan&&seriesModel.setRoamPan(res.x,res.y),seriesModel.setRoamZoom&&seriesModel.setRoamZoom(res.zoom),coordSys&&coordSys.setPan(res.x,res.y),coordSys&&coordSys.setZoom(res.zoom)})})},/* 198 */
/***/
function(module,exports){module.exports=function(ecModel){var legendModels=ecModel.findComponents({mainType:"legend"});legendModels&&legendModels.length&&ecModel.eachSeriesByType("graph",function(graphSeries){var categoriesData=graphSeries.getCategoriesData(),graph=graphSeries.getGraph(),data=graph.data,categoryNames=categoriesData.mapArray(categoriesData.getName);data.filterSelf(function(idx){var model=data.getItemModel(idx),category=model.getShallow("category");if(null!=category){"number"==typeof category&&(category=categoryNames[category]);
// If in any legend component the status is not selected.
for(var i=0;i<legendModels.length;i++)if(!legendModels[i].isSelected(category))return!1}return!0})},this)}},/* 199 */
/***/
function(module,exports){module.exports=function(ecModel){ecModel.eachSeriesByType("graph",function(seriesModel){var colorList=seriesModel.get("color"),categoriesData=seriesModel.getCategoriesData(),data=seriesModel.getData(),categoryNameIdxMap={};categoriesData.each(function(idx){categoryNameIdxMap[categoriesData.getName(idx)]=idx;var itemModel=categoriesData.getItemModel(idx),rawIdx=categoriesData.getRawIndex(idx),color=itemModel.get("itemStyle.normal.color")||colorList[rawIdx%colorList.length];categoriesData.setItemVisual(idx,"color",color)}),
// Assign category color to visual
categoriesData.count()&&data.each(function(idx){var model=data.getItemModel(idx),category=model.getShallow("category");null!=category&&("string"==typeof category&&(category=categoryNameIdxMap[category]),data.setItemVisual(idx,"color",categoriesData.getItemVisual(category,"color")))})})}},/* 200 */
/***/
function(module,exports,__webpack_require__){var simpleLayoutHelper=__webpack_require__(201);module.exports=function(ecModel,api){ecModel.eachSeriesByType("graph",function(seriesModel){var layout=seriesModel.get("layout");layout&&"none"!==layout||simpleLayoutHelper(seriesModel)})}},/* 201 */
/***/
function(module,exports){module.exports=function(seriesModel){var coordSys=seriesModel.coordinateSystem;if(!coordSys||"view"===coordSys.type){var graph=seriesModel.getGraph();graph.eachNode(function(node){var model=node.getModel();node.setLayout([+model.get("x"),+model.get("y")])}),graph.eachEdge(function(edge){var cp1,curveness=edge.getModel().get("lineStyle.normal.curveness")||0,p1=edge.node1.getLayout(),p2=edge.node2.getLayout();curveness>0&&(cp1=[(p1[0]+p2[0])/2-(p1[1]-p2[1])*curveness,(p1[1]+p2[1])/2-(p2[0]-p1[0])*curveness]),edge.setLayout([p1,p2,cp1])})}}},/* 202 */
/***/
function(module,exports,__webpack_require__){var circularLayoutHelper=__webpack_require__(203);module.exports=function(ecModel,api){ecModel.eachSeriesByType("graph",function(seriesModel){"circular"===seriesModel.get("layout")&&circularLayoutHelper(seriesModel)})}},/* 203 */
/***/
function(module,exports){module.exports=function(seriesModel){var coordSys=seriesModel.coordinateSystem;if(!coordSys||"view"===coordSys.type){var rect=coordSys.getBoundingRect(),nodeData=seriesModel.getData(),graph=nodeData.graph,angle=0,sum=nodeData.getSum("value"),unitAngle=2*Math.PI/(sum||nodeData.count()),cx=rect.width/2+rect.x,cy=rect.height/2+rect.y,r=Math.min(rect.width,rect.height)/2;graph.eachNode(function(node){var value=node.getValue("value");angle+=unitAngle*(sum?value:2)/2,node.setLayout([r*Math.cos(angle)+cx,r*Math.sin(angle)+cy]),angle+=unitAngle*(sum?value:2)/2}),graph.eachEdge(function(edge){var cp1,curveness=edge.getModel().get("lineStyle.normal.curveness")||0,p1=edge.node1.getLayout(),p2=edge.node2.getLayout();curveness>0&&(cp1=[cx,cy]),edge.setLayout([p1,p2,cp1])})}}},/* 204 */
/***/
function(module,exports,__webpack_require__){var forceHelper=__webpack_require__(205),numberUtil=__webpack_require__(7),simpleLayoutHelper=__webpack_require__(201),circularLayoutHelper=__webpack_require__(203),vec2=__webpack_require__(16);module.exports=function(ecModel,api){ecModel.eachSeriesByType("graph",function(graphSeries){if("force"===graphSeries.get("layout")){var preservedPoints=graphSeries.preservedPoints||{},graph=graphSeries.getGraph(),nodeData=graph.data,edgeData=graph.edgeData,forceModel=graphSeries.getModel("force"),initLayout=forceModel.get("initLayout");graphSeries.preservedPoints?nodeData.each(function(idx){var id=nodeData.getId(idx);nodeData.setItemLayout(idx,preservedPoints[id]||[NaN,NaN])}):initLayout&&"none"!==initLayout?"circular"===initLayout&&circularLayoutHelper(graphSeries):simpleLayoutHelper(graphSeries);var nodeDataExtent=nodeData.getDataExtent("value"),repulsion=forceModel.get("repulsion"),edgeLength=forceModel.get("edgeLength"),nodes=nodeData.mapArray("value",function(value,idx){var point=nodeData.getItemLayout(idx),rep=numberUtil.linearMap(value,nodeDataExtent,[0,repulsion])||repulsion/2;return{w:rep,rep:rep,p:!point||isNaN(point[0])||isNaN(point[1])?null:point}}),edges=edgeData.mapArray("value",function(value,idx){var edge=graph.getEdgeByIndex(idx);
// var w = numberUtil.linearMap(value, edgeDataExtent, [0, 100]);
return{n1:nodes[edge.node1.dataIndex],n2:nodes[edge.node2.dataIndex],d:edgeLength,curveness:edge.getModel().get("lineStyle.normal.curveness")||0}}),coordSys=graphSeries.coordinateSystem,rect=coordSys.getBoundingRect(),forceInstance=forceHelper(nodes,edges,{rect:rect,gravity:forceModel.get("gravity")}),oldStep=forceInstance.step;forceInstance.step=function(cb){for(var i=0,l=nodes.length;l>i;i++)nodes[i].fixed&&
// Write back to layout instance
vec2.copy(nodes[i].p,graph.getNodeByIndex(i).getLayout());oldStep(function(nodes,edges,stopped){for(var i=0,l=nodes.length;l>i;i++)nodes[i].fixed||graph.getNodeByIndex(i).setLayout(nodes[i].p),preservedPoints[nodeData.getId(i)]=nodes[i].p;for(var i=0,l=edges.length;l>i;i++){var e=edges[i],p1=e.n1.p,p2=e.n2.p,points=[p1,p2];e.curveness>0&&points.push([(p1[0]+p2[0])/2-(p1[1]-p2[1])*e.curveness,(p1[1]+p2[1])/2-(p2[0]-p1[0])*e.curveness]),graph.getEdgeByIndex(i).setLayout(points)}
// Update layout
cb&&cb(stopped)})},graphSeries.forceLayout=forceInstance,graphSeries.preservedPoints=preservedPoints,
// Step to get the layout
forceInstance.step()}else
// Remove prev injected forceLayout instance
graphSeries.forceLayout=null})}},/* 205 */
/***/
function(module,exports,__webpack_require__){var vec2=__webpack_require__(16),scaleAndAdd=vec2.scaleAndAdd;
// function adjacentNode(n, e) {
//     return e.n1 === n ? e.n2 : e.n1;
// }
module.exports=function(nodes,edges,opts){
// for (var i = 0; i < edges.length; i++) {
//     var e = edges[i];
//     var n1 = e.n1;
//     var n2 = e.n2;
//     n1.edges = n1.edges || [];
//     n2.edges = n2.edges || [];
//     n1.edges.push(e);
//     n2.edges.push(e);
// }
// Init position
for(var rect=opts.rect,width=rect.width,height=rect.height,center=[rect.x+width/2,rect.y+height/2],gravity=null==opts.gravity?.1:opts.gravity,i=0;i<nodes.length;i++){var n=nodes[i];n.p||(
// Use the position from first adjecent node with defined position
// Or use a random position
// From d3
// if (n.edges) {
//     var j = -1;
//     while (++j < n.edges.length) {
//         var e = n.edges[j];
//         var other = adjacentNode(n, e);
//         if (other.p) {
//             n.p = vec2.clone(other.p);
//             break;
//         }
//     }
// }
// if (!n.p) {
n.p=vec2.create(width*(Math.random()-.5)+center[0],height*(Math.random()-.5)+center[1])),n.pp=vec2.clone(n.p),n.edges=null}
// Formula in 'Graph Drawing by Force-directed Placement'
// var k = scale * Math.sqrt(width * height / nodes.length);
// var k2 = k * k;
var friction=.6;return{warmUp:function(){friction=.5},setFixed:function(idx){nodes[idx].fixed=!0},setUnfixed:function(idx){nodes[idx].fixed=!1},step:function(cb){for(var v12=[],nLen=nodes.length,i=0;i<edges.length;i++){var e=edges[i],n1=e.n1,n2=e.n2;vec2.sub(v12,n2.p,n1.p);var d=vec2.len(v12)-e.d,w=n2.w/(n1.w+n2.w);vec2.normalize(v12,v12),!n1.fixed&&scaleAndAdd(n1.p,n1.p,v12,w*d*friction),!n2.fixed&&scaleAndAdd(n2.p,n2.p,v12,-(1-w)*d*friction)}
// Gravity
for(var i=0;nLen>i;i++){var n=nodes[i];n.fixed||(vec2.sub(v12,center,n.p),
// var d = vec2.len(v12);
// vec2.scale(v12, v12, 1 / d);
// var gravityFactor = gravity;
vec2.scaleAndAdd(n.p,n.p,v12,gravity*friction))}
// Repulsive
// PENDING
for(var i=0;nLen>i;i++)for(var n1=nodes[i],j=i+1;nLen>j;j++){var n2=nodes[j];vec2.sub(v12,n2.p,n1.p);var d=vec2.len(v12);0===d&&(
// Random repulse
vec2.set(v12,Math.random()-.5,Math.random()-.5),d=1);var repFact=(n1.rep+n2.rep)/d/d;!n1.fixed&&scaleAndAdd(n1.pp,n1.pp,v12,repFact),!n2.fixed&&scaleAndAdd(n2.pp,n2.pp,v12,-repFact)}for(var v=[],i=0;nLen>i;i++){var n=nodes[i];n.fixed||(vec2.sub(v,n.p,n.pp),vec2.scaleAndAdd(n.p,n.p,v,friction),vec2.copy(n.pp,n.p))}friction=.992*friction,cb&&cb(nodes,edges,.01>friction)}}}},/* 206 */
/***/
function(module,exports,__webpack_require__){function getViewRect(seriesModel,api,aspect){var option=seriesModel.getBoxLayoutParams();return option.aspect=aspect,layout.getLayoutRect(option,{width:api.getWidth(),height:api.getHeight()})}
// FIXME Where to create the simple view coordinate system
var View=__webpack_require__(169),layout=__webpack_require__(21),bbox=__webpack_require__(50);module.exports=function(ecModel,api){var viewList=[];return ecModel.eachSeriesByType("graph",function(seriesModel){var coordSysType=seriesModel.get("coordinateSystem");if(!coordSysType||"view"===coordSysType){var viewCoordSys=new View;viewList.push(viewCoordSys);var data=seriesModel.getData(),positions=data.mapArray(function(idx){var itemModel=data.getItemModel(idx);return[+itemModel.get("x"),+itemModel.get("y")]}),min=[],max=[];bbox.fromPoints(positions,min,max);
// FIXME If get view rect after data processed?
var viewRect=getViewRect(seriesModel,api,(max[0]-min[0])/(max[1]-min[1])||1);
// Position may be NaN, use view rect instead
(isNaN(min[0])||isNaN(min[1]))&&(min=[viewRect.x,viewRect.y],max=[viewRect.x+viewRect.width,viewRect.y+viewRect.height]);var bbWidth=max[0]-min[0],bbHeight=max[1]-min[1],viewWidth=viewRect.width,viewHeight=viewRect.height;viewCoordSys=seriesModel.coordinateSystem=new View,viewCoordSys.setBoundingRect(min[0],min[1],bbWidth,bbHeight),viewCoordSys.setViewRect(viewRect.x,viewRect.y,viewWidth,viewHeight);
// Update roam info
var roamDetailModel=seriesModel.getModel("roamDetail");viewCoordSys.setPan(roamDetailModel.get("x")||0,roamDetailModel.get("y")||0),viewCoordSys.setZoom(roamDetailModel.get("zoom")||1)}}),viewList}},/* 207 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(208),__webpack_require__(209)},/* 208 */
/***/
function(module,exports,__webpack_require__){var List=__webpack_require__(94),SeriesModel=__webpack_require__(27),zrUtil=__webpack_require__(3),GaugeSeries=SeriesModel.extend({type:"series.gauge",getInitialData:function(option,ecModel){var list=new List(["value"],this),dataOpt=option.data||[];
// Only use the first data item
return zrUtil.isArray(dataOpt)||(dataOpt=[dataOpt]),list.initData(dataOpt),list},defaultOption:{zlevel:0,z:2,
// 默认全局居中
center:["50%","50%"],legendHoverLink:!0,radius:"75%",startAngle:225,endAngle:-45,clockwise:!0,
// 最小值
min:0,
// 最大值
max:100,
// 分割段数，默认为10
splitNumber:10,
// 坐标轴线
axisLine:{
// 默认显示，属性show控制显示与否
show:!0,lineStyle:{// 属性lineStyle控制线条样式
color:[[.2,"#91c7ae"],[.8,"#63869e"],[1,"#c23531"]],width:30}},
// 分隔线
splitLine:{
// 默认显示，属性show控制显示与否
show:!0,
// 属性length控制线长
length:30,
// 属性lineStyle（详见lineStyle）控制线条样式
lineStyle:{color:"#eee",width:2,type:"solid"}},
// 坐标轴小标记
axisTick:{
// 属性show控制显示与否，默认不显示
show:!0,
// 每份split细分多少段
splitNumber:5,
// 属性length控制线长
length:8,
// 属性lineStyle控制线条样式
lineStyle:{color:"#eee",width:1,type:"solid"}},axisLabel:{show:!0,
// formatter: null,
textStyle:{// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:"auto"}},pointer:{show:!0,length:"80%",width:8},itemStyle:{normal:{color:"auto"}},title:{show:!0,
// x, y，单位px
offsetCenter:[0,"-40%"],
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
textStyle:{color:"#333",fontSize:15}},detail:{show:!0,backgroundColor:"rgba(0,0,0,0)",borderWidth:0,borderColor:"#ccc",width:100,height:40,
// x, y，单位px
offsetCenter:[0,"40%"],
// formatter: null,
// 其余属性默认使用全局文本样式，详见TEXTSTYLE
textStyle:{color:"auto",fontSize:30}}}});module.exports=GaugeSeries},/* 209 */
/***/
function(module,exports,__webpack_require__){function parsePosition(seriesModel,api){var center=seriesModel.get("center"),width=api.getWidth(),height=api.getHeight(),size=Math.min(width,height),cx=parsePercent(center[0],api.getWidth()),cy=parsePercent(center[1],api.getHeight()),r=parsePercent(seriesModel.get("radius"),size/2);return{cx:cx,cy:cy,r:r}}function formatLabel(label,labelFormatter){return labelFormatter&&("string"==typeof labelFormatter?label=labelFormatter.replace("{value}",label):"function"==typeof labelFormatter&&(label=labelFormatter(label))),label}var PointerPath=__webpack_require__(210),graphic=__webpack_require__(42),numberUtil=__webpack_require__(7),parsePercent=numberUtil.parsePercent,PI2=2*Math.PI,GaugeView=__webpack_require__(41).extend({type:"gauge",render:function(seriesModel,ecModel,api){this.group.removeAll();var colorList=seriesModel.get("axisLine.lineStyle.color"),posInfo=parsePosition(seriesModel,api);this._renderMain(seriesModel,ecModel,api,colorList,posInfo)},_renderMain:function(seriesModel,ecModel,api,colorList,posInfo){for(var group=this.group,axisLineModel=seriesModel.getModel("axisLine"),lineStyleModel=axisLineModel.getModel("lineStyle"),clockwise=seriesModel.get("clockwise"),startAngle=-seriesModel.get("startAngle")/180*Math.PI,endAngle=-seriesModel.get("endAngle")/180*Math.PI,angleRangeSpan=(endAngle-startAngle)%PI2,prevEndAngle=startAngle,axisLineWidth=lineStyleModel.get("width"),i=0;i<colorList.length;i++){var endAngle=startAngle+angleRangeSpan*colorList[i][0],sector=new graphic.Sector({shape:{startAngle:prevEndAngle,endAngle:endAngle,cx:posInfo.cx,cy:posInfo.cy,clockwise:clockwise,r0:posInfo.r-axisLineWidth,r:posInfo.r},silent:!0});sector.setStyle({fill:colorList[i][1]}),sector.setStyle(lineStyleModel.getLineStyle(
// Because we use sector to simulate arc
// so the properties for stroking are useless
["color","borderWidth","borderColor"])),group.add(sector),prevEndAngle=endAngle}var getColor=function(percent){
// Less than 0
if(0>=percent)return colorList[0][1];for(var i=0;i<colorList.length;i++)if(colorList[i][0]>=percent&&(0===i?0:colorList[i-1][0])<percent)return colorList[i][1];
// More than 1
return colorList[i-1][1]};if(!clockwise){var tmp=startAngle;startAngle=endAngle,endAngle=tmp}this._renderTicks(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise),this._renderPointer(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise),this._renderTitle(seriesModel,ecModel,api,getColor,posInfo),this._renderDetail(seriesModel,ecModel,api,getColor,posInfo)},_renderTicks:function(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise){for(var group=this.group,cx=posInfo.cx,cy=posInfo.cy,r=posInfo.r,minVal=seriesModel.get("min"),maxVal=seriesModel.get("max"),splitLineModel=seriesModel.getModel("splitLine"),tickModel=seriesModel.getModel("axisTick"),labelModel=seriesModel.getModel("axisLabel"),splitNumber=seriesModel.get("splitNumber"),subSplitNumber=tickModel.get("splitNumber"),splitLineLen=parsePercent(splitLineModel.get("length"),r),tickLen=parsePercent(tickModel.get("length"),r),angle=startAngle,step=(endAngle-startAngle)/splitNumber,subStep=step/subSplitNumber,splitLineStyle=splitLineModel.getModel("lineStyle").getLineStyle(),tickLineStyle=tickModel.getModel("lineStyle").getLineStyle(),textStyleModel=labelModel.getModel("textStyle"),i=0;splitNumber>=i;i++){var unitX=Math.cos(angle),unitY=Math.sin(angle);
// Split line
if(splitLineModel.get("show")){var splitLine=new graphic.Line({shape:{x1:unitX*r+cx,y1:unitY*r+cy,x2:unitX*(r-splitLineLen)+cx,y2:unitY*(r-splitLineLen)+cy},style:splitLineStyle,silent:!0});"auto"===splitLineStyle.stroke&&splitLine.setStyle({stroke:getColor(i/splitNumber)}),group.add(splitLine)}
// Label
if(labelModel.get("show")){var label=formatLabel(numberUtil.round(i/splitNumber*(maxVal-minVal)+minVal),labelModel.get("formatter")),text=new graphic.Text({style:{text:label,x:unitX*(r-splitLineLen-5)+cx,y:unitY*(r-splitLineLen-5)+cy,fill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont(),textVerticalAlign:-.4>unitY?"top":unitY>.4?"bottom":"middle",textAlign:-.4>unitX?"left":unitX>.4?"right":"center"},silent:!0});"auto"===text.style.fill&&text.setStyle({fill:getColor(i/splitNumber)}),group.add(text)}
// Axis tick
if(tickModel.get("show")&&i!==splitNumber){for(var j=0;subSplitNumber>=j;j++){var unitX=Math.cos(angle),unitY=Math.sin(angle),tickLine=new graphic.Line({shape:{x1:unitX*r+cx,y1:unitY*r+cy,x2:unitX*(r-tickLen)+cx,y2:unitY*(r-tickLen)+cy},silent:!0,style:tickLineStyle});"auto"===tickLineStyle.stroke&&tickLine.setStyle({stroke:getColor((i+j/subSplitNumber)/splitNumber)}),group.add(tickLine),angle+=subStep}angle-=subStep}else angle+=step}},_renderPointer:function(seriesModel,ecModel,api,getColor,posInfo,startAngle,endAngle,clockwise){var linearMap=numberUtil.linearMap,valueExtent=[+seriesModel.get("min"),+seriesModel.get("max")],angleExtent=[startAngle,endAngle];clockwise||(angleExtent=angleExtent.reverse());var data=seriesModel.getData(),oldData=this._data,group=this.group;data.diff(oldData).add(function(idx){var pointer=new PointerPath({shape:{angle:startAngle}});graphic.updateProps(pointer,{shape:{angle:linearMap(data.get("value",idx),valueExtent,angleExtent)}},seriesModel),group.add(pointer),data.setItemGraphicEl(idx,pointer)}).update(function(newIdx,oldIdx){var pointer=oldData.getItemGraphicEl(oldIdx);graphic.updateProps(pointer,{shape:{angle:linearMap(data.get("value",newIdx),valueExtent,angleExtent)}},seriesModel),group.add(pointer),data.setItemGraphicEl(newIdx,pointer)}).remove(function(idx){var pointer=oldData.getItemGraphicEl(idx);group.remove(pointer)}).execute(),data.eachItemGraphicEl(function(pointer,idx){var itemModel=data.getItemModel(idx),pointerModel=itemModel.getModel("pointer");pointer.attr({shape:{x:posInfo.cx,y:posInfo.cy,width:parsePercent(pointerModel.get("width"),posInfo.r),r:parsePercent(pointerModel.get("length"),posInfo.r)},style:itemModel.getModel("itemStyle.normal").getItemStyle()}),"auto"===pointer.style.fill&&pointer.setStyle("fill",getColor((data.get("value",idx)-valueExtent[0])/(valueExtent[1]-valueExtent[0]))),graphic.setHoverStyle(pointer,itemModel.getModel("itemStyle.emphasis").getItemStyle())}),this._data=data},_renderTitle:function(seriesModel,ecModel,api,getColor,posInfo){var titleModel=seriesModel.getModel("title");if(titleModel.get("show")){var textStyleModel=titleModel.getModel("textStyle"),offsetCenter=titleModel.get("offsetCenter"),x=posInfo.cx+parsePercent(offsetCenter[0],posInfo.r),y=posInfo.cy+parsePercent(offsetCenter[1],posInfo.r),text=new graphic.Text({style:{x:x,y:y,
// FIXME First data name ?
text:seriesModel.getData().getName(0),fill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont(),textAlign:"center",textVerticalAlign:"middle"}});this.group.add(text)}},_renderDetail:function(seriesModel,ecModel,api,getColor,posInfo){var detailModel=seriesModel.getModel("detail"),minVal=seriesModel.get("min"),maxVal=seriesModel.get("max");if(detailModel.get("show")){var textStyleModel=detailModel.getModel("textStyle"),offsetCenter=detailModel.get("offsetCenter"),x=posInfo.cx+parsePercent(offsetCenter[0],posInfo.r),y=posInfo.cy+parsePercent(offsetCenter[1],posInfo.r),width=parsePercent(detailModel.get("width"),posInfo.r),height=parsePercent(detailModel.get("height"),posInfo.r),value=seriesModel.getData().get("value",0),rect=new graphic.Rect({shape:{x:x-width/2,y:y-height/2,width:width,height:height},style:{text:formatLabel(
// FIXME First data name ?
value,detailModel.get("formatter")),fill:detailModel.get("backgroundColor"),textFill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()}});"auto"===rect.style.textFill&&rect.setStyle("textFill",getColor((value-minVal)/(maxVal-minVal))),rect.setStyle(detailModel.getItemStyle(["color"])),this.group.add(rect)}}});module.exports=GaugeView},/* 210 */
/***/
function(module,exports,__webpack_require__){module.exports=__webpack_require__(44).extend({type:"echartsGaugePointer",shape:{angle:0,width:10,r:10,x:0,y:0},buildPath:function(ctx,shape){var mathCos=Math.cos,mathSin=Math.sin,r=shape.r,width=shape.width,angle=shape.angle,x=shape.x-mathCos(angle)*width*(width>=r/3?1:2),y=shape.y-mathSin(angle)*width*(width>=r/3?1:2);angle=shape.angle-Math.PI/2,ctx.moveTo(x,y),ctx.lineTo(shape.x+mathCos(angle)*width,shape.y+mathSin(angle)*width),ctx.lineTo(shape.x+mathCos(shape.angle)*r,shape.y+mathSin(shape.angle)*r),ctx.lineTo(shape.x-mathCos(angle)*width,shape.y-mathSin(angle)*width),ctx.lineTo(x,y)}})},/* 211 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);__webpack_require__(212),__webpack_require__(213),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(137),"funnel")),echarts.registerLayout(__webpack_require__(214)),echarts.registerProcessor("filter",zrUtil.curry(__webpack_require__(140),"funnel"))},/* 212 */
/***/
function(module,exports,__webpack_require__){"use strict";var List=__webpack_require__(94),modelUtil=__webpack_require__(5),completeDimensions=__webpack_require__(96),FunnelSeries=__webpack_require__(1).extendSeriesModel({type:"series.funnel",init:function(option){FunnelSeries.superApply(this,"init",arguments),
// Enable legend selection for each data item
// Use a function instead of direct access because data reference may changed
this.legendDataProvider=function(){return this._dataBeforeProcessed},
// Extend labelLine emphasis
this._defaultLabelLine(option)},getInitialData:function(option,ecModel){var dimensions=completeDimensions(["value"],option.data),list=new List(dimensions,this);return list.initData(option.data),list},_defaultLabelLine:function(option){
// Extend labelLine emphasis
modelUtil.defaultEmphasis(option.labelLine,["show"]);var labelLineNormalOpt=option.labelLine.normal,labelLineEmphasisOpt=option.labelLine.emphasis;
// Not show label line if `label.normal.show = false`
labelLineNormalOpt.show=labelLineNormalOpt.show&&option.label.normal.show,labelLineEmphasisOpt.show=labelLineEmphasisOpt.show&&option.label.emphasis.show},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
legendHoverLink:!0,left:80,top:60,right:80,bottom:60,
// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
// 默认取数据最小最大值
// min: 0,
// max: 100,
minSize:"0%",maxSize:"100%",sort:"descending",// 'ascending', 'descending'
gap:0,funnelAlign:"center",label:{normal:{show:!0,position:"outer"},emphasis:{show:!0}},labelLine:{normal:{show:!0,length:20,lineStyle:{
// color: 各异,
width:1,type:"solid"}},emphasis:{}},itemStyle:{normal:{
// color: 各异,
borderColor:"#fff",borderWidth:1},emphasis:{}}}});module.exports=FunnelSeries},/* 213 */
/***/
function(module,exports,__webpack_require__){/**
	     * Piece of pie including Sector, Label, LabelLine
	     * @constructor
	     * @extends {module:zrender/graphic/Group}
	     */
function FunnelPiece(data,idx){
// Hover to change label and labelLine
function onEmphasis(){labelLine.ignore=labelLine.hoverIgnore,text.ignore=text.hoverIgnore}function onNormal(){labelLine.ignore=labelLine.normalIgnore,text.ignore=text.normalIgnore}graphic.Group.call(this);var polygon=new graphic.Polygon,labelLine=new graphic.Polyline,text=new graphic.Text;this.add(polygon),this.add(labelLine),this.add(text),this.updateData(data,idx,!0),this.on("emphasis",onEmphasis).on("normal",onNormal).on("mouseover",onEmphasis).on("mouseout",onNormal)}function getLabelStyle(data,idx,state,labelModel){var textStyleModel=labelModel.getModel("textStyle"),position=labelModel.get("position"),isLabelInside="inside"===position||"inner"===position||"center"===position;return{fill:textStyleModel.getTextColor()||(isLabelInside?"#fff":data.getItemVisual(idx,"color")),textFont:textStyleModel.getFont(),text:zrUtil.retrieve(data.hostModel.getFormattedLabel(idx,state),data.getName(idx))}}var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),funnelPieceProto=FunnelPiece.prototype,opacityAccessPath=["itemStyle","normal","opacity"];funnelPieceProto.updateData=function(data,idx,firstCreate){var polygon=this.childAt(0),seriesModel=data.hostModel,itemModel=data.getItemModel(idx),layout=data.getItemLayout(idx),opacity=data.getItemModel(idx).get(opacityAccessPath);opacity=null==opacity?1:opacity,firstCreate?(polygon.setShape({points:layout.points}),polygon.setStyle({opacity:0}),graphic.initProps(polygon,{style:{opacity:opacity}},seriesModel)):graphic.updateProps(polygon,{style:{opacity:opacity},shape:{points:layout.points}},seriesModel);
// Update common style
var itemStyleModel=itemModel.getModel("itemStyle"),visualColor=data.getItemVisual(idx,"color");polygon.setStyle(zrUtil.defaults({fill:visualColor},itemStyleModel.getModel("normal").getItemStyle(["opacity"]))),polygon.hoverStyle=itemStyleModel.getModel("emphasis").getItemStyle(),this._updateLabel(data,idx),graphic.setHoverStyle(this)},funnelPieceProto._updateLabel=function(data,idx){var labelLine=this.childAt(1),labelText=this.childAt(2),seriesModel=data.hostModel,itemModel=data.getItemModel(idx),layout=data.getItemLayout(idx),labelLayout=layout.label,visualColor=data.getItemVisual(idx,"color");graphic.updateProps(labelLine,{shape:{points:labelLayout.linePoints||labelLayout.linePoints}},seriesModel),graphic.updateProps(labelText,{style:{x:labelLayout.x,y:labelLayout.y}},seriesModel),labelText.attr({style:{textAlign:labelLayout.textAlign,textVerticalAlign:labelLayout.verticalAlign,textFont:labelLayout.font},rotation:labelLayout.rotation,origin:[labelLayout.x,labelLayout.y],z2:10});var labelModel=itemModel.getModel("label.normal"),labelHoverModel=itemModel.getModel("label.emphasis"),labelLineModel=itemModel.getModel("labelLine.normal"),labelLineHoverModel=itemModel.getModel("labelLine.emphasis");labelText.setStyle(getLabelStyle(data,idx,"normal",labelModel)),labelText.ignore=labelText.normalIgnore=!labelModel.get("show"),labelText.hoverIgnore=!labelHoverModel.get("show"),labelLine.ignore=labelLine.normalIgnore=!labelLineModel.get("show"),labelLine.hoverIgnore=!labelLineHoverModel.get("show"),
// Default use item visual color
labelLine.setStyle({stroke:visualColor}),labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle()),labelText.hoverStyle=getLabelStyle(data,idx,"emphasis",labelHoverModel),labelLine.hoverStyle=labelLineHoverModel.getModel("lineStyle").getLineStyle()},zrUtil.inherits(FunnelPiece,graphic.Group);var Funnel=__webpack_require__(41).extend({type:"funnel",render:function(seriesModel,ecModel,api){var data=seriesModel.getData(),oldData=this._data,group=this.group;data.diff(oldData).add(function(idx){var funnelPiece=new FunnelPiece(data,idx);data.setItemGraphicEl(idx,funnelPiece),group.add(funnelPiece)}).update(function(newIdx,oldIdx){var piePiece=oldData.getItemGraphicEl(oldIdx);piePiece.updateData(data,newIdx),group.add(piePiece),data.setItemGraphicEl(newIdx,piePiece)}).remove(function(idx){var piePiece=oldData.getItemGraphicEl(idx);group.remove(piePiece)}).execute(),this._data=data},remove:function(){this.group.removeAll(),this._data=null}});module.exports=Funnel},/* 214 */
/***/
function(module,exports,__webpack_require__){function getViewRect(seriesModel,api){return layout.getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()})}function getSortedIndices(data,sort){for(var valueArr=data.mapArray("value",function(val){return val}),indices=[],isAscending="ascending"===sort,i=0,len=data.count();len>i;i++)indices[i]=i;return indices.sort(function(a,b){return isAscending?valueArr[a]-valueArr[b]:valueArr[b]-valueArr[a]}),indices}function labelLayout(data){data.each(function(idx){var textAlign,textX,textY,linePoints,itemModel=data.getItemModel(idx),labelModel=itemModel.getModel("label.normal"),labelPosition=labelModel.get("position"),labelLineModel=itemModel.getModel("labelLine.normal"),layout=data.getItemLayout(idx),points=layout.points,isLabelInside="inner"===labelPosition||"inside"===labelPosition||"center"===labelPosition;if(isLabelInside)textX=(points[0][0]+points[1][0]+points[2][0]+points[3][0])/4,textY=(points[0][1]+points[1][1]+points[2][1]+points[3][1])/4,textAlign="center",linePoints=[[textX,textY],[textX,textY]];else{var x1,y1,x2,labelLineLen=labelLineModel.get("length");"left"===labelPosition?(x1=(points[3][0]+points[0][0])/2,y1=(points[3][1]+points[0][1])/2,x2=x1-labelLineLen,textX=x2-5,textAlign="right"):(x1=(points[1][0]+points[2][0])/2,y1=(points[1][1]+points[2][1])/2,x2=x1+labelLineLen,textX=x2+5,textAlign="left");var y2=y1;linePoints=[[x1,y1],[x2,y2]],textY=y2}layout.label={linePoints:linePoints,x:textX,y:textY,verticalAlign:"middle",textAlign:textAlign,inside:isLabelInside}})}var layout=__webpack_require__(21),number=__webpack_require__(7),parsePercent=number.parsePercent;module.exports=function(ecModel,api){ecModel.eachSeriesByType("funnel",function(seriesModel){var data=seriesModel.getData(),sort=seriesModel.get("sort"),viewRect=getViewRect(seriesModel,api),indices=getSortedIndices(data,sort),sizeExtent=[parsePercent(seriesModel.get("minSize"),viewRect.width),parsePercent(seriesModel.get("maxSize"),viewRect.width)],dataExtent=data.getDataExtent("value"),min=seriesModel.get("min"),max=seriesModel.get("max");null==min&&(min=Math.min(dataExtent[0],0)),null==max&&(max=dataExtent[1]);var funnelAlign=seriesModel.get("funnelAlign"),gap=seriesModel.get("gap"),itemHeight=(viewRect.height-gap*(data.count()-1))/data.count(),y=viewRect.y,getLinePoints=function(idx,offY){
// End point index is data.count() and we assign it 0
var x0,val=data.get("value",idx)||0,itemWidth=number.linearMap(val,[min,max],sizeExtent,!0);switch(funnelAlign){case"left":x0=viewRect.x;break;case"center":x0=viewRect.x+(viewRect.width-itemWidth)/2;break;case"right":x0=viewRect.x+viewRect.width-itemWidth}return[[x0,offY],[x0+itemWidth,offY]]};"ascending"===sort&&(itemHeight=-itemHeight,gap=-gap,y+=viewRect.height,indices=indices.reverse());for(var i=0;i<indices.length;i++){var idx=indices[i],nextIdx=indices[i+1],start=getLinePoints(idx,y),end=getLinePoints(nextIdx,y+itemHeight);y+=itemHeight+gap,data.setItemLayout(idx,{points:start.concat(end.slice().reverse())})}labelLayout(data)})}},/* 215 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(216),__webpack_require__(227),__webpack_require__(228),echarts.registerVisualCoding("chart",__webpack_require__(229))},/* 216 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(217),__webpack_require__(220),__webpack_require__(222);var echarts=__webpack_require__(1);
// Parallel view
echarts.extendComponentView({type:"parallel"}),echarts.registerPreprocessor(__webpack_require__(226))},/* 217 */
/***/
function(module,exports,__webpack_require__){function create(ecModel,api){var coordSysList=[];
// Inject the coordinateSystems into seriesModel
return ecModel.eachComponent("parallel",function(parallelModel,idx){var coordSys=new Parallel(parallelModel,ecModel,api);coordSys.name="parallel_"+idx,coordSys.resize(parallelModel,api),parallelModel.coordinateSystem=coordSys,coordSys.model=parallelModel,coordSysList.push(coordSys)}),ecModel.eachSeries(function(seriesModel){if("parallel"===seriesModel.get("coordinateSystem")){var parallelIndex=seriesModel.get("parallelIndex");seriesModel.coordinateSystem=coordSysList[parallelIndex]}}),coordSysList}/**
	 * Parallel coordinate system creater.
	 */
var Parallel=__webpack_require__(218);__webpack_require__(25).register("parallel",{create:create})},/* 218 */
/***/
function(module,exports,__webpack_require__){function Parallel(parallelModel,ecModel,api){/**
	         * key: dimension
	         * @type {Object.<string, module:echarts/coord/parallel/Axis>}
	         * @private
	         */
this._axesMap={},/**
	         * key: dimension
	         * value: {position: [], rotation, }
	         * @type {Object.<string, Object>}
	         * @private
	         */
this._axesLayout={},/**
	         * Always follow axis order.
	         * @type {Array.<string>}
	         * @readOnly
	         */
this.dimensions=parallelModel.dimensions,/**
	         * @type {module:zrender/core/BoundingRect}
	         */
this._rect,/**
	         * @type {module:echarts/coord/parallel/ParallelModel}
	         */
this._model=parallelModel,this._init(parallelModel,ecModel,api)}/**
	 * Parallel Coordinates
	 * <https://en.wikipedia.org/wiki/Parallel_coordinates>
	 */
var layout=__webpack_require__(21),axisHelper=__webpack_require__(108),zrUtil=__webpack_require__(3),ParallelAxis=__webpack_require__(219),matrix=__webpack_require__(17),vector=__webpack_require__(16),each=zrUtil.each,PI=Math.PI;Parallel.prototype={type:"parallel",constructor:Parallel,/**
	         * Initialize cartesian coordinate systems
	         * @private
	         */
_init:function(parallelModel,ecModel,api){var dimensions=parallelModel.dimensions,parallelAxisIndex=parallelModel.parallelAxisIndex;each(dimensions,function(dim,idx){var axisIndex=parallelAxisIndex[idx],axisModel=ecModel.getComponent("parallelAxis",axisIndex),axis=this._axesMap[dim]=new ParallelAxis(dim,axisHelper.createScaleByModel(axisModel),[0,0],axisModel.get("type"),axisIndex),isCategory="category"===axis.type;axis.onBand=isCategory&&axisModel.get("boundaryGap"),axis.inverse=axisModel.get("inverse"),
// Inject axis into axisModel
axisModel.axis=axis,
// Inject axisModel into axis
axis.model=axisModel},this)},/**
	         * Update axis scale after data processed
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
update:function(ecModel,api){this._updateAxesFromSeries(this._model,ecModel)},/**
	         * Update properties from series
	         * @private
	         */
_updateAxesFromSeries:function(parallelModel,ecModel){ecModel.eachSeries(function(seriesModel){if(parallelModel.contains(seriesModel,ecModel)){var data=seriesModel.getData();each(this.dimensions,function(dim){var axis=this._axesMap[dim];axis.scale.unionExtent(data.getDataExtent(dim)),axisHelper.niceScaleExtent(axis,axis.model)},this)}},this)},/**
	         * Resize the parallel coordinate system.
	         * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
	         * @param {module:echarts/ExtensionAPI} api
	         */
resize:function(parallelModel,api){this._rect=layout.getLayoutRect(parallelModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()}),this._layoutAxes(parallelModel)},/**
	         * @return {module:zrender/core/BoundingRect}
	         */
getRect:function(){return this._rect},/**
	         * @private
	         */
_layoutAxes:function(parallelModel){var rect=this._rect,layout=parallelModel.get("layout"),axes=this._axesMap,dimensions=this.dimensions,size=[rect.width,rect.height],sizeIdx="horizontal"===layout?0:1,layoutLength=size[sizeIdx],axisLength=size[1-sizeIdx],axisExtent=[0,axisLength];each(axes,function(axis){var idx=axis.inverse?1:0;axis.setExtent(axisExtent[idx],axisExtent[1-idx])}),each(dimensions,function(dim,idx){var pos=layoutLength*idx/(dimensions.length-1),positionTable={horizontal:{x:pos,y:axisLength},vertical:{x:0,y:pos}},rotationTable={horizontal:PI/2,vertical:0},position=[positionTable[layout].x+rect.x,positionTable[layout].y+rect.y],rotation=rotationTable[layout],transform=matrix.create();matrix.rotate(transform,transform,rotation),matrix.translate(transform,transform,position),
// TODO
// tick等排布信息。
// TODO
// 根据axis order 更新 dimensions顺序。
this._axesLayout[dim]={position:position,rotation:rotation,transform:transform,tickDirection:1,labelDirection:1}},this)},/**
	         * Get axis by dim.
	         * @param {string} dim
	         * @return {module:echarts/coord/parallel/ParallelAxis} [description]
	         */
getAxis:function(dim){return this._axesMap[dim]},/**
	         * Convert a dim value of a single item of series data to Point.
	         * @param {*} value
	         * @param {string} dim
	         * @return {Array}
	         */
dataToPoint:function(value,dim){return this.axisCoordToPoint(this._axesMap[dim].dataToCoord(value),dim)},/**
	         * @param {module:echarts/data/List} data
	         * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
	         *                            {number} dataIndex
	         * @param {Object} context
	         */
eachActiveState:function(data,callback,context){for(var dimensions=this.dimensions,axesMap=this._axesMap,hasActiveSet=!1,j=0,lenj=dimensions.length;lenj>j;j++)"normal"!==axesMap[dimensions[j]].model.getActiveState()&&(hasActiveSet=!0);for(var i=0,len=data.count();len>i;i++){var activeState,values=data.getValues(dimensions,i);if(hasActiveSet){activeState="active";for(var j=0,lenj=dimensions.length;lenj>j;j++){var dimName=dimensions[j],state=axesMap[dimName].model.getActiveState(values[j],j);if("inactive"===state){activeState="inactive";break}}}else activeState="normal";callback.call(context,activeState,i)}},/**
	         * Convert coords of each axis to Point.
	         *  Return point. For example: [10, 20]
	         * @param {Array.<number>} coords
	         * @param {string} dim
	         * @return {Array.<number>}
	         */
axisCoordToPoint:function(coord,dim){var axisLayout=this._axesLayout[dim],point=[coord,0];return vector.applyTransform(point,point,axisLayout.transform),point},/**
	         * Get axis layout.
	         */
getAxisLayout:function(dim){return zrUtil.clone(this._axesLayout[dim])}},module.exports=Parallel},/* 219 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117),ParallelAxis=function(dim,scale,coordExtent,axisType,axisIndex){Axis.call(this,dim,scale,coordExtent),/**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
this.type=axisType||"value",/**
	         * @type {number}
	         * @readOnly
	         */
this.axisIndex=axisIndex};ParallelAxis.prototype={constructor:ParallelAxis,/**
	         * Axis model
	         * @param {module:echarts/coord/parallel/AxisModel}
	         */
model:null},zrUtil.inherits(ParallelAxis,Axis),module.exports=ParallelAxis},/* 220 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),Component=__webpack_require__(19);__webpack_require__(221),Component.extend({type:"parallel",dependencies:["parallelAxis"],/**
	         * @type {module:echarts/coord/parallel/Parallel}
	         */
coordinateSystem:null,/**
	         * Each item like: 'dim0', 'dim1', 'dim2', ...
	         * @type {Array.<string>}
	         * @readOnly
	         */
dimensions:null,/**
	         * Coresponding to dimensions.
	         * @type {Array.<number>}
	         * @readOnly
	         */
parallelAxisIndex:null,defaultOption:{zlevel:0,// 一级层叠
z:0,// 二级层叠
left:80,top:60,right:80,bottom:60,
// width: {totalWidth} - left - right,
// height: {totalHeight} - top - bottom,
layout:"horizontal",// 'horizontal' or 'vertical'
parallelAxisDefault:null},/**
	         * @override
	         */
init:function(){Component.prototype.init.apply(this,arguments),this.mergeOption({})},/**
	         * @override
	         */
mergeOption:function(newOption){var thisOption=this.option;newOption&&zrUtil.merge(thisOption,newOption,!0),this._initDimensions()},/**
	         * Whether series or axis is in this coordinate system.
	         * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
	         * @param {module:echarts/model/Global} ecModel
	         */
contains:function(model,ecModel){var parallelIndex=model.get("parallelIndex");return null!=parallelIndex&&ecModel.getComponent("parallel",parallelIndex)===this},/**
	         * @private
	         */
_initDimensions:function(){var dimensions=this.dimensions=[],parallelAxisIndex=this.parallelAxisIndex=[],axisModels=zrUtil.filter(this.dependentModels.parallelAxis,function(axisModel){
// Can not use this.contains here, because
// initialization has not been completed yet.
return axisModel.get("parallelIndex")===this.componentIndex});zrUtil.each(axisModels,function(axisModel){dimensions.push("dim"+axisModel.get("dim")),parallelAxisIndex.push(axisModel.componentIndex)})}})},/* 221 */
/***/
function(module,exports,__webpack_require__){function getAxisType(axisName,option){return option.type||(option.data?"category":"value")}var ComponentModel=__webpack_require__(19),zrUtil=__webpack_require__(3),makeStyleMapper=__webpack_require__(11),axisModelCreator=__webpack_require__(121),numberUtil=__webpack_require__(7),AxisModel=ComponentModel.extend({type:"baseParallelAxis",/**
	         * @type {module:echarts/coord/parallel/Axis}
	         */
axis:null,/**
	         * @type {Array.<Array.<number>}
	         * @readOnly
	         */
activeIntervals:[],/**
	         * @return {Object}
	         */
getAreaSelectStyle:function(){return makeStyleMapper([["fill","color"],["lineWidth","borderWidth"],["stroke","borderColor"],["width","width"],["opacity","opacity"]]).call(this.getModel("areaSelectStyle"))},/**
	         * The code of this feature is put on AxisModel but not ParallelAxis,
	         * because axisModel can be alive after echarts updating but instance of
	         * ParallelAxis having been disposed. this._activeInterval should be kept
	         * when action dispatched (i.e. legend click).
	         *
	         * @param {Array.<Array<number>>} intervals interval.length === 0
	         *                                          means set all active.
	         * @public
	         */
setActiveIntervals:function(intervals){var activeIntervals=this.activeIntervals=zrUtil.clone(intervals);
// Normalize
if(activeIntervals)for(var i=activeIntervals.length-1;i>=0;i--)numberUtil.asc(activeIntervals[i])},/**
	         * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
	         *                         value can not be input.
	         * @return {string} 'normal': no activeIntervals set,
	         *                  'active',
	         *                  'inactive'.
	         * @public
	         */
getActiveState:function(value){var activeIntervals=this.activeIntervals;if(!activeIntervals.length)return"normal";if(null==value)return"inactive";for(var i=0,len=activeIntervals.length;len>i;i++)if(activeIntervals[i][0]<=value&&value<=activeIntervals[i][1])return"active";return"inactive"}}),defaultOption={type:"value",/**
	         * @type {Array.<number>}
	         */
dim:null,// 0, 1, 2, ...
parallelIndex:null,areaSelectStyle:{width:20,borderWidth:1,borderColor:"rgba(160,197,232)",color:"rgba(160,197,232)",opacity:.3},z:10};zrUtil.merge(AxisModel.prototype,__webpack_require__(123)),axisModelCreator("parallel",AxisModel,getAxisType,defaultOption),module.exports=AxisModel},/* 222 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(217),__webpack_require__(223),__webpack_require__(224)},/* 223 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1),actionInfo={type:"axisAreaSelect",event:"axisAreaSelected",update:"updateVisual"};/**
	     * @payload
	     * @property {string} parallelAxisId
	     * @property {Array.<Array.<number>>} intervals
	     */
echarts.registerAction(actionInfo,function(payload,ecModel){ecModel.eachComponent({mainType:"parallelAxis",query:payload},function(parallelAxisModel){parallelAxisModel.axis.model.setActiveIntervals(payload.intervals)})})},/* 224 */
/***/
function(module,exports,__webpack_require__){function fromAxisAreaSelect(axisModel,ecModel,payload){return payload&&"axisAreaSelect"===payload.type&&ecModel.findComponents({mainType:"parallelAxis",query:payload})[0]===axisModel}var zrUtil=__webpack_require__(3),AxisBuilder=__webpack_require__(126),SelectController=__webpack_require__(225),elementList=["axisLine","axisLabel","axisTick","axisName"],AxisView=__webpack_require__(1).extendComponentView({type:"parallelAxis",/**
	         * @type {module:echarts/component/helper/SelectController}
	         */
_selectController:null,/**
	         * @override
	         */
render:function(axisModel,ecModel,api,payload){if(!fromAxisAreaSelect(axisModel,ecModel,payload)&&(this.axisModel=axisModel,this.api=api,this.group.removeAll(),axisModel.get("show"))){var coordSys=ecModel.getComponent("parallel",axisModel.get("parallelIndex")).coordinateSystem,areaSelectStyle=axisModel.getAreaSelectStyle(),areaWidth=areaSelectStyle.width,axisLayout=coordSys.getAxisLayout(axisModel.axis.dim),builderOpt=zrUtil.extend({strokeContainThreshold:areaWidth,
// lineWidth === 0 or no value.
axisLineSilent:!(areaWidth>0)},axisLayout),axisBuilder=new AxisBuilder(axisModel,builderOpt);zrUtil.each(elementList,axisBuilder.add,axisBuilder);var axisGroup=axisBuilder.getGroup();this.group.add(axisGroup),this._buildSelectController(axisGroup,areaSelectStyle,axisModel,api)}},_buildSelectController:function(axisGroup,areaSelectStyle,axisModel,api){var axis=axisModel.axis,selectController=this._selectController;selectController||(selectController=this._selectController=new SelectController("line",api.getZr(),areaSelectStyle),selectController.on("selected",zrUtil.bind(this._onSelected,this))),selectController.enable(axisGroup);
// After filtering, axis may change, select area needs to be update.
var ranges=zrUtil.map(axisModel.activeIntervals,function(interval){return[axis.dataToCoord(interval[0],!0),axis.dataToCoord(interval[1],!0)]});selectController.update(ranges)},_onSelected:function(ranges){
// Do not cache these object, because the mey be changed.
var axisModel=this.axisModel,axis=axisModel.axis,intervals=zrUtil.map(ranges,function(range){return[axis.coordToData(range[0],!0),axis.coordToData(range[1],!0)]});this.api.dispatchAction({type:"axisAreaSelect",parallelAxisId:axisModel.id,intervals:intervals})},/**
	         * @override
	         */
remove:function(){this._selectController&&this._selectController.disable()},/**
	         * @override
	         */
dispose:function(){this._selectController&&(this._selectController.dispose(),this._selectController=null)}});module.exports=AxisView},/* 225 */
/***/
function(module,exports,__webpack_require__){/**
	     * @alias module:echarts/component/helper/SelectController
	     * @constructor
	     * @mixin {module:zrender/mixin/Eventful}
	     *
	     * @param {string} type 'line', 'rect'
	     * @param {module:zrender/zrender~ZRender} zr
	     * @param {Object} [opt]
	     * @param {number} [opt.width]
	     * @param {number} [opt.lineWidth]
	     * @param {string} [opt.stroke]
	     * @param {string} [opt.fill]
	     */
function SelectController(type,zr,opt){Eventful.call(this),/**
	         * @type {string}
	         * @readOnly
	         */
this.type=type,/**
	         * @type {module:zrender/zrender~ZRender}
	         */
this.zr=zr,/**
	         * @type {Object}
	         * @readOnly
	         */
this.opt=zrUtil.clone(opt),/**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
this.group=new graphic.Group,/**
	         * @type {module:zrender/core/BoundingRect}
	         */
this._containerRect=null,/**
	         * @type {Array.<nubmer>}
	         * @private
	         */
this._track=[],/**
	         * @type {boolean}
	         */
this._dragging,/**
	         * @type {module:zrender/Element}
	         * @private
	         */
this._cover,/**
	         * @type {boolean}
	         * @private
	         */
this._disabled=!0,/**
	         * @type {Object}
	         * @private
	         */
this._handlers={mousedown:bind(mousedown,this),mousemove:bind(mousemove,this),mouseup:bind(mouseup,this)},each(EVENTS,function(eventName){this.zr.on(eventName,this._handlers[eventName])},this)}function updateZ(group){group.traverse(function(el){el.z=COVER_Z})}function isInContainer(x,y){var localPos=this.group.transformCoordToLocal(x,y);return!this._containerRect||this._containerRect.contain(localPos[0],localPos[1])}function preventDefault(e){var rawE=e.event;rawE.preventDefault&&rawE.preventDefault()}function mousedown(e){if(!(this._disabled||e.target&&e.target.draggable)){preventDefault(e);var x=e.offsetX,y=e.offsetY;isInContainer.call(this,x,y)&&(this._dragging=!0,this._track=[[x,y]])}}function mousemove(e){this._dragging&&!this._disabled&&(preventDefault(e),updateViewByCursor.call(this,e))}function mouseup(e){this._dragging&&!this._disabled&&(preventDefault(e),updateViewByCursor.call(this,e,!0),this._dragging=!1,this._track=[])}function updateViewByCursor(e,isEnd){var x=e.offsetX,y=e.offsetY;if(isInContainer.call(this,x,y)){this._track.push([x,y]);
// Create or update cover.
var ranges=shouldShowCover.call(this)?coverRenderers[this.type].getRanges.call(this):[];renderCover.call(this,ranges),this.trigger("selected",zrUtil.clone(ranges)),isEnd&&this.trigger("selectEnd",zrUtil.clone(ranges))}}function shouldShowCover(){var track=this._track;if(!track.length)return!1;var p2=track[track.length-1],p1=track[0],dx=p2[0]-p1[0],dy=p2[1]-p1[1],dist=mathPow(dx*dx+dy*dy,.5);return dist>UNSELECT_THRESHOLD}function renderCover(ranges){var coverRenderer=coverRenderers[this.type];ranges&&ranges.length?(this._cover||(this._cover=coverRenderer.create.call(this),this.group.add(this._cover)),coverRenderer.update.call(this,ranges)):(this.group.remove(this._cover),this._cover=null),updateZ(this.group)}function removeGroup(){
// container may 'removeAll' outside.
var group=this.group,container=group.parent;container&&container.remove(group)}function createRectCover(){var opt=this.opt;return new graphic.Rect({
// FIXME
// customize style.
style:{stroke:opt.stroke,fill:opt.fill,lineWidth:opt.lineWidth,opacity:opt.opacity}})}function getLocalTrack(){return zrUtil.map(this._track,function(point){return this.group.transformCoordToLocal(point[0],point[1])},this)}function getLocalTrackEnds(){var localTrack=getLocalTrack.call(this),tail=localTrack.length-1;return 0>tail&&(tail=0),[localTrack[0],localTrack[tail]]}/**
	 * Box selection tool.
	 *
	 * @module echarts/component/helper/SelectController
	 */
var Eventful=__webpack_require__(32),zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),bind=zrUtil.bind,each=zrUtil.each,mathMin=Math.min,mathMax=Math.max,mathPow=Math.pow,COVER_Z=1e4,UNSELECT_THRESHOLD=2,EVENTS=["mousedown","mousemove","mouseup"];SelectController.prototype={constructor:SelectController,/**
	         * @param {module:zrender/mixin/Transformable} container
	         * @param {module:zrender/core/BoundingRect|boolean} [rect] If not specified,
	         *                                                  use container.getBoundingRect().
	         *                                                  If false, do not use containerRect.
	         */
enable:function(container,rect){this._disabled=!1,
// Remove from old container.
removeGroup.call(this),
// boundingRect will change when dragging, so we have
// to keep initial boundingRect.
this._containerRect=rect!==!1?rect||container.getBoundingRect():null,
// Add to new container.
container.add(this.group)},/**
	         * Update cover location.
	         * @param {Array.<number>|Object} ranges If null/undefined, remove cover.
	         */
update:function(ranges){
// TODO
// Only support one interval yet.
renderCover.call(this,ranges&&zrUtil.clone(ranges))},disable:function(){this._disabled=!0,removeGroup.call(this)},dispose:function(){this.disable(),each(EVENTS,function(eventName){this.zr.off(eventName,this._handlers[eventName])},this)}},zrUtil.mixin(SelectController,Eventful);/**
	     * key: this.type
	     * @type {Object}
	     */
var coverRenderers={line:{create:createRectCover,getRanges:function(){var ends=getLocalTrackEnds.call(this),min=mathMin(ends[0][0],ends[1][0]),max=mathMax(ends[0][0],ends[1][0]);return[[min,max]]},update:function(ranges){var range=ranges[0],width=this.opt.width;this._cover.setShape({x:range[0],y:-width/2,width:range[1]-range[0],height:width})}},rect:{create:createRectCover,getRanges:function(){var ends=getLocalTrackEnds.call(this),min=[mathMin(ends[1][0],ends[0][0]),mathMin(ends[1][1],ends[0][1])],max=[mathMax(ends[1][0],ends[0][0]),mathMax(ends[1][1],ends[0][1])];return[[[min[0],max[0]],// x range
[min[1],max[1]]]]},update:function(ranges){var range=ranges[0];this._cover.setShape({x:range[0][0],y:range[1][0],width:range[0][1]-range[0][0],height:range[1][1]-range[1][0]})}}};module.exports=SelectController},/* 226 */
/***/
function(module,exports,__webpack_require__){/**
	     * Create a parallel coordinate if not exists.
	     * @inner
	     */
function createParallelIfNeeded(option){if(!option.parallel){var hasParallelSeries=!1;zrUtil.each(option.series,function(seriesOpt){seriesOpt&&"parallel"===seriesOpt.type&&(hasParallelSeries=!0)}),hasParallelSeries&&(option.parallel=[{}])}}/**
	     * Merge aixs definition from parallel option (if exists) to axis option.
	     * @inner
	     */
function mergeAxisOptionFromParallel(option){var axes=modelUtil.normalizeToArray(option.parallelAxis);zrUtil.each(axes,function(axisOption){if(zrUtil.isObject(axisOption)){var parallelIndex=axisOption.parallelIndex||0,parallelOption=modelUtil.normalizeToArray(option.parallel)[parallelIndex];parallelOption&&parallelOption.parallelAxisDefault&&zrUtil.merge(axisOption,parallelOption.parallelAxisDefault,!1)}})}var zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5);module.exports=function(option){createParallelIfNeeded(option),mergeAxisOptionFromParallel(option)}},/* 227 */
/***/
function(module,exports,__webpack_require__){function translateCategoryValue(axisModel,dim,rawData){var axisData=axisModel.get("data"),numberDim=+dim.replace("dim","");axisData&&axisData.length&&zrUtil.each(rawData,function(dataItem){if(dataItem){var index=zrUtil.indexOf(axisData,dataItem[numberDim]);dataItem[numberDim]=index>=0?index:NaN}})}var List=__webpack_require__(94),zrUtil=__webpack_require__(3),SeriesModel=__webpack_require__(27);module.exports=SeriesModel.extend({type:"series.parallel",dependencies:["parallel"],getInitialData:function(option,ecModel){var parallelModel=ecModel.getComponent("parallel",this.get("parallelIndex")),dimensions=parallelModel.dimensions,parallelAxisIndices=parallelModel.parallelAxisIndex,rawData=option.data,dimensionsInfo=zrUtil.map(dimensions,function(dim,index){var axisModel=ecModel.getComponent("parallelAxis",parallelAxisIndices[index]);return"category"===axisModel.get("type")?(translateCategoryValue(axisModel,dim,rawData),{name:dim,type:"ordinal"}):dim}),list=new List(dimensionsInfo,this);return list.initData(rawData),list},/**
	         * User can get data raw indices on 'axisAreaSelected' event received.
	         *
	         * @public
	         * @param {string} activeState 'active' or 'inactive' or 'normal'
	         * @return {Array.<number>} Raw indices
	         */
getRawIndicesByActiveState:function(activeState){var coordSys=this.coordinateSystem,data=this.getData(),indices=[];return coordSys.eachActiveState(data,function(theActiveState,dataIndex){activeState===theActiveState&&indices.push(data.getRawIndex(dataIndex))}),indices},defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:"parallel",parallelIndex:0,
// FIXME 尚无用
label:{normal:{show:!1},emphasis:{show:!1}},inactiveOpacity:.05,activeOpacity:1,lineStyle:{normal:{width:2,opacity:.45,type:"solid"}},
// smooth: false
animationEasing:"linear"}})},/* 228 */
/***/
function(module,exports,__webpack_require__){function createGridClipShape(coordSys,seriesModel,cb){var parallelModel=coordSys.model,rect=coordSys.getRect(),rectEl=new graphic.Rect({shape:{x:rect.x,y:rect.y,width:rect.width,height:rect.height}}),dim="horizontal"===parallelModel.get("layout")?"width":"height";return rectEl.setShape(dim,0),graphic.initProps(rectEl,{shape:{width:rect.width,height:rect.height}},seriesModel,cb),rectEl}function eachAxisPair(values,dimensions,coordSys,cb){for(var i=0,len=dimensions.length-1;len>i;i++){var dimA=dimensions[i],dimB=dimensions[i+1],valueA=values[i],valueB=values[i+1];cb(isEmptyValue(valueA,coordSys.getAxis(dimA).type)||isEmptyValue(valueB,coordSys.getAxis(dimB).type)?null:[coordSys.dataToPoint(valueA,dimA),coordSys.dataToPoint(valueB,dimB)],i)}}function createEl(pointPair){return new graphic.Polyline({shape:{points:pointPair},silent:!0})}
// FIXME
// 公用方法?
function isEmptyValue(val,axisType){return"category"===axisType?null==val:null==val||isNaN(val)}var graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),ParallelView=__webpack_require__(41).extend({type:"parallel",init:function(){/**
	             * @type {module:zrender/container/Group}
	             * @private
	             */
this._dataGroup=new graphic.Group,this.group.add(this._dataGroup),/**
	             * @type {module:echarts/data/List}
	             */
this._data},/**
	         * @override
	         */
render:function(seriesModel,ecModel,api,payload){function add(newDataIndex){var values=data.getValues(dimensions,newDataIndex),elGroup=new graphic.Group;dataGroup.add(elGroup),eachAxisPair(values,dimensions,coordSys,function(pointPair,pairIndex){
// FIXME
// init animation
pointPair&&elGroup.add(createEl(pointPair))}),data.setItemGraphicEl(newDataIndex,elGroup)}function update(newDataIndex,oldDataIndex){var values=data.getValues(dimensions,newDataIndex),elGroup=oldData.getItemGraphicEl(oldDataIndex),newEls=[],elGroupIndex=0;eachAxisPair(values,dimensions,coordSys,function(pointPair,pairIndex){var el=elGroup.childAt(elGroupIndex++);pointPair&&!el?newEls.push(createEl(pointPair)):pointPair&&graphic.updateProps(el,{shape:{points:pointPair}},seriesModel)});
// Remove redundent els
for(var i=elGroup.childCount()-1;i>=elGroupIndex;i--)elGroup.remove(elGroup.childAt(i));
// Add new els
for(var i=0,len=newEls.length;len>i;i++)elGroup.add(newEls[i]);data.setItemGraphicEl(newDataIndex,elGroup)}function remove(oldDataIndex){var elGroup=oldData.getItemGraphicEl(oldDataIndex);dataGroup.remove(elGroup)}var dataGroup=this._dataGroup,data=seriesModel.getData(),oldData=this._data,coordSys=seriesModel.coordinateSystem,dimensions=coordSys.dimensions;data.diff(oldData).add(add).update(update).remove(remove).execute(),
// Update style
data.eachItemGraphicEl(function(elGroup,idx){var itemModel=data.getItemModel(idx),lineStyleModel=itemModel.getModel("lineStyle.normal");elGroup.eachChild(function(child){child.setStyle(zrUtil.extend(lineStyleModel.getLineStyle(),{stroke:data.getItemVisual(idx,"color"),opacity:data.getItemVisual(idx,"opacity")}))})}),
// First create
this._data||dataGroup.setClipPath(createGridClipShape(coordSys,seriesModel,function(){dataGroup.removeClipPath()})),this._data=data},/**
	         * @override
	         */
remove:function(){this._dataGroup&&this._dataGroup.removeAll(),this._data=null}});module.exports=ParallelView},/* 229 */
/***/
function(module,exports){/**
	     * @payload
	     * @property {string} parallelAxisId
	     * @property {Array.<number>} extent
	     */
module.exports=function(ecModel,payload){ecModel.eachSeriesByType("parallel",function(seriesModel){var itemStyleModel=seriesModel.getModel("itemStyle.normal"),globalColors=ecModel.get("color"),color=itemStyleModel.get("color")||globalColors[seriesModel.seriesIndex%globalColors.length],inactiveOpacity=seriesModel.get("inactiveOpacity"),activeOpacity=seriesModel.get("activeOpacity"),lineStyle=seriesModel.getModel("lineStyle.normal").getLineStyle(),coordSys=seriesModel.coordinateSystem,data=seriesModel.getData(),opacityMap={normal:lineStyle.opacity,active:activeOpacity,inactive:inactiveOpacity};coordSys.eachActiveState(data,function(activeState,dataIndex){data.setItemVisual(dataIndex,"opacity",opacityMap[activeState])}),data.setVisual("color",color)})}},/* 230 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(231),__webpack_require__(232),echarts.registerLayout(__webpack_require__(233)),echarts.registerVisualCoding("chart",__webpack_require__(235))},/* 231 */
/***/
function(module,exports,__webpack_require__){"use strict";var SeriesModel=__webpack_require__(27),createGraphFromNodeEdge=__webpack_require__(191);module.exports=SeriesModel.extend({type:"series.sankey",layoutInfo:null,getInitialData:function(option,ecModel){var links=option.edges||option.links,nodes=option.data||option.nodes;if(nodes&&links){var graph=createGraphFromNodeEdge(nodes,links,this,!0);return graph.data}},/**
	         * @return {module:echarts/data/Graph}
	         */
getGraph:function(){return this.getData().graph},/**
	         * return {module:echarts/data/List}
	         */
getEdgeData:function(){return this.getGraph().edgeData},defaultOption:{zlevel:0,z:2,coordinateSystem:"view",layout:null,
// the position of the whole view
left:"5%",top:"5%",right:"20%",bottom:"5%",
// the dx of the node
nodeWidth:20,
// the distance between two nodes
nodeGap:8,
// the number of iterations to change the position of the node
layoutIterations:32,label:{normal:{show:!0,position:"right",textStyle:{color:"#000",fontSize:12}},emphasis:{show:!0}},itemStyle:{normal:{borderWidth:1,borderColor:"#aaa"}},lineStyle:{normal:{color:"#314656",opacity:.2,curveness:.5},emphasis:{opacity:.6}},
// colorEncoded node
color:["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"],animationEasing:"linear",animationDuration:1e3}})},/* 232 */
/***/
function(module,exports,__webpack_require__){
//add animation to the view
function createGridClipShape(rect,seriesModel,cb){var rectEl=new graphic.Rect({shape:{x:rect.x-10,y:rect.y-10,width:0,height:rect.height+20}});return graphic.initProps(rectEl,{shape:{width:rect.width+20,height:rect.height+20}},seriesModel,cb),rectEl}var graphic=__webpack_require__(42),modelUtil=__webpack_require__(5),zrUtil=__webpack_require__(3),SankeyShape=graphic.extendShape({shape:{x1:0,y1:0,x2:0,y2:0,cpx1:0,cpy1:0,cpx2:0,cpy2:0,extent:0},buildPath:function(ctx,shape){var halfExtent=shape.extent/2;ctx.moveTo(shape.x1,shape.y1-halfExtent),ctx.bezierCurveTo(shape.cpx1,shape.cpy1-halfExtent,shape.cpx2,shape.cpy2-halfExtent,shape.x2,shape.y2-halfExtent),ctx.lineTo(shape.x2,shape.y2+halfExtent),ctx.bezierCurveTo(shape.cpx2,shape.cpy2+halfExtent,shape.cpx1,shape.cpy1+halfExtent,shape.x1,shape.y1+halfExtent),ctx.closePath()}});module.exports=__webpack_require__(1).extendChartView({type:"sankey",/**
	         * @private
	         * @type {module:echarts/chart/sankey/SankeySeries}
	         */
_model:null,render:function(seriesModel,ecModel,api){var graph=seriesModel.getGraph(),group=this.group,layoutInfo=seriesModel.layoutInfo;this._model=seriesModel,group.removeAll(),group.position=[layoutInfo.x,layoutInfo.y];var edgeData=graph.edgeData,rawOption=seriesModel.option,formatModel=modelUtil.createDataFormatModel(seriesModel,edgeData,rawOption.edges||rawOption.links);formatModel.formatTooltip=function(dataIndex){var params=this.getDataParams(dataIndex),rawDataOpt=params.data,html=rawDataOpt.source+" -- "+rawDataOpt.target;return params.value&&(html+=":"+params.value),html},
// generate a rect  for each node
graph.eachNode(function(node){var layout=node.getLayout(),itemModel=node.getModel(),labelModel=itemModel.getModel("label.normal"),textStyleModel=labelModel.getModel("textStyle"),labelHoverModel=itemModel.getModel("label.emphasis"),textStyleHoverModel=labelHoverModel.getModel("textStyle"),rect=new graphic.Rect({shape:{x:layout.x,y:layout.y,width:node.getLayout().dx,height:node.getLayout().dy},style:{
// Get formatted label in label.normal option. Use node id if it is not specified
text:labelModel.get("show")?seriesModel.getFormattedLabel(node.dataIndex,"normal")||node.id:"",textFont:textStyleModel.getFont(),textFill:textStyleModel.getTextColor(),textPosition:labelModel.get("position")}});rect.setStyle(zrUtil.defaults({fill:node.getVisual("color")},itemModel.getModel("itemStyle.normal").getItemStyle())),graphic.setHoverStyle(rect,zrUtil.extend(node.getModel("itemStyle.emphasis"),{text:labelHoverModel.get("show")?seriesModel.getFormattedLabel(node.dataIndex,"emphasis")||node.id:"",textFont:textStyleHoverModel.getFont(),textFill:textStyleHoverModel.getTextColor(),textPosition:labelHoverModel.get("position")})),group.add(rect)}),
// generate a bezire Curve for each edge
graph.eachEdge(function(edge){var curve=new SankeyShape;curve.dataIndex=edge.dataIndex,curve.dataModel=formatModel;var lineStyleModel=edge.getModel("lineStyle.normal"),curvature=lineStyleModel.get("curveness"),n1Layout=edge.node1.getLayout(),n2Layout=edge.node2.getLayout(),edgeLayout=edge.getLayout();curve.shape.extent=Math.max(1,edgeLayout.dy);var x1=n1Layout.x+n1Layout.dx,y1=n1Layout.y+edgeLayout.sy+edgeLayout.dy/2,x2=n2Layout.x,y2=n2Layout.y+edgeLayout.ty+edgeLayout.dy/2,cpx1=x1*(1-curvature)+x2*curvature,cpy1=y1,cpx2=x1*curvature+x2*(1-curvature),cpy2=y2;curve.setShape({x1:x1,y1:y1,x2:x2,y2:y2,cpx1:cpx1,cpy1:cpy1,cpx2:cpx2,cpy2:cpy2}),curve.setStyle(lineStyleModel.getItemStyle()),graphic.setHoverStyle(curve,edge.getModel("lineStyle.emphasis").getItemStyle()),group.add(curve)}),this._data||group.setClipPath(createGridClipShape(group.getBoundingRect(),seriesModel,function(){group.removeClipPath()})),this._data=seriesModel.getData()}})},/* 233 */
/***/
function(module,exports,__webpack_require__){/**
	     * get the layout position of the whole view.
	     */
function getViewRect(seriesModel,api){return layout.getLayoutRect(seriesModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()})}function layoutSankey(nodes,edges,nodeWidth,nodeGap,width,height,iterations){computeNodeBreadths(nodes,nodeWidth,width),computeNodeDepths(nodes,edges,height,nodeGap,iterations),computeEdgeDepths(nodes)}/**
	     * compute the value of each node by summing the associated edge's value.
	     * @param {module:echarts/data/Graph~Node} nodes
	     */
function computeNodeValues(nodes){zrUtil.each(nodes,function(node){var value1=sum(node.outEdges,getEdgeValue),value2=sum(node.inEdges,getEdgeValue),value=Math.max(value1,value2);node.setLayout({value:value},!0)})}/**
	     * compute the x-position for each node.
	     * @param {module:echarts/data/Graph~Node} nodes
	     * @param  {number} nodeWidth
	     * @param  {number} width
	     */
function computeNodeBreadths(nodes,nodeWidth,width){for(var remainNodes=nodes,nextNode=null,x=0,kx=0;remainNodes.length;){nextNode=[];for(var i=0,len=remainNodes.length;len>i;i++){var node=remainNodes[i];node.setLayout({x:x},!0),node.setLayout({dx:nodeWidth},!0);for(var j=0,lenj=node.outEdges.length;lenj>j;j++)nextNode.push(node.outEdges[j].node2)}remainNodes=nextNode,++x}moveSinksRight(nodes,x),kx=(width-nodeWidth)/(x-1),scaleNodeBreadths(nodes,kx)}/**
	     * all the node without outEgdes are assigned maximum breadth and
	     * be aligned in the last column.
	     * @param {module:echarts/data/Graph~Node} nodes
	     * @param {number} x
	     */
function moveSinksRight(nodes,x){zrUtil.each(nodes,function(node){node.outEdges.length||node.setLayout({x:x-1},!0)})}/**
	     * scale node x-position to the width.
	     * @param {module:echarts/data/Graph~Node} nodes
	     * @param {number} kx
	     */
function scaleNodeBreadths(nodes,kx){zrUtil.each(nodes,function(node){var nodeX=node.getLayout().x*kx;node.setLayout({x:nodeX},!0)})}/**
	     * using Gauss-Seidel iterations method to compute the node depth(y-position).
	     * @param {module:echarts/data/Graph~Node} nodes
	     * @param {module:echarts/data/Graph~Edge} edges
	     * @param {number} height
	     * @param {numbber} nodeGap
	     * @param {number} iterations
	     */
function computeNodeDepths(nodes,edges,height,nodeGap,iterations){var nodesByBreadth=nest().key(function(d){return d.getLayout().x}).sortKeys(ascending).entries(nodes).map(function(d){return d.values});initializeNodeDepth(nodes,nodesByBreadth,edges,height,nodeGap),resolveCollisions(nodesByBreadth,nodeGap,height);for(var alpha=1;iterations>0;iterations--)alpha*=.99,relaxRightToLeft(nodesByBreadth,alpha),resolveCollisions(nodesByBreadth,nodeGap,height),relaxLeftToRight(nodesByBreadth,alpha),resolveCollisions(nodesByBreadth,nodeGap,height)}/**
	     * compute the original y-position for each node.
	     * @param {module:echarts/data/Graph~Node} nodes
	     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
	     * @param {module:echarts/data/Graph~Edge} edges
	     * @param {number} height
	     * @param {number} nodeGap
	     */
function initializeNodeDepth(nodes,nodesByBreadth,edges,height,nodeGap){var kyArray=[];zrUtil.each(nodesByBreadth,function(nodes){var n=nodes.length,sum=0;zrUtil.each(nodes,function(node){sum+=node.getLayout().value});var ky=(height-(n-1)*nodeGap)/sum;kyArray.push(ky)}),kyArray.sort(function(a,b){return a-b});var ky0=kyArray[0];zrUtil.each(nodesByBreadth,function(nodes){zrUtil.each(nodes,function(node,i){node.setLayout({y:i},!0);var nodeDy=node.getLayout().value*ky0;node.setLayout({dy:nodeDy},!0)})}),zrUtil.each(edges,function(edge){var edgeDy=+edge.getValue()*ky0;edge.setLayout({dy:edgeDy},!0)})}/**
	     * resolve the collision of initialized depth.
	     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
	     * @param {number} nodeGap
	     * @param {number} height
	     */
function resolveCollisions(nodesByBreadth,nodeGap,height){zrUtil.each(nodesByBreadth,function(nodes){var node,dy,i,y0=0,n=nodes.length;for(nodes.sort(ascendingDepth),i=0;n>i;i++){if(node=nodes[i],dy=y0-node.getLayout().y,dy>0){var nodeY=node.getLayout().y+dy;node.setLayout({y:nodeY},!0)}y0=node.getLayout().y+node.getLayout().dy+nodeGap}if(dy=y0-nodeGap-height,dy>0){var nodeY=node.getLayout().y-dy;for(node.setLayout({y:nodeY},!0),y0=node.getLayout().y,i=n-2;i>=0;--i)node=nodes[i],dy=node.getLayout().y+node.getLayout().dy+nodeGap-y0,dy>0&&(nodeY=node.getLayout().y-dy,node.setLayout({y:nodeY},!0)),y0=node.getLayout().y}})}/**
	     * change the y-position of the nodes, except most the right side nodes.
	     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
	     * @param {number} alpha
	     */
function relaxRightToLeft(nodesByBreadth,alpha){zrUtil.each(nodesByBreadth.slice().reverse(),function(nodes){zrUtil.each(nodes,function(node){if(node.outEdges.length){var y=sum(node.outEdges,weightedTarget)/sum(node.outEdges,getEdgeValue),nodeY=node.getLayout().y+(y-center(node))*alpha;node.setLayout({y:nodeY},!0)}})})}function weightedTarget(edge){return center(edge.node2)*edge.getValue()}/**
	     * change the y-position of the nodes, except most the left side nodes.
	     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
	     * @param {number} alpha
	     */
function relaxLeftToRight(nodesByBreadth,alpha){zrUtil.each(nodesByBreadth,function(nodes){zrUtil.each(nodes,function(node){if(node.inEdges.length){var y=sum(node.inEdges,weightedSource)/sum(node.inEdges,getEdgeValue),nodeY=node.getLayout().y+(y-center(node))*alpha;node.setLayout({y:nodeY},!0)}})})}function weightedSource(edge){return center(edge.node1)*edge.getValue()}/**
	     * compute the depth(y-position) of each edge.
	     * @param {module:echarts/data/Graph~Node} nodes
	     */
function computeEdgeDepths(nodes){zrUtil.each(nodes,function(node){node.outEdges.sort(ascendingTargetDepth),node.inEdges.sort(ascendingSourceDepth)}),zrUtil.each(nodes,function(node){var sy=0,ty=0;zrUtil.each(node.outEdges,function(edge){edge.setLayout({sy:sy},!0),sy+=edge.getLayout().dy}),zrUtil.each(node.inEdges,function(edge){edge.setLayout({ty:ty},!0),ty+=edge.getLayout().dy})})}function ascendingTargetDepth(a,b){return a.node2.getLayout().y-b.node2.getLayout().y}function ascendingSourceDepth(a,b){return a.node1.getLayout().y-b.node1.getLayout().y}function sum(array,f){var a,s=0,n=array.length,i=-1;if(1===arguments.length)for(;++i<n;)a=+array[i],isNaN(a)||(s+=a);else for(;++i<n;)a=+f.call(array,array[i],i),isNaN(a)||(s+=a);return s}function center(node){return node.getLayout().y+node.getLayout().dy/2}function ascendingDepth(a,b){return a.getLayout().y-b.getLayout().y}function ascending(a,b){return b>a?-1:a>b?1:a==b?0:NaN}function getEdgeValue(edge){return edge.getValue()}var layout=__webpack_require__(21),nest=__webpack_require__(234),zrUtil=__webpack_require__(3);module.exports=function(ecModel,api){ecModel.eachSeriesByType("sankey",function(seriesModel){var nodeWidth=seriesModel.get("nodeWidth"),nodeGap=seriesModel.get("nodeGap"),layoutInfo=getViewRect(seriesModel,api);seriesModel.layoutInfo=layoutInfo;var width=layoutInfo.width,height=layoutInfo.height,graph=seriesModel.getGraph(),nodes=graph.nodes,edges=graph.edges;computeNodeValues(nodes);var filteredNodes=nodes.filter(function(node){return 0===node.getLayout().value}),iterations=0!==filteredNodes.length?0:seriesModel.get("layoutIterations");layoutSankey(nodes,edges,nodeWidth,nodeGap,width,height,iterations)})}},/* 234 */
/***/
function(module,exports,__webpack_require__){/**
	     * nest helper used to group by the array.
	     * can specified the keys and sort the keys.
	     */
function nest(){/**
	         * map an Array into the mapObject.
	         * @param {Array} array
	         * @param {number} depth
	         */
function map(array,depth){if(depth>=keysFunction.length)return array;for(var i=-1,n=array.length,keyFunction=keysFunction[depth++],mapObject={},valuesByKey={};++i<n;){var keyValue=keyFunction(array[i]),values=valuesByKey[keyValue];values?values.push(array[i]):valuesByKey[keyValue]=[array[i]]}return zrUtil.each(valuesByKey,function(value,key){mapObject[key]=map(value,depth)}),mapObject}/**
	         * transform the Map Object to multidimensional Array
	         * @param {Object} map
	         * @param {number} depth
	         */
function entriesMap(mapObject,depth){if(depth>=keysFunction.length)return mapObject;var array=[],sortKeyFunction=sortKeysFunction[depth++];return zrUtil.each(mapObject,function(value,key){array.push({key:key,values:entriesMap(value,depth)})}),sortKeyFunction?array.sort(function(a,b){return sortKeyFunction(a.key,b.key)}):array}var keysFunction=[],sortKeysFunction=[];return{/**
	             * specified the key to groupby the arrays.
	             * users can specified one more keys.
	             * @param {Function} d
	             */
key:function(d){return keysFunction.push(d),this},/**
	             * specified the comparator to sort the keys
	             * @param {Function} order
	             */
sortKeys:function(order){return sortKeysFunction[keysFunction.length-1]=order,this},/**
	             * the array to be grouped by.
	             * @param {Array} array
	             */
entries:function(array){return entriesMap(map(array,0),0)}}}var zrUtil=__webpack_require__(3);module.exports=nest},/* 235 */
/***/
function(module,exports,__webpack_require__){var VisualMapping=__webpack_require__(187);module.exports=function(ecModel,payload){ecModel.eachSeriesByType("sankey",function(seriesModel){var graph=seriesModel.getGraph(),nodes=graph.nodes;nodes.sort(function(a,b){return a.getLayout().value-b.getLayout().value});var minValue=nodes[0].getLayout().value,maxValue=nodes[nodes.length-1].getLayout().value;nodes.forEach(function(node){var mapping=new VisualMapping({type:"color",mappingMethod:"linear",dataExtent:[minValue,maxValue],visual:seriesModel.get("color")}),mapValueToColor=mapping.mapValueToVisual(node.getLayout().value);node.setVisual("color",mapValueToColor)})})}},/* 236 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(237),__webpack_require__(240),echarts.registerVisualCoding("chart",__webpack_require__(241)),echarts.registerLayout(__webpack_require__(242))},/* 237 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),SeriesModel=__webpack_require__(27),whiskerBoxCommon=__webpack_require__(238),BoxplotSeries=SeriesModel.extend({type:"series.boxplot",dependencies:["xAxis","yAxis","grid"],
// TODO
// box width represents group size, so dimension should have 'size'.
/**
	         * @see <https://en.wikipedia.org/wiki/Box_plot>
	         * The meanings of 'min' and 'max' depend on user,
	         * and echarts do not need to know it.
	         * @readOnly
	         */
valueDimensions:["min","Q1","median","Q3","max"],/**
	         * @type {Array.<string>}
	         * @readOnly
	         */
dimensions:null,/**
	         * @override
	         */
defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:"cartesian2d",legendHoverLink:!0,hoverAnimation:!0,xAxisIndex:0,yAxisIndex:0,layout:null,// 'horizontal' or 'vertical'
boxWidth:[7,50],// [min, max] can be percent of band width.
itemStyle:{normal:{color:"#fff",borderWidth:1},emphasis:{borderWidth:2,shadowBlur:5,shadowOffsetX:2,shadowOffsetY:2,shadowColor:"rgba(0,0,0,0.4)"}},animationEasing:"elasticOut",animationDuration:800}});zrUtil.mixin(BoxplotSeries,whiskerBoxCommon.seriesModelMixin,!0),module.exports=BoxplotSeries},/* 238 */
/***/
function(module,exports,__webpack_require__){"use strict";function getItemValue(item){return null==item.value?item:item.value}var List=__webpack_require__(94),completeDimensions=__webpack_require__(96),WhiskerBoxDraw=__webpack_require__(239),zrUtil=__webpack_require__(3),seriesModelMixin={/**
	         * @private
	         * @type {string}
	         */
_baseAxisDim:null,/**
	         * @override
	         */
getInitialData:function(option,ecModel){
// When both types of xAxis and yAxis are 'value', layout is
// needed to be specified by user. Otherwise, layout can be
// judged by which axis is category.
var categories,addOrdinal,xAxisModel=ecModel.getComponent("xAxis",this.get("xAxisIndex")),yAxisModel=ecModel.getComponent("yAxis",this.get("yAxisIndex")),xAxisType=xAxisModel.get("type"),yAxisType=yAxisModel.get("type");
// FIXME
// 考虑时间轴
"category"===xAxisType?(option.layout="horizontal",categories=xAxisModel.getCategories(),addOrdinal=!0):"category"===yAxisType?(option.layout="vertical",categories=yAxisModel.getCategories(),addOrdinal=!0):option.layout=option.layout||"horizontal",this._baseAxisDim="horizontal"===option.layout?"x":"y";var data=option.data,dimensions=this.dimensions=["base"].concat(this.valueDimensions);completeDimensions(dimensions,data);var list=new List(dimensions,this);return list.initData(data,categories?categories.slice():null,function(dataItem,dimName,idx,dimIdx){var value=getItemValue(dataItem);return addOrdinal?"base"===dimName?idx:value[dimIdx-1]:value[dimIdx]}),list},/**
	         * Used by Gird.
	         * @param {string} axisDim 'x' or 'y'
	         * @return {Array.<string>} dimensions on the axis.
	         */
coordDimToDataDim:function(axisDim){var dims=this.valueDimensions.slice(),baseDim=["base"],map={horizontal:{x:baseDim,y:dims},vertical:{x:dims,y:baseDim}};return map[this.get("layout")][axisDim]},/**
	         * @override
	         * @param {string|number} dataDim
	         * @return {string} coord dimension
	         */
dataDimToCoordDim:function(dataDim){var dim;return zrUtil.each(["x","y"],function(coordDim,index){var dataDims=this.coordDimToDataDim(coordDim);zrUtil.indexOf(dataDims,dataDim)>=0&&(dim=coordDim)},this),dim},/**
	         * If horizontal, base axis is x, otherwise y.
	         * @override
	         */
getBaseAxis:function(){var dim=this._baseAxisDim;return this.ecModel.getComponent(dim+"Axis",this.get(dim+"AxisIndex")).axis}},viewMixin={init:function(){/**
	             * Old data.
	             * @private
	             * @type {module:echarts/chart/helper/WhiskerBoxDraw}
	             */
var whiskerBoxDraw=this._whiskerBoxDraw=new WhiskerBoxDraw(this.getStyleUpdater());this.group.add(whiskerBoxDraw.group)},render:function(seriesModel,ecModel,api){this._whiskerBoxDraw.updateData(seriesModel.getData())},remove:function(ecModel){this._whiskerBoxDraw.remove()}};module.exports={seriesModelMixin:seriesModelMixin,viewMixin:viewMixin}},/* 239 */
/***/
function(module,exports,__webpack_require__){/**
	     * @constructor
	     * @alias {module:echarts/chart/helper/WhiskerBox}
	     * @param {module:echarts/data/List} data
	     * @param {number} idx
	     * @param {Function} styleUpdater
	     * @param {boolean} isInit
	     * @extends {module:zrender/graphic/Group}
	     */
function WhiskerBox(data,idx,styleUpdater,isInit){graphic.Group.call(this),/**
	         * @type {number}
	         * @readOnly
	         */
this.bodyIndex,/**
	         * @type {number}
	         * @readOnly
	         */
this.whiskerIndex,/**
	         * @type {Function}
	         */
this.styleUpdater=styleUpdater,this._createContent(data,idx,isInit),this.updateData(data,idx,isInit),/**
	         * Last series model.
	         * @type {module:echarts/model/Series}
	         */
this._seriesModel}function transInit(points,dim,itemLayout){return zrUtil.map(points,function(point){return point=point.slice(),point[dim]=itemLayout.initBaseline,point})}function makeWhiskerEndsShape(whiskerEnds){
// zr animation only support 2-dim array.
var shape={};return zrUtil.each(whiskerEnds,function(ends,i){shape["ends"+i]=ends}),shape}/**
	     * @constructor
	     * @alias module:echarts/chart/helper/WhiskerBoxDraw
	     */
function WhiskerBoxDraw(styleUpdater){this.group=new graphic.Group,this.styleUpdater=styleUpdater}/**
	 * @module echarts/chart/helper/Symbol
	 */
var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),Path=__webpack_require__(44),WhiskerPath=Path.extend({type:"whiskerInBox",shape:{},buildPath:function(ctx,shape){for(var i in shape)if(0===i.indexOf("ends")){var pts=shape[i];ctx.moveTo(pts[0][0],pts[0][1]),ctx.lineTo(pts[1][0],pts[1][1])}}}),whiskerBoxProto=WhiskerBox.prototype;whiskerBoxProto._createContent=function(data,idx,isInit){var itemLayout=data.getItemLayout(idx),constDim="horizontal"===itemLayout.chartLayout?1:0,count=0;
// Whisker element.
this.add(new graphic.Polygon({shape:{points:isInit?transInit(itemLayout.bodyEnds,constDim,itemLayout):itemLayout.bodyEnds},style:{strokeNoScale:!0},z2:100})),this.bodyIndex=count++;
// Box element.
var whiskerEnds=zrUtil.map(itemLayout.whiskerEnds,function(ends){return isInit?transInit(ends,constDim,itemLayout):ends});this.add(new WhiskerPath({shape:makeWhiskerEndsShape(whiskerEnds),style:{strokeNoScale:!0},z2:100})),this.whiskerIndex=count++},/**
	     * Update symbol properties
	     * @param  {module:echarts/data/List} data
	     * @param  {number} idx
	     */
whiskerBoxProto.updateData=function(data,idx,isInit){var seriesModel=this._seriesModel=data.hostModel,itemLayout=data.getItemLayout(idx),updateMethod=graphic[isInit?"initProps":"updateProps"];
// this.childAt(this.bodyIndex).stopAnimation(true);
// this.childAt(this.whiskerIndex).stopAnimation(true);
updateMethod(this.childAt(this.bodyIndex),{shape:{points:itemLayout.bodyEnds}},seriesModel),updateMethod(this.childAt(this.whiskerIndex),{shape:makeWhiskerEndsShape(itemLayout.whiskerEnds)},seriesModel),this.styleUpdater.call(null,this,data,idx)},zrUtil.inherits(WhiskerBox,graphic.Group);var whiskerBoxDrawProto=WhiskerBoxDraw.prototype;/**
	     * Update symbols draw by new data
	     * @param {module:echarts/data/List} data
	     */
whiskerBoxDrawProto.updateData=function(data){var group=this.group,oldData=this._data,styleUpdater=this.styleUpdater;data.diff(oldData).add(function(newIdx){if(data.hasValue(newIdx)){var symbolEl=new WhiskerBox(data,newIdx,styleUpdater,!0);data.setItemGraphicEl(newIdx,symbolEl),group.add(symbolEl)}}).update(function(newIdx,oldIdx){var symbolEl=oldData.getItemGraphicEl(oldIdx);
// Empty data
// Empty data
// Add back
return data.hasValue(newIdx)?(symbolEl?symbolEl.updateData(data,newIdx):symbolEl=new WhiskerBox(data,newIdx,styleUpdater),group.add(symbolEl),void data.setItemGraphicEl(newIdx,symbolEl)):void group.remove(symbolEl)}).remove(function(oldIdx){var el=oldData.getItemGraphicEl(oldIdx);el&&group.remove(el)}).execute(),this._data=data},/**
	     * Remove symbols.
	     * @param {module:echarts/data/List} data
	     */
whiskerBoxDrawProto.remove=function(){var group=this.group,data=this._data;this._data=null,data&&data.eachItemGraphicEl(function(el){el&&group.remove(el)})},module.exports=WhiskerBoxDraw},/* 240 */
/***/
function(module,exports,__webpack_require__){"use strict";function updateStyle(itemGroup,data,idx){var itemModel=data.getItemModel(idx),normalItemStyleModel=itemModel.getModel(normalStyleAccessPath),borderColor=data.getItemVisual(idx,"color"),itemStyle=normalItemStyleModel.getItemStyle(["borderColor"]),whiskerEl=itemGroup.childAt(itemGroup.whiskerIndex);whiskerEl.style.set(itemStyle),whiskerEl.style.stroke=borderColor,whiskerEl.dirty();var bodyEl=itemGroup.childAt(itemGroup.bodyIndex);bodyEl.style.set(itemStyle),bodyEl.style.stroke=borderColor,bodyEl.dirty();var hoverStyle=itemModel.getModel(emphasisStyleAccessPath).getItemStyle();graphic.setHoverStyle(itemGroup,hoverStyle)}var zrUtil=__webpack_require__(3),ChartView=__webpack_require__(41),graphic=__webpack_require__(42),whiskerBoxCommon=__webpack_require__(238),BoxplotView=ChartView.extend({type:"boxplot",getStyleUpdater:function(){return updateStyle}});zrUtil.mixin(BoxplotView,whiskerBoxCommon.viewMixin,!0);
// Update common properties
var normalStyleAccessPath=["itemStyle","normal"],emphasisStyleAccessPath=["itemStyle","emphasis"];module.exports=BoxplotView},/* 241 */
/***/
function(module,exports){var borderColorQuery=["itemStyle","normal","borderColor"];module.exports=function(ecModel,api){var globalColors=ecModel.get("color");ecModel.eachRawSeriesByType("boxplot",function(seriesModel){var defaulColor=globalColors[seriesModel.seriesIndex%globalColors.length],data=seriesModel.getData();data.setVisual({legendSymbol:"roundRect",
// Use name 'color' but not 'borderColor' for legend usage and
// visual coding from other component like dataRange.
color:seriesModel.get(borderColorQuery)||defaulColor}),
// Only visible series has each data be visual encoded
ecModel.isSeriesFiltered(seriesModel)||data.each(function(idx){var itemModel=data.getItemModel(idx);data.setItemVisual(idx,{color:itemModel.get(borderColorQuery,!0)})})})}},/* 242 */
/***/
function(module,exports,__webpack_require__){/**
	     * Group series by axis.
	     */
function groupSeriesByAxis(ecModel){var result=[],axisList=[];return ecModel.eachSeriesByType("boxplot",function(seriesModel){var baseAxis=seriesModel.getBaseAxis(),idx=zrUtil.indexOf(axisList,baseAxis);0>idx&&(idx=axisList.length,axisList[idx]=baseAxis,result[idx]={axis:baseAxis,seriesModels:[]}),result[idx].seriesModels.push(seriesModel)}),result}/**
	     * Calculate offset and box width for each series.
	     */
function calculateBase(groupItem){var extent,bandWidth,baseAxis=groupItem.axis,seriesModels=groupItem.seriesModels,seriesCount=seriesModels.length,boxWidthList=groupItem.boxWidthList=[],boxOffsetList=groupItem.boxOffsetList=[],boundList=[];if("category"===baseAxis.type)bandWidth=baseAxis.getBandWidth();else{var maxDataCount=0;each(seriesModels,function(seriesModel){maxDataCount=Math.max(maxDataCount,seriesModel.getData().count())}),extent=baseAxis.getExtent(),Math.abs(extent[1]-extent[0])/maxDataCount}each(seriesModels,function(seriesModel){var boxWidthBound=seriesModel.get("boxWidth");zrUtil.isArray(boxWidthBound)||(boxWidthBound=[boxWidthBound,boxWidthBound]),boundList.push([parsePercent(boxWidthBound[0],bandWidth)||0,parsePercent(boxWidthBound[1],bandWidth)||0])});var availableWidth=.8*bandWidth-2,boxGap=availableWidth/seriesCount*.3,boxWidth=(availableWidth-boxGap*(seriesCount-1))/seriesCount,base=boxWidth/2-availableWidth/2;each(seriesModels,function(seriesModel,idx){boxOffsetList.push(base),base+=boxGap+boxWidth,boxWidthList.push(Math.min(Math.max(boxWidth,boundList[idx][0]),boundList[idx][1]))})}/**
	     * Calculate points location for each series.
	     */
function layoutSingleSeries(seriesModel,offset,boxWidth){var coordSys=seriesModel.coordinateSystem,data=seriesModel.getData(),dimensions=seriesModel.dimensions,chartLayout=seriesModel.get("layout"),halfWidth=boxWidth/2;data.each(dimensions,function(){function getPoint(val){var p=[];p[variableDim]=axisDimVal,p[constDim]=val;var point;return isNaN(axisDimVal)||isNaN(val)?point=[NaN,NaN]:(point=coordSys.dataToPoint(p),point[variableDim]+=offset),point}function addBodyEnd(point,start){var point1=point.slice(),point2=point.slice();point1[variableDim]+=halfWidth,point2[variableDim]-=halfWidth,start?bodyEnds.push(point1,point2):bodyEnds.push(point2,point1)}function layEndLine(endCenter){var line=[endCenter.slice(),endCenter.slice()];line[0][variableDim]-=halfWidth,line[1][variableDim]+=halfWidth,whiskerEnds.push(line)}var args=arguments,dimLen=dimensions.length,axisDimVal=args[0],idx=args[dimLen],variableDim="horizontal"===chartLayout?0:1,constDim=1-variableDim,median=getPoint(args[3]),end1=getPoint(args[1]),end5=getPoint(args[5]),whiskerEnds=[[end1,getPoint(args[2])],[end5,getPoint(args[4])]];layEndLine(end1),layEndLine(end5),layEndLine(median);var bodyEnds=[];addBodyEnd(whiskerEnds[0][1],0),addBodyEnd(whiskerEnds[1][1],1),data.setItemLayout(idx,{chartLayout:chartLayout,initBaseline:median[constDim],median:median,bodyEnds:bodyEnds,whiskerEnds:whiskerEnds})})}var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),parsePercent=numberUtil.parsePercent,each=zrUtil.each;module.exports=function(ecModel,api){var groupResult=groupSeriesByAxis(ecModel);each(groupResult,function(groupItem){var seriesModels=groupItem.seriesModels;seriesModels.length&&(calculateBase(groupItem),each(seriesModels,function(seriesModel,idx){layoutSingleSeries(seriesModel,groupItem.boxOffsetList[idx],groupItem.boxWidthList[idx])}))})}},/* 243 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1);__webpack_require__(244),__webpack_require__(245),echarts.registerPreprocessor(__webpack_require__(246)),echarts.registerVisualCoding("chart",__webpack_require__(247)),echarts.registerLayout(__webpack_require__(248))},/* 244 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),SeriesModel=__webpack_require__(27),whiskerBoxCommon=__webpack_require__(238),formatUtil=__webpack_require__(6),encodeHTML=formatUtil.encodeHTML,addCommas=formatUtil.addCommas,CandlestickSeries=SeriesModel.extend({type:"series.candlestick",dependencies:["xAxis","yAxis","grid"],/**
	         * @readOnly
	         */
valueDimensions:["open","close","lowest","highest"],/**
	         * @type {Array.<string>}
	         * @readOnly
	         */
dimensions:null,/**
	         * @override
	         */
defaultOption:{zlevel:0,// 一级层叠
z:2,// 二级层叠
coordinateSystem:"cartesian2d",legendHoverLink:!0,hoverAnimation:!0,xAxisIndex:0,yAxisIndex:0,layout:null,// 'horizontal' or 'vertical'
itemStyle:{normal:{color:"#c23531",// 阳线 positive
color0:"#314656",// 阴线 negative     '#c23531', '#314656'
borderWidth:1,
// FIXME
// ec2中使用的是lineStyle.color 和 lineStyle.color0
borderColor:"#c23531",borderColor0:"#314656"},emphasis:{borderWidth:2}},animationUpdate:!1,animationEasing:"linear",animationDuration:300},/**
	         * Get dimension for shadow in dataZoom
	         * @return {string} dimension name
	         */
getShadowDim:function(){return"open"},/**
	         * @override
	         */
formatTooltip:function(dataIndex,mutipleSeries){
// It rearly use mutiple candlestick series in one cartesian,
// so only consider one series in this default tooltip.
var valueHTMLArr=zrUtil.map(this.valueDimensions,function(dim){return dim+": "+addCommas(this._data.get(dim,dataIndex))},this);return encodeHTML(this.name)+"<br />"+valueHTMLArr.join("<br />")}});zrUtil.mixin(CandlestickSeries,whiskerBoxCommon.seriesModelMixin,!0),module.exports=CandlestickSeries},/* 245 */
/***/
function(module,exports,__webpack_require__){"use strict";function updateStyle(itemGroup,data,idx){var itemModel=data.getItemModel(idx),normalItemStyleModel=itemModel.getModel(normalStyleAccessPath),color=data.getItemVisual(idx,"color"),borderColor=data.getItemVisual(idx,"borderColor"),itemStyle=normalItemStyleModel.getItemStyle(["color","color0","borderColor","borderColor0"]),whiskerEl=itemGroup.childAt(itemGroup.whiskerIndex);whiskerEl.style.set(itemStyle),whiskerEl.style.stroke=borderColor,whiskerEl.dirty();var bodyEl=itemGroup.childAt(itemGroup.bodyIndex);bodyEl.style.set(itemStyle),bodyEl.style.fill=color,bodyEl.style.stroke=borderColor,bodyEl.dirty();var hoverStyle=itemModel.getModel(emphasisStyleAccessPath).getItemStyle();graphic.setHoverStyle(itemGroup,hoverStyle)}var zrUtil=__webpack_require__(3),ChartView=__webpack_require__(41),graphic=__webpack_require__(42),whiskerBoxCommon=__webpack_require__(238),CandlestickView=ChartView.extend({type:"candlestick",getStyleUpdater:function(){return updateStyle}});zrUtil.mixin(CandlestickView,whiskerBoxCommon.viewMixin,!0);
// Update common properties
var normalStyleAccessPath=["itemStyle","normal"],emphasisStyleAccessPath=["itemStyle","emphasis"];module.exports=CandlestickView},/* 246 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3);module.exports=function(option){option&&zrUtil.isArray(option.series)&&
// Translate 'k' to 'candlestick'.
zrUtil.each(option.series,function(seriesItem){zrUtil.isObject(seriesItem)&&"k"===seriesItem.type&&(seriesItem.type="candlestick")})}},/* 247 */
/***/
function(module,exports){var positiveBorderColorQuery=["itemStyle","normal","borderColor"],negativeBorderColorQuery=["itemStyle","normal","borderColor0"],positiveColorQuery=["itemStyle","normal","color"],negativeColorQuery=["itemStyle","normal","color0"];module.exports=function(ecModel,api){ecModel.eachRawSeriesByType("candlestick",function(seriesModel){var data=seriesModel.getData();data.setVisual({legendSymbol:"roundRect"}),
// Only visible series has each data be visual encoded
ecModel.isSeriesFiltered(seriesModel)||data.each(function(idx){var itemModel=data.getItemModel(idx),sign=data.getItemLayout(idx).sign;data.setItemVisual(idx,{color:itemModel.get(sign>0?positiveColorQuery:negativeColorQuery),borderColor:itemModel.get(sign>0?positiveBorderColorQuery:negativeBorderColorQuery)})})})}},/* 248 */
/***/
function(module,exports){function calculateCandleWidth(seriesModel,data){var extent,baseAxis=seriesModel.getBaseAxis(),bandWidth="category"===baseAxis.type?baseAxis.getBandWidth():(extent=baseAxis.getExtent(),Math.abs(extent[1]-extent[0])/data.count());
// Half band width is perfect when space is enouph, otherwise
// try not to be smaller than CANDLE_MIN_NICE_WIDTH (and only
// gap is compressed), otherwise ensure not to be smaller than
// CANDLE_MIN_WIDTH in spite of overlap.
return bandWidth/2-2>CANDLE_MIN_NICE_WIDTH?bandWidth/2-2:bandWidth-CANDLE_MIN_NICE_WIDTH>GPA_MIN?CANDLE_MIN_NICE_WIDTH:Math.max(bandWidth-GPA_MIN,CANDLE_MIN_WIDTH)}var CANDLE_MIN_WIDTH=2,CANDLE_MIN_NICE_WIDTH=5,GPA_MIN=4;module.exports=function(ecModel,api){ecModel.eachSeriesByType("candlestick",function(seriesModel){var coordSys=seriesModel.coordinateSystem,data=seriesModel.getData(),dimensions=seriesModel.dimensions,chartLayout=seriesModel.get("layout"),candleWidth=calculateCandleWidth(seriesModel,data);data.each(dimensions,function(){function getPoint(val){var p=[];return p[variableDim]=axisDimVal,p[constDim]=val,isNaN(axisDimVal)||isNaN(val)?[NaN,NaN]:coordSys.dataToPoint(p)}function addBodyEnd(point,start){var point1=point.slice(),point2=point.slice();point1[variableDim]+=candleWidth/2,point2[variableDim]-=candleWidth/2,start?bodyEnds.push(point1,point2):bodyEnds.push(point2,point1)}var args=arguments,dimLen=dimensions.length,axisDimVal=args[0],idx=args[dimLen],variableDim="horizontal"===chartLayout?0:1,constDim=1-variableDim,openVal=args[1],closeVal=args[2],lowestVal=args[3],highestVal=args[4],ocLow=Math.min(openVal,closeVal),ocHigh=Math.max(openVal,closeVal),ocLowPoint=getPoint(ocLow),ocHighPoint=getPoint(ocHigh),lowestPoint=getPoint(lowestVal),highestPoint=getPoint(highestVal),whiskerEnds=[[highestPoint,ocHighPoint],[lowestPoint,ocLowPoint]],bodyEnds=[];addBodyEnd(ocHighPoint,0),addBodyEnd(ocLowPoint,1),data.setItemLayout(idx,{chartLayout:chartLayout,sign:openVal>closeVal?-1:closeVal>openVal?1:0,initBaseline:openVal>closeVal?ocHighPoint[constDim]:ocLowPoint[constDim],// open point.
bodyEnds:bodyEnds,whiskerEnds:whiskerEnds})},!0)})}},/* 249 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);__webpack_require__(250),__webpack_require__(251),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(103),"effectScatter","circle",null)),echarts.registerLayout(zrUtil.curry(__webpack_require__(104),"effectScatter"))},/* 250 */
/***/
function(module,exports,__webpack_require__){"use strict";var createListFromArray=__webpack_require__(93),SeriesModel=__webpack_require__(27);module.exports=SeriesModel.extend({type:"series.effectScatter",dependencies:["grid","polar"],getInitialData:function(option,ecModel){var list=createListFromArray(option.data,this,ecModel);return list},defaultOption:{coordinateSystem:"cartesian2d",zlevel:0,z:2,legendHoverLink:!0,effectType:"ripple",
// When to show the effect, option: 'render'|'emphasis'
showEffectOn:"render",
// Ripple effect config
rippleEffect:{period:4,
// Scale of ripple
scale:2.5,
// Brush type can be fill or stroke
brushType:"fill"},
// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,
// Polar coordinate system
polarIndex:0,
// Geo coordinate system
geoIndex:0,
// symbol: null,        // 图形类型
symbolSize:10}})},/* 251 */
/***/
function(module,exports,__webpack_require__){var SymbolDraw=__webpack_require__(98),EffectSymbol=__webpack_require__(252);__webpack_require__(1).extendChartView({type:"effectScatter",init:function(){this._symbolDraw=new SymbolDraw(EffectSymbol)},render:function(seriesModel,ecModel,api){var data=seriesModel.getData(),effectSymbolDraw=this._symbolDraw;effectSymbolDraw.updateData(data),this.group.add(effectSymbolDraw.group)},updateLayout:function(){this._symbolDraw.updateLayout()},remove:function(ecModel,api){this._symbolDraw&&this._symbolDraw.remove(api)}})},/* 252 */
/***/
function(module,exports,__webpack_require__){function normalizeSymbolSize(symbolSize){return zrUtil.isArray(symbolSize)||(symbolSize=[+symbolSize,+symbolSize]),symbolSize}/**
	     * @constructor
	     * @param {module:echarts/data/List} data
	     * @param {number} idx
	     * @extends {module:zrender/graphic/Group}
	     */
function EffectSymbol(data,idx){Group.call(this);var symbol=new Symbol(data,idx),rippleGroup=new Group;this.add(symbol),this.add(rippleGroup),rippleGroup.beforeUpdate=function(){this.attr(symbol.getScale())},this.updateData(data,idx)}/**
	 * Symbol with ripple effect
	 * @module echarts/chart/helper/EffectSymbol
	 */
var zrUtil=__webpack_require__(3),symbolUtil=__webpack_require__(100),graphic=__webpack_require__(42),numberUtil=__webpack_require__(7),Symbol=__webpack_require__(99),Group=graphic.Group,EFFECT_RIPPLE_NUMBER=3,effectSymbolProto=EffectSymbol.prototype;effectSymbolProto.stopEffectAnimation=function(){this.childAt(1).removeAll()},effectSymbolProto.startEffectAnimation=function(period,brushType,rippleScale,effectOffset,z,zlevel){for(var symbolType=this._symbolType,color=this._color,rippleGroup=this.childAt(1),i=0;EFFECT_RIPPLE_NUMBER>i;i++){var ripplePath=symbolUtil.createSymbol(symbolType,-.5,-.5,1,1,color);ripplePath.attr({style:{stroke:"stroke"===brushType?color:null,fill:"fill"===brushType?color:null,strokeNoScale:!0},z2:99,silent:!0,scale:[1,1],z:z,zlevel:zlevel});var delay=-i/EFFECT_RIPPLE_NUMBER*period+effectOffset;
// TODO Configurable period
ripplePath.animate("",!0).when(period,{scale:[rippleScale,rippleScale]}).delay(delay).start(),ripplePath.animateStyle(!0).when(period,{opacity:0}).delay(delay).start(),rippleGroup.add(ripplePath)}},/**
	     * Highlight symbol
	     */
effectSymbolProto.highlight=function(){this.trigger("emphasis")},/**
	     * Downplay symbol
	     */
effectSymbolProto.downplay=function(){this.trigger("normal")},/**
	     * Update symbol properties
	     * @param  {module:echarts/data/List} data
	     * @param  {number} idx
	     */
effectSymbolProto.updateData=function(data,idx){function onEmphasis(){symbol.trigger("emphasis"),"render"!==showEffectOn&&this.startEffectAnimation(effectPeriod,brushType,rippleScale,effectOffset,z,zlevel)}function onNormal(){symbol.trigger("normal"),"render"!==showEffectOn&&this.stopEffectAnimation()}var seriesModel=data.hostModel;this.childAt(0).updateData(data,idx);var rippleGroup=this.childAt(1),itemModel=data.getItemModel(idx),symbolType=data.getItemVisual(idx,"symbol"),symbolSize=normalizeSymbolSize(data.getItemVisual(idx,"symbolSize")),color=data.getItemVisual(idx,"color");rippleGroup.attr("scale",symbolSize),rippleGroup.traverse(function(ripplePath){ripplePath.attr({fill:color})});var symbolOffset=itemModel.getShallow("symbolOffset");if(symbolOffset){var pos=rippleGroup.position;pos[0]=numberUtil.parsePercent(symbolOffset[0],symbolSize[0]),pos[1]=numberUtil.parsePercent(symbolOffset[1],symbolSize[1])}this._symbolType=symbolType,this._color=color;var showEffectOn=seriesModel.get("showEffectOn"),rippleScale=itemModel.get("rippleEffect.scale"),brushType=itemModel.get("rippleEffect.brushType"),effectPeriod=1e3*itemModel.get("rippleEffect.period"),effectOffset=idx/data.count(),z=itemModel.getShallow("z")||0,zlevel=itemModel.getShallow("zlevel")||0;this.stopEffectAnimation(),"render"===showEffectOn&&this.startEffectAnimation(effectPeriod,brushType,rippleScale,effectOffset,z,zlevel);var symbol=this.childAt(0);this.on("mouseover",onEmphasis,this).on("mouseout",onNormal,this).on("emphasis",onEmphasis,this).on("normal",onNormal,this)},effectSymbolProto.fadeOut=function(cb){cb&&cb()},zrUtil.inherits(EffectSymbol,Group),module.exports=EffectSymbol},/* 253 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(254),__webpack_require__(255);var zrUtil=__webpack_require__(3),echarts=__webpack_require__(1);echarts.registerLayout(__webpack_require__(257)),echarts.registerVisualCoding("chart",zrUtil.curry(__webpack_require__(88),"lines","lineStyle"))},/* 254 */
/***/
function(module,exports,__webpack_require__){"use strict";var SeriesModel=__webpack_require__(27),List=__webpack_require__(94),zrUtil=__webpack_require__(3),CoordinateSystem=__webpack_require__(25);module.exports=SeriesModel.extend({type:"series.lines",dependencies:["grid","polar"],getInitialData:function(option,ecModel){function geoCoordGetter(item,dim,dataIndex,dimIndex){return item.coord&&item.coord[dimIndex]}var fromDataArr=[],toDataArr=[],lineDataArr=[];zrUtil.each(option.data,function(opt){fromDataArr.push(opt[0]),toDataArr.push(opt[1]),lineDataArr.push(zrUtil.extend(zrUtil.extend({},zrUtil.isArray(opt[0])?null:opt[0]),zrUtil.isArray(opt[1])?null:opt[1]))});
// var coordSys = option.coordinateSystem;
// if (coordSys !== 'cartesian2d' && coordSys !== 'geo') {
//     throw new Error('Coordinate system can only be cartesian2d or geo in lines');
// }
// var dimensions = coordSys === 'geo' ? ['lng', 'lat'] : ['x', 'y'];
var coordSys=CoordinateSystem.get(option.coordinateSystem);if(!coordSys)throw new Error("Invalid coordinate system");var dimensions=coordSys.dimensions,fromData=new List(dimensions,this),toData=new List(dimensions,this),lineData=new List(["value"],this);return fromData.initData(fromDataArr,null,geoCoordGetter),toData.initData(toDataArr,null,geoCoordGetter),lineData.initData(lineDataArr),this.fromData=fromData,this.toData=toData,lineData},formatTooltip:function(dataIndex){var fromName=this.fromData.getName(dataIndex),toName=this.toData.getName(dataIndex);return fromName+" > "+toName},defaultOption:{coordinateSystem:"geo",zlevel:0,z:2,legendHoverLink:!0,hoverAnimation:!0,
// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,
// Geo coordinate system
geoIndex:0,
// symbol: null,
// symbolSize: 10,
// symbolRotate: null,
effect:{show:!1,period:4,symbol:"circle",symbolSize:3,
// Length of trail, 0 - 1
trailLength:.2},large:!1,
// Available when large is true
largeThreshold:2e3,label:{normal:{show:!1,position:"end"}},
// itemStyle: {
//     normal: {
//     }
// },
lineStyle:{normal:{opacity:.5}}}})},/* 255 */
/***/
function(module,exports,__webpack_require__){var LineDraw=__webpack_require__(194),EffectLine=__webpack_require__(256),Line=__webpack_require__(195);__webpack_require__(1).extendChartView({type:"lines",init:function(){},render:function(seriesModel,ecModel,api){var data=seriesModel.getData(),lineDraw=this._lineDraw,hasEffect=seriesModel.get("effect.show");hasEffect!==this._hasEffet&&(lineDraw&&lineDraw.remove(),lineDraw=this._lineDraw=new LineDraw(hasEffect?EffectLine:Line),this._hasEffet=hasEffect);var zlevel=seriesModel.get("zlevel"),trailLength=seriesModel.get("effect.trailLength"),zr=api.getZr();
// Avoid the drag cause ghost shadow
// FIXME Better way ?
zr.painter.getLayer(zlevel).clear(!0),
// Config layer with motion blur
null!=this._lastZlevel&&zr.configLayer(this._lastZlevel,{motionBlur:!1}),hasEffect&&trailLength&&zr.configLayer(zlevel,{motionBlur:!0,lastFrameAlpha:Math.max(Math.min(trailLength/10+.9,1),0)}),this.group.add(lineDraw.group),lineDraw.updateData(data),this._lastZlevel=zlevel},updateLayout:function(seriesModel,ecModel,api){this._lineDraw.updateLayout();
// Not use motion when dragging or zooming
var zr=api.getZr();zr.painter.getLayer(this._lastZlevel).clear(!0)},remove:function(ecModel,api){this._lineDraw&&this._lineDraw.remove(api,!0)}})},/* 256 */
/***/
function(module,exports,__webpack_require__){/**
	     * @constructor
	     * @extends {module:zrender/graphic/Group}
	     * @alias {module:echarts/chart/helper/Line}
	     */
function EffectLine(lineData,fromData,toData,idx){graphic.Group.call(this);var line=new Line(lineData,fromData,toData,idx);this.add(line),this._updateEffectSymbol(lineData,idx)}function setAnimationPoints(symbol,points){symbol.__p1=points[0],symbol.__p2=points[1],symbol.__cp1=points[2]||[(points[0][0]+points[1][0])/2,(points[0][1]+points[1][1])/2]}function updateSymbolPosition(){var p1=this.__p1,p2=this.__p2,cp1=this.__cp1,t=this.__t,pos=this.position,quadraticAt=curveUtil.quadraticAt,quadraticDerivativeAt=curveUtil.quadraticDerivativeAt;pos[0]=quadraticAt(p1[0],cp1[0],p2[0],t),pos[1]=quadraticAt(p1[1],cp1[1],p2[1],t);
// Tangent
var tx=quadraticDerivativeAt(p1[0],cp1[0],p2[0],t),ty=quadraticDerivativeAt(p1[1],cp1[1],p2[1],t);this.rotation=-Math.atan2(ty,tx)-Math.PI/2,this.ignore=!1}/**
	 * @module echarts/chart/helper/EffectLine
	 */
var graphic=__webpack_require__(42),Line=__webpack_require__(195),zrUtil=__webpack_require__(3),symbolUtil=__webpack_require__(100),curveUtil=__webpack_require__(49),effectLineProto=EffectLine.prototype;effectLineProto._updateEffectSymbol=function(lineData,idx){var itemModel=lineData.getItemModel(idx),effectModel=itemModel.getModel("effect"),size=effectModel.get("symbolSize"),symbolType=effectModel.get("symbol");zrUtil.isArray(size)||(size=[size,size]);var color=effectModel.get("color")||lineData.getItemVisual(idx,"color"),symbol=this.childAt(1),period=1e3*effectModel.get("period");this._symbolType===symbolType&&period===this._period||(symbol=symbolUtil.createSymbol(symbolType,-.5,-.5,1,1,color),symbol.ignore=!0,symbol.z2=100,this._symbolType=symbolType,this._period=period,this.add(symbol),symbol.__t=0,symbol.animate("",!0).when(period,{__t:1}).delay(idx/lineData.count()*period/2).during(zrUtil.bind(updateSymbolPosition,symbol)).start()),
// Shadow color is same with color in default
symbol.setStyle("shadowColor",color),symbol.setStyle(effectModel.getItemStyle(["color"])),symbol.attr("scale",size);var points=lineData.getItemLayout(idx);setAnimationPoints(symbol,points),symbol.setColor(color),symbol.attr("scale",size)},effectLineProto.updateData=function(lineData,fromData,toData,idx){this.childAt(0).updateData(lineData,fromData,toData,idx),this._updateEffectSymbol(lineData,idx)},effectLineProto.updateLayout=function(lineData,fromData,toData,idx){this.childAt(0).updateLayout(lineData,fromData,toData,idx);var symbol=this.childAt(1),points=lineData.getItemLayout(idx);setAnimationPoints(symbol,points)},zrUtil.inherits(EffectLine,graphic.Group),module.exports=EffectLine},/* 257 */
/***/
function(module,exports){module.exports=function(ecModel){ecModel.eachSeriesByType("lines",function(seriesModel){var coordSys=seriesModel.coordinateSystem,fromData=seriesModel.fromData,toData=seriesModel.toData,lineData=seriesModel.getData(),dims=coordSys.dimensions;fromData.each(dims,function(x,y,idx){fromData.setItemLayout(idx,coordSys.dataToPoint([x,y]))}),toData.each(dims,function(x,y,idx){toData.setItemLayout(idx,coordSys.dataToPoint([x,y]))}),lineData.each(function(idx){var cp1,p1=fromData.getItemLayout(idx),p2=toData.getItemLayout(idx),curveness=lineData.getItemModel(idx).get("lineStyle.normal.curveness");curveness>0&&(cp1=[(p1[0]+p2[0])/2-(p1[1]-p2[1])*curveness,(p1[1]+p2[1])/2-(p2[0]-p1[0])*curveness]),lineData.setItemLayout(idx,[p1,p2,cp1])})})}},/* 258 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(259),__webpack_require__(260)},/* 259 */
/***/
function(module,exports,__webpack_require__){var SeriesModel=__webpack_require__(27),createListFromArray=__webpack_require__(93);module.exports=SeriesModel.extend({type:"series.heatmap",getInitialData:function(option,ecModel){return createListFromArray(option.data,this,ecModel)},defaultOption:{
// Cartesian2D or geo
coordinateSystem:"cartesian2d",zlevel:0,z:2,
// Cartesian coordinate system
xAxisIndex:0,yAxisIndex:0,
// Geo coordinate system
geoIndex:0,blurSize:30,pointSize:20,maxOpacity:1,minOpacity:0}})},/* 260 */
/***/
function(module,exports,__webpack_require__){function getIsInPiecewiseRange(dataExtent,pieceList,selected){var dataSpan=dataExtent[1]-dataExtent[0];pieceList=zrUtil.map(pieceList,function(piece){return{interval:[(piece.interval[0]-dataExtent[0])/dataSpan,(piece.interval[1]-dataExtent[0])/dataSpan]}});var len=pieceList.length,lastIndex=0;return function(val){
// Try to find in the location of the last found
for(var i=lastIndex;len>i;i++){var interval=pieceList[i].interval;if(interval[0]<=val&&val<=interval[1]){lastIndex=i;break}}if(i===len)// Not found, back interation
for(var i=lastIndex-1;i>=0;i--){var interval=pieceList[i].interval;if(interval[0]<=val&&val<=interval[1]){lastIndex=i;break}}return i>=0&&len>i&&selected[i]}}function getIsInContinuousRange(dataExtent,range){var dataSpan=dataExtent[1]-dataExtent[0];return range=[(range[0]-dataExtent[0])/dataSpan,(range[1]-dataExtent[0])/dataSpan],function(val){return val>=range[0]&&val<=range[1]}}function isGeoCoordSys(coordSys){var dimensions=coordSys.dimensions;
// Not use coorSys.type === 'geo' because coordSys maybe extended
return"lng"===dimensions[0]&&"lat"===dimensions[1]}var graphic=__webpack_require__(42),HeatmapLayer=__webpack_require__(261),zrUtil=__webpack_require__(3);module.exports=__webpack_require__(1).extendChartView({type:"heatmap",render:function(seriesModel,ecModel,api){var visualMapOfThisSeries;if(ecModel.eachComponent("visualMap",function(visualMap){visualMap.eachTargetSeries(function(targetSeries){targetSeries===seriesModel&&(visualMapOfThisSeries=visualMap)})}),!visualMapOfThisSeries)throw new Error("Heatmap must use with visualMap");this.group.removeAll();var coordSys=seriesModel.coordinateSystem;"cartesian2d"===coordSys.type?this._renderOnCartesian(coordSys,seriesModel,api):isGeoCoordSys(coordSys)&&this._renderOnGeo(coordSys,seriesModel,visualMapOfThisSeries,api)},_renderOnCartesian:function(cartesian,seriesModel,api){var xAxis=cartesian.getAxis("x"),yAxis=cartesian.getAxis("y"),group=this.group;if("category"!==xAxis.type||"category"!==yAxis.type)throw new Error("Heatmap on cartesian must have two category axes");if(!xAxis.onBand||!yAxis.onBand)throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");var width=xAxis.getBandWidth(),height=yAxis.getBandWidth(),data=seriesModel.getData();data.each(["x","y","z"],function(x,y,z,idx){var itemModel=data.getItemModel(idx),point=cartesian.dataToPoint([x,y]);
// Ignore empty data
if(!isNaN(z)){var rect=new graphic.Rect({shape:{x:point[0]-width/2,y:point[1]-height/2,width:width,height:height},style:{fill:data.getItemVisual(idx,"color")}}),style=itemModel.getModel("itemStyle.normal").getItemStyle(["color"]),hoverStl=itemModel.getModel("itemStyle.emphasis").getItemStyle(),labelModel=itemModel.getModel("label.normal"),hoverLabelModel=itemModel.getModel("label.emphasis"),rawValue=seriesModel.getRawValue(idx),defaultText="-";rawValue&&null!=rawValue[2]&&(defaultText=rawValue[2]),labelModel.get("show")&&(graphic.setText(style,labelModel),style.text=seriesModel.getFormattedLabel(idx,"normal")||defaultText),hoverLabelModel.get("show")&&(graphic.setText(hoverStl,hoverLabelModel),hoverStl.text=seriesModel.getFormattedLabel(idx,"emphasis")||defaultText),rect.setStyle(style),graphic.setHoverStyle(rect,hoverStl),group.add(rect),data.setItemGraphicEl(idx,rect)}})},_renderOnGeo:function(geo,seriesModel,visualMapModel,api){var inRangeVisuals=visualMapModel.targetVisuals.inRange,outOfRangeVisuals=visualMapModel.targetVisuals.outOfRange,data=seriesModel.getData(),hmLayer=this._hmLayer||this._hmLayer||new HeatmapLayer;hmLayer.blurSize=seriesModel.get("blurSize"),hmLayer.pointSize=seriesModel.get("pointSize"),hmLayer.minOpacity=seriesModel.get("minOpacity"),hmLayer.maxOpacity=seriesModel.get("maxOpacity");var rect=geo.getViewRect().clone(),roamTransform=geo.getRoamTransform();rect.applyTransform(roamTransform);
// Clamp on viewport
var x=Math.max(rect.x,0),y=Math.max(rect.y,0),x2=Math.min(rect.width+rect.x,api.getWidth()),y2=Math.min(rect.height+rect.y,api.getHeight()),width=x2-x,height=y2-y,points=data.mapArray(["lng","lat","value"],function(lng,lat,value){var pt=geo.dataToPoint([lng,lat]);return pt[0]-=x,pt[1]-=y,pt.push(value),pt}),dataExtent=visualMapModel.getExtent(),isInRange="visualMap.continuous"===visualMapModel.type?getIsInContinuousRange(dataExtent,visualMapModel.option.range):getIsInPiecewiseRange(dataExtent,visualMapModel.getPieceList(),visualMapModel.option.selected);hmLayer.update(points,width,height,inRangeVisuals.color.getNormalizer(),{inRange:inRangeVisuals.color.getColorMapper(),outOfRange:outOfRangeVisuals.color.getColorMapper()},isInRange);var img=new graphic.Image({style:{width:width,height:height,x:x,y:y,image:hmLayer.canvas},silent:!0});this.group.add(img)}})},/* 261 */
/***/
function(module,exports,__webpack_require__){/**
	     * Heatmap Chart
	     *
	     * @class
	     */
function Heatmap(){var canvas=zrUtil.createCanvas();this.canvas=canvas,this.blurSize=30,this.pointSize=20,this.maxOpacity=1,this.minOpacity=0,this._gradientPixels={}}/**
	 * @file defines echarts Heatmap Chart
	 * @author Ovilia (me@zhangwenli.com)
	 * Inspired by https://github.com/mourner/simpleheat
	 *
	 * @module
	 */
var GRADIENT_LEVELS=256,zrUtil=__webpack_require__(3);Heatmap.prototype={/**
	         * Renders Heatmap and returns the rendered canvas
	         * @param {Array} data array of data, each has x, y, value
	         * @param {number} width canvas width
	         * @param {number} height canvas height
	         */
update:function(data,width,height,normalize,colorFunc,isInRange){var brush=this._getBrush(),gradientInRange=this._getGradient(data,colorFunc,"inRange"),gradientOutOfRange=this._getGradient(data,colorFunc,"outOfRange"),r=this.pointSize+this.blurSize,canvas=this.canvas,ctx=canvas.getContext("2d"),len=data.length;canvas.width=width,canvas.height=height;for(var i=0;len>i;++i){var p=data[i],x=p[0],y=p[1],value=p[2],alpha=normalize(value);
// draw with the circle brush with alpha
ctx.globalAlpha=alpha,ctx.drawImage(brush,x-r,y-r)}for(
// colorize the canvas using alpha value and set with gradient
var imageData=ctx.getImageData(0,0,canvas.width,canvas.height),pixels=imageData.data,offset=0,pixelLen=pixels.length,minOpacity=this.minOpacity,maxOpacity=this.maxOpacity,diffOpacity=maxOpacity-minOpacity;pixelLen>offset;){var alpha=pixels[offset+3]/256,gradientOffset=4*Math.floor(alpha*(GRADIENT_LEVELS-1));
// Simple optimize to ignore the empty data
if(alpha>0){var gradient=isInRange(alpha)?gradientInRange:gradientOutOfRange;
// Any alpha > 0 will be mapped to [minOpacity, maxOpacity]
alpha>0&&(alpha=alpha*diffOpacity+minOpacity),pixels[offset++]=gradient[gradientOffset],pixels[offset++]=gradient[gradientOffset+1],pixels[offset++]=gradient[gradientOffset+2],pixels[offset++]=gradient[gradientOffset+3]*alpha*256}else offset+=4}return ctx.putImageData(imageData,0,0),canvas},/**
	         * get canvas of a black circle brush used for canvas to draw later
	         * @private
	         * @returns {Object} circle brush canvas
	         */
_getBrush:function(){var brushCanvas=this._brushCanvas||(this._brushCanvas=zrUtil.createCanvas()),r=this.pointSize+this.blurSize,d=2*r;brushCanvas.width=d,brushCanvas.height=d;var ctx=brushCanvas.getContext("2d");
// in order to render shadow without the distinct circle,
// draw the distinct circle in an invisible place,
// and use shadowOffset to draw shadow in the center of the canvas
// draw the shadow in black, and use alpha and shadow blur to generate
// color in color map
// draw circle in the left to the canvas
return ctx.clearRect(0,0,d,d),ctx.shadowOffsetX=d,ctx.shadowBlur=this.blurSize,ctx.shadowColor="#000",ctx.beginPath(),ctx.arc(-r,r,this.pointSize,0,2*Math.PI,!0),ctx.closePath(),ctx.fill(),brushCanvas},/**
	         * get gradient color map
	         * @private
	         */
_getGradient:function(data,colorFunc,state){for(var gradientPixels=this._gradientPixels,pixelsSingleState=gradientPixels[state]||(gradientPixels[state]=new Uint8ClampedArray(1024)),color=[],off=0,i=0;256>i;i++)colorFunc[state](i/255,!0,color),pixelsSingleState[off++]=color[0],pixelsSingleState[off++]=color[1],pixelsSingleState[off++]=color[2],pixelsSingleState[off++]=color[3];return pixelsSingleState}},module.exports=Heatmap},/* 262 */
/***/
function(module,exports,__webpack_require__){/**
	 * Legend component entry file8
	 */
__webpack_require__(263),__webpack_require__(264),__webpack_require__(265);var echarts=__webpack_require__(1);
// Series Filter
echarts.registerProcessor("filter",__webpack_require__(267))},/* 263 */
/***/
function(module,exports,__webpack_require__){"use strict";var zrUtil=__webpack_require__(3),Model=__webpack_require__(8),LegendModel=__webpack_require__(1).extendComponentModel({type:"legend",dependencies:["series"],layoutMode:{type:"box",ignoreSize:!0},init:function(option,parentModel,ecModel){this.mergeDefaultAndTheme(option,ecModel),option.selected=option.selected||{},this._updateData(ecModel);var legendData=this._data,selectedMap=this.option.selected;
// If selectedMode is single, try to select one
if(legendData[0]&&"single"===this.get("selectedMode")){var hasSelected=!1;for(var name in selectedMap)selectedMap[name]&&(this.select(name),hasSelected=!0);
// Try select the first if selectedMode is single
!hasSelected&&this.select(legendData[0].get("name"))}},mergeOption:function(option){LegendModel.superCall(this,"mergeOption",option),this._updateData(this.ecModel)},_updateData:function(ecModel){var legendData=zrUtil.map(this.get("data")||[],function(dataItem){return"string"==typeof dataItem&&(dataItem={name:dataItem}),new Model(dataItem,this,this.ecModel)},this);this._data=legendData;var availableNames=zrUtil.map(ecModel.getSeries(),function(series){return series.name});ecModel.eachSeries(function(seriesModel){if(seriesModel.legendDataProvider){var data=seriesModel.legendDataProvider();availableNames=availableNames.concat(data.mapArray(data.getName))}}),/**
	             * @type {Array.<string>}
	             * @private
	             */
this._availableNames=availableNames},/**
	         * @return {Array.<module:echarts/model/Model>}
	         */
getData:function(){return this._data},/**
	         * @param {string} name
	         */
select:function(name){var selected=this.option.selected,selectedMode=this.get("selectedMode");if("single"===selectedMode){var data=this._data;zrUtil.each(data,function(dataItem){selected[dataItem.get("name")]=!1})}selected[name]=!0},/**
	         * @param {string} name
	         */
unSelect:function(name){"single"!==this.get("selectedMode")&&(this.option.selected[name]=!1)},/**
	         * @param {string} name
	         */
toggleSelected:function(name){var selected=this.option.selected;name in selected||(selected[name]=!0),this[selected[name]?"unSelect":"select"](name)},/**
	         * @param {string} name
	         */
isSelected:function(name){var selected=this.option.selected;return!(name in selected&&!selected[name])&&zrUtil.indexOf(this._availableNames,name)>=0},defaultOption:{
// 一级层叠
zlevel:0,
// 二级层叠
z:4,show:!0,
// 布局方式，默认为水平布局，可选为：
// 'horizontal' | 'vertical'
orient:"horizontal",left:"center",
// right: 'center',
top:"top",
// bottom: 'top',
// 水平对齐
// 'auto' | 'left' | 'right'
// 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
align:"auto",backgroundColor:"rgba(0,0,0,0)",
// 图例边框颜色
borderColor:"#ccc",
// 图例边框线宽，单位px，默认为0（无边框）
borderWidth:0,
// 图例内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,
// 各个item之间的间隔，单位px，默认为10，
// 横向布局时为水平间隔，纵向布局时为纵向间隔
itemGap:10,
// 图例图形宽度
itemWidth:25,
// 图例图形高度
itemHeight:14,textStyle:{
// 图例文字颜色
color:"#333"},
// formatter: '',
// 选择模式，默认开启图例开关
selectedMode:!0}});module.exports=LegendModel},/* 264 */
/***/
function(module,exports,__webpack_require__){function legendSelectActionHandler(methodName,payload,ecModel){var isSelected,selectedMap={},isToggleSelect="toggleSelected"===methodName;
// Return the event explicitly
// Update all legend components
return ecModel.eachComponent("legend",function(legendModel){isToggleSelect&&null!=isSelected?
// Force other legend has same selected status
// Or the first is toggled to true and other are toggled to false
// In the case one legend has some item unSelected in option. And if other legend
// doesn't has the item, they will assume it is selected.
legendModel[isSelected?"select":"unSelect"](payload.name):(legendModel[methodName](payload.name),isSelected=legendModel.isSelected(payload.name));var legendData=legendModel.getData();zrUtil.each(legendData,function(model){var name=model.get("name");
// Wrap element
if("\n"!==name&&""!==name){var isItemSelected=legendModel.isSelected(name);name in selectedMap?selectedMap[name]=selectedMap[name]&&isItemSelected:selectedMap[name]=isItemSelected}})}),{name:payload.name,selected:selectedMap}}/**
	 * @file Legend action
	 */
var echarts=__webpack_require__(1),zrUtil=__webpack_require__(3);/**
	     * @event legendToggleSelect
	     * @type {Object}
	     * @property {string} type 'legendToggleSelect'
	     * @property {string} [from]
	     * @property {string} name Series name or data item name
	     */
echarts.registerAction("legendToggleSelect","legendselectchanged",zrUtil.curry(legendSelectActionHandler,"toggleSelected")),/**
	     * @event legendSelect
	     * @type {Object}
	     * @property {string} type 'legendSelect'
	     * @property {string} name Series name or data item name
	     */
echarts.registerAction("legendSelect","legendselected",zrUtil.curry(legendSelectActionHandler,"select")),/**
	     * @event legendUnSelect
	     * @type {Object}
	     * @property {string} type 'legendUnSelect'
	     * @property {string} name Series name or data item name
	     */
echarts.registerAction("legendUnSelect","legendunselected",zrUtil.curry(legendSelectActionHandler,"unSelect"))},/* 265 */
/***/
function(module,exports,__webpack_require__){function dispatchSelectAction(name,api){api.dispatchAction({type:"legendToggleSelect",name:name})}function dispatchHighlightAction(seriesModel,dataName,api){seriesModel.get("legendHoverLink")&&api.dispatchAction({type:"highlight",seriesName:seriesModel.name,name:dataName})}function dispatchDownplayAction(seriesModel,dataName,api){seriesModel.get("legendHoverLink")&&api.dispatchAction({type:"downplay",seriesName:seriesModel.name,name:dataName})}var zrUtil=__webpack_require__(3),symbolCreator=__webpack_require__(100),graphic=__webpack_require__(42),listComponentHelper=__webpack_require__(266),curry=zrUtil.curry,LEGEND_DISABLE_COLOR="#ccc";module.exports=__webpack_require__(1).extendComponentView({type:"legend",init:function(){this._symbolTypeStore={}},render:function(legendModel,ecModel,api){var group=this.group;if(group.removeAll(),legendModel.get("show")){var selectMode=legendModel.get("selectedMode"),itemAlign=legendModel.get("align");"auto"===itemAlign&&(itemAlign="right"===legendModel.get("left")&&"vertical"===legendModel.get("orient")?"right":"left");var legendDrawedMap={};zrUtil.each(legendModel.getData(),function(itemModel){var name=itemModel.get("name");
// Use empty string or \n as a newline string
if(""===name||"\n"===name)return void group.add(new graphic.Group({newline:!0}));var seriesModel=ecModel.getSeriesByName(name)[0];if(!legendDrawedMap[name])
// Series legend
if(seriesModel){var data=seriesModel.getData(),color=data.getVisual("color");
// If color is a callback function
"function"==typeof color&&(
// Use the first data
color=color(seriesModel.getDataParams(0)));
// Using rect symbol defaultly
var legendSymbolType=data.getVisual("legendSymbol")||"roundRect",symbolType=data.getVisual("symbol"),itemGroup=this._createItem(name,itemModel,legendModel,legendSymbolType,symbolType,itemAlign,color,selectMode);itemGroup.on("click",curry(dispatchSelectAction,name,api)).on("mouseover",curry(dispatchHighlightAction,seriesModel,"",api)).on("mouseout",curry(dispatchDownplayAction,seriesModel,"",api)),legendDrawedMap[name]=!0}else
// Data legend of pie, funnel
ecModel.eachRawSeries(function(seriesModel){
// In case multiple series has same data name
if(!legendDrawedMap[name]&&seriesModel.legendDataProvider){var data=seriesModel.legendDataProvider(),idx=data.indexOfName(name),color=data.getItemVisual(idx,"color"),legendSymbolType="roundRect",itemGroup=this._createItem(name,itemModel,legendModel,legendSymbolType,null,itemAlign,color,selectMode);itemGroup.on("click",curry(dispatchSelectAction,name,api)).on("mouseover",curry(dispatchHighlightAction,seriesModel,name,api)).on("mouseout",curry(dispatchDownplayAction,seriesModel,name,api)),legendDrawedMap[name]=!0}},this)},this),listComponentHelper.layout(group,legendModel,api),
// Render background after group is layout
// FIXME
listComponentHelper.addBackground(group,legendModel)}},_createItem:function(name,itemModel,legendModel,legendSymbolType,symbolType,itemAlign,color,selectMode){var itemWidth=legendModel.get("itemWidth"),itemHeight=legendModel.get("itemHeight"),isSelected=legendModel.isSelected(name),itemGroup=new graphic.Group,textStyleModel=itemModel.getModel("textStyle"),itemIcon=itemModel.get("icon");
// Compose symbols
// PENDING
if(legendSymbolType=itemIcon||legendSymbolType,itemGroup.add(symbolCreator.createSymbol(legendSymbolType,0,0,itemWidth,itemHeight,isSelected?color:LEGEND_DISABLE_COLOR)),!itemIcon&&symbolType&&(symbolType!==legendSymbolType||"none"==symbolType)){var size=.8*itemHeight;"none"===symbolType&&(symbolType="circle"),
// Put symbol in the center
itemGroup.add(symbolCreator.createSymbol(symbolType,(itemWidth-size)/2,(itemHeight-size)/2,size,size,isSelected?color:LEGEND_DISABLE_COLOR))}
// Text
var textX="left"===itemAlign?itemWidth+5:-5,textAlign=itemAlign,formatter=legendModel.get("formatter");"string"==typeof formatter&&formatter?name=formatter.replace("{name}",name):"function"==typeof formatter&&(name=formatter(name));var text=new graphic.Text({style:{text:name,x:textX,y:itemHeight/2,fill:isSelected?textStyleModel.getTextColor():LEGEND_DISABLE_COLOR,textFont:textStyleModel.getFont(),textAlign:textAlign,textVerticalAlign:"middle"}});
// Add a invisible rect to increase the area of mouse hover
return itemGroup.add(text),itemGroup.add(new graphic.Rect({shape:itemGroup.getBoundingRect(),invisible:!0})),itemGroup.eachChild(function(child){child.silent=!selectMode}),this.group.add(itemGroup),graphic.setHoverStyle(itemGroup),itemGroup}})},/* 266 */
/***/
function(module,exports,__webpack_require__){function positionGroup(group,model,api){layout.positionGroup(group,model.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()},model.get("padding"))}
// List layout
var layout=__webpack_require__(21),formatUtil=__webpack_require__(6),graphic=__webpack_require__(42);module.exports={/**
	         * Layout list like component.
	         * It will box layout each items in group of component and then position the whole group in the viewport
	         * @param {module:zrender/group/Group} group
	         * @param {module:echarts/model/Component} componentModel
	         * @param {module:echarts/ExtensionAPI}
	         */
layout:function(group,componentModel,api){var rect=layout.getLayoutRect(componentModel.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()},componentModel.get("padding"));layout.box(componentModel.get("orient"),group,componentModel.get("itemGap"),rect.width,rect.height),positionGroup(group,componentModel,api)},addBackground:function(group,componentModel){var padding=formatUtil.normalizeCssArray(componentModel.get("padding")),boundingRect=group.getBoundingRect(),style=componentModel.getItemStyle(["color","opacity"]);style.fill=componentModel.get("backgroundColor");var rect=new graphic.Rect({shape:{x:boundingRect.x-padding[3],y:boundingRect.y-padding[0],width:boundingRect.width+padding[1]+padding[3],height:boundingRect.height+padding[0]+padding[2]},style:style,silent:!0,z2:-1});graphic.subPixelOptimizeRect(rect),group.add(rect)}}},/* 267 */
/***/
function(module,exports){module.exports=function(ecModel){var legendModels=ecModel.findComponents({mainType:"legend"});legendModels&&legendModels.length&&ecModel.filterSeries(function(series){
// If in any legend component the status is not selected.
// Because in legend series is assumed selected when it is not in the legend data.
for(var i=0;i<legendModels.length;i++)if(!legendModels[i].isSelected(series.name))return!1;return!0})}},/* 268 */
/***/
function(module,exports,__webpack_require__){
// FIXME Better way to pack data in graphic element
__webpack_require__(269),__webpack_require__(270),
// Show tip action
/**
	     * @action
	     * @property {string} type
	     * @property {number} seriesIndex
	     * @property {number} dataIndex
	     * @property {number} [x]
	     * @property {number} [y]
	     */
__webpack_require__(1).registerAction({type:"showTip",event:"showTip",update:"none"},
// noop
function(){}),
// Hide tip action
__webpack_require__(1).registerAction({type:"hideTip",event:"hideTip",update:"none"},
// noop
function(){})},/* 269 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(1).extendComponentModel({type:"tooltip",defaultOption:{zlevel:0,z:8,show:!0,
// tooltip主体内容
showContent:!0,
// 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'
trigger:"item",
// 触发条件，支持 'click' | 'mousemove'
triggerOn:"mousemove",
// 是否永远显示 content
alwaysShowContent:!1,
// 位置 {Array} | {Function}
// position: null
// 内容格式器：{string}（Template） ¦ {Function}
// formatter: null
showDelay:0,
// 隐藏延迟，单位ms
hideDelay:100,
// 动画变换时间，单位s
transitionDuration:.4,enterable:!1,
// 提示背景颜色，默认为透明度为0.7的黑色
backgroundColor:"rgba(50,50,50,0.7)",
// 提示边框颜色
borderColor:"#333",
// 提示边框圆角，单位px，默认为4
borderRadius:4,
// 提示边框线宽，单位px，默认为0（无边框）
borderWidth:0,
// 提示内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,
// Extra css text
extraCssText:"",
// 坐标轴指示器，坐标轴触发有效
axisPointer:{
// 默认为直线
// 可选为：'line' | 'shadow' | 'cross'
type:"line",
// type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
// 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
// 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
// 极坐标系会默认选择 angle 轴
axis:"auto",animation:!0,animationDurationUpdate:200,animationEasingUpdate:"exponentialOut",
// 直线指示器样式设置
lineStyle:{color:"#555",width:1,type:"solid"},crossStyle:{color:"#555",width:1,type:"dashed",
// TODO formatter
textStyle:{}},
// 阴影指示器样式设置
shadowStyle:{color:"rgba(150,150,150,0.3)"}},textStyle:{color:"#fff",fontSize:14}}})},/* 270 */
/***/
function(module,exports,__webpack_require__){function dataEqual(a,b){if(!a||!b)return!1;var round=numberUtil.round;return round(a[0])===round(b[0])&&round(a[1])===round(b[1])}/**
	     * @inner
	     */
function makeLineShape(x1,y1,x2,y2){return{x1:x1,y1:y1,x2:x2,y2:y2}}/**
	     * @inner
	     */
function makeRectShape(x,y,width,height){return{x:x,y:y,width:width,height:height}}/**
	     * @inner
	     */
function makeSectorShape(cx,cy,r0,r,startAngle,endAngle){return{cx:cx,cy:cy,r0:r0,r:r,startAngle:startAngle,endAngle:endAngle,clockwise:!0}}function refixTooltipPosition(x,y,el,viewWidth,viewHeight){var width=el.clientWidth,height=el.clientHeight,gap=20;return x+width+gap>viewWidth?x-=width+gap:x+=gap,y+height+gap>viewHeight?y-=height+gap:y+=gap,[x,y]}function calcTooltipPosition(position,rect,dom){var domWidth=dom.clientWidth,domHeight=dom.clientHeight,gap=5,x=0,y=0,rectWidth=rect.width,rectHeight=rect.height;switch(position){case"inside":x=rect.x+rectWidth/2-domWidth/2,y=rect.y+rectHeight/2-domHeight/2;break;case"top":x=rect.x+rectWidth/2-domWidth/2,y=rect.y-domHeight-gap;break;case"bottom":x=rect.x+rectWidth/2-domWidth/2,y=rect.y+rectHeight+gap;break;case"left":x=rect.x-domWidth-gap,y=rect.y+rectHeight/2-domHeight/2;break;case"right":x=rect.x+rectWidth+gap,y=rect.y+rectHeight/2-domHeight/2}return[x,y]}/**
	     * @param  {string|Function|Array.<number>} positionExpr
	     * @param  {number} x Mouse x
	     * @param  {number} y Mouse y
	     * @param  {module:echarts/component/tooltip/TooltipContent} content
	     * @param  {Object|<Array.<Object>} params
	     * @param  {module:zrender/Element} el target element
	     * @param  {module:echarts/ExtensionAPI} api
	     * @return {Array.<number>}
	     */
function updatePosition(positionExpr,x,y,content,params,el,api){var viewWidth=api.getWidth(),viewHeight=api.getHeight(),rect=el&&el.getBoundingRect().clone();if(el&&rect.applyTransform(el.transform),"function"==typeof positionExpr&&(
// Callback of position can be an array or a string specify the positiont
positionExpr=positionExpr([x,y],params,rect)),zrUtil.isArray(positionExpr))x=parsePercent(positionExpr[0],viewWidth),y=parsePercent(positionExpr[1],viewHeight);else if("string"==typeof positionExpr&&el){var pos=calcTooltipPosition(positionExpr,rect,content.el);x=pos[0],y=pos[1]}else{var pos=refixTooltipPosition(x,y,content.el,viewWidth,viewHeight);x=pos[0],y=pos[1]}content.moveTo(x,y)}function ifSeriesSupportAxisTrigger(seriesModel){var coordSys=seriesModel.coordinateSystem,trigger=seriesModel.get("tooltip.trigger",!0);
// Ignore series use item tooltip trigger and series coordinate system is not cartesian or
return!(!coordSys||"cartesian2d"!==coordSys.type&&"polar"!==coordSys.type&&"single"!==coordSys.type||"item"===trigger)}var TooltipContent=__webpack_require__(271),graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),formatUtil=__webpack_require__(6),numberUtil=__webpack_require__(7),parsePercent=numberUtil.parsePercent,env=__webpack_require__(78);__webpack_require__(1).extendComponentView({type:"tooltip",_axisPointers:{},init:function(ecModel,api){if(!env.node){var tooltipContent=new TooltipContent(api.getDom(),api);this._tooltipContent=tooltipContent,api.on("showTip",this._manuallyShowTip,this),api.on("hideTip",this._manuallyHideTip,this)}},render:function(tooltipModel,ecModel,api){if(!env.node){
// Reset
this.group.removeAll(),/**
	             * @type {Object}
	             * @private
	             */
this._axisPointers={},/**
	             * @private
	             * @type {module:echarts/component/tooltip/TooltipModel}
	             */
this._tooltipModel=tooltipModel,/**
	             * @private
	             * @type {module:echarts/model/Global}
	             */
this._ecModel=ecModel,/**
	             * @private
	             * @type {module:echarts/ExtensionAPI}
	             */
this._api=api,/**
	             * @type {Object}
	             * @private
	             */
this._lastHover={};var tooltipContent=this._tooltipContent;tooltipContent.update(),tooltipContent.enterable=tooltipModel.get("enterable"),this._alwaysShowContent=tooltipModel.get("alwaysShowContent"),/**
	             * @type {Object.<string, Array>}
	             */
this._seriesGroupByAxis=this._prepareAxisTriggerData(tooltipModel,ecModel);var crossText=this._crossText;
// Try to keep the tooltip show when refreshing
if(crossText&&this.group.add(crossText),null!=this._lastX&&null!=this._lastY){var self=this;clearTimeout(this._refreshUpdateTimeout),this._refreshUpdateTimeout=setTimeout(function(){
// Show tip next tick after other charts are rendered
// In case highlight action has wrong result
// FIXME
self._manuallyShowTip({x:self._lastX,y:self._lastY})})}var zr=this._api.getZr();zr.off("click",this._tryShow),zr.off("mousemove",this._mousemove),zr.off("mouseout",this._hide),zr.off("globalout",this._hide),"click"===tooltipModel.get("triggerOn")?zr.on("click",this._tryShow,this):(zr.on("mousemove",this._mousemove,this),zr.on("mouseout",this._hide,this),zr.on("globalout",this._hide,this))}},_mousemove:function(e){var showDelay=this._tooltipModel.get("showDelay"),self=this;clearTimeout(this._showTimeout),showDelay>0?this._showTimeout=setTimeout(function(){self._tryShow(e)},showDelay):this._tryShow(e)},/**
	         * Show tip manually by
	         *  dispatchAction({
	         *      type: 'showTip',
	         *      x: 10,
	         *      y: 10
	         *  });
	         * Or
	         *  dispatchAction({
	         *      type: 'showTip',
	         *      seriesIndex: 0,
	         *      dataIndex: 1
	         *  });
	         *
	         *  TODO Batch
	         */
_manuallyShowTip:function(event){
// From self
if(event.from!==this.uid){var ecModel=this._ecModel,seriesIndex=event.seriesIndex,dataIndex=event.dataIndex,seriesModel=ecModel.getSeriesByIndex(seriesIndex),api=this._api;if(null==event.x||null==event.y){if(seriesModel||
// Find the first series can use axis trigger
ecModel.eachSeries(function(_series){ifSeriesSupportAxisTrigger(_series)&&!seriesModel&&(seriesModel=_series)}),seriesModel){var data=seriesModel.getData();null==dataIndex&&(dataIndex=data.indexOfName(event.name));var cx,cy,el=data.getItemGraphicEl(dataIndex),coordSys=seriesModel.coordinateSystem;if(coordSys&&coordSys.dataToPoint){var point=coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions,function(dim){return seriesModel.coordDimToDataDim(dim)[0]}),dataIndex,!0));cx=point&&point[0],cy=point&&point[1]}else if(el){
// Use graphic bounding rect
var rect=el.getBoundingRect().clone();rect.applyTransform(el.transform),cx=rect.x+rect.width/2,cy=rect.y+rect.height/2}null!=cx&&null!=cy&&this._tryShow({offsetX:cx,offsetY:cy,target:el,event:{}})}}else{var el=api.getZr().handler.findHover(event.x,event.y);this._tryShow({offsetX:event.x,offsetY:event.y,target:el,event:{}})}}},_manuallyHideTip:function(e){e.from!==this.uid&&this._hide()},_prepareAxisTriggerData:function(tooltipModel,ecModel){
// Prepare data for axis trigger
var seriesGroupByAxis={};return ecModel.eachSeries(function(seriesModel){if(ifSeriesSupportAxisTrigger(seriesModel)){var baseAxis,key,coordSys=seriesModel.coordinateSystem;
// Only cartesian2d, polar and single support axis trigger
"cartesian2d"===coordSys.type?(baseAxis=coordSys.getBaseAxis(),key=baseAxis.dim+baseAxis.index):"single"===coordSys.type?(baseAxis=coordSys.getAxis(),key=baseAxis.dim+baseAxis.type):(baseAxis=coordSys.getBaseAxis(),key=baseAxis.dim+coordSys.name),seriesGroupByAxis[key]=seriesGroupByAxis[key]||{coordSys:[],series:[]},seriesGroupByAxis[key].coordSys.push(coordSys),seriesGroupByAxis[key].series.push(seriesModel)}},this),seriesGroupByAxis},/**
	         * mousemove handler
	         * @param {Object} e
	         * @private
	         */
_tryShow:function(e){var el=e.target,tooltipModel=this._tooltipModel,globalTrigger=tooltipModel.get("trigger"),ecModel=this._ecModel,api=this._api;if(tooltipModel)
// Always show item tooltip if mouse is on the element with dataIndex
if(
// Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
this._lastX=e.offsetX,this._lastY=e.offsetY,el&&null!=el.dataIndex){
// Use dataModel in element if possible
// Used when mouseover on a element like markPoint or edge
// In which case, the data is not main data in series.
var dataModel=el.dataModel||ecModel.getSeriesByIndex(el.seriesIndex),dataIndex=el.dataIndex,itemModel=dataModel.getData().getItemModel(dataIndex);
// Series or single data may use item trigger when global is axis trigger
"axis"===(itemModel.get("tooltip.trigger")||globalTrigger)?this._showAxisTooltip(tooltipModel,ecModel,e):(
// Reset ticket
this._ticket="",
// If either single data or series use item trigger
this._hideAxisPointer(),
// Reset last hover and dispatch downplay action
this._resetLastHover(),this._showItemTooltipContent(dataModel,dataIndex,e)),api.dispatchAction({type:"showTip",from:this.uid,dataIndex:el.dataIndex,seriesIndex:el.seriesIndex})}else"item"===globalTrigger?this._hide():
// Try show axis tooltip
this._showAxisTooltip(tooltipModel,ecModel,e),
// Action of cross pointer
// other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method
"cross"===tooltipModel.get("axisPointer.type")&&api.dispatchAction({type:"showTip",from:this.uid,x:e.offsetX,y:e.offsetY})},/**
	         * Show tooltip on axis
	         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel
	         * @param {module:echarts/model/Global} ecModel
	         * @param {Object} e
	         * @private
	         */
_showAxisTooltip:function(tooltipModel,ecModel,e){var axisPointerModel=tooltipModel.getModel("axisPointer"),axisPointerType=axisPointerModel.get("type");if("cross"===axisPointerType){var el=e.target;if(el&&null!=el.dataIndex){var seriesModel=ecModel.getSeriesByIndex(el.seriesIndex),dataIndex=el.dataIndex;this._showItemTooltipContent(seriesModel,dataIndex,e)}}this._showAxisPointer();var allNotShow=!0;zrUtil.each(this._seriesGroupByAxis,function(seriesCoordSysSameAxis){
// Try show the axis pointer
var allCoordSys=seriesCoordSysSameAxis.coordSys,coordSys=allCoordSys[0],point=[e.offsetX,e.offsetY];if(!coordSys.containPoint(point))
// Hide axis pointer
return void this._hideAxisPointer(coordSys.name);allNotShow=!1;
// Make sure point is discrete on cateogry axis
var dimensions=coordSys.dimensions,value=coordSys.pointToData(point,!0);point=coordSys.dataToPoint(value);var baseAxis=coordSys.getBaseAxis(),axisType=axisPointerModel.get("axis");"auto"===axisType&&(axisType=baseAxis.dim);var contentNotChange=!1,lastHover=this._lastHover;if("cross"===axisPointerType)
// If hover data not changed
// Possible when two axes are all category
dataEqual(lastHover.data,value)&&(contentNotChange=!0),lastHover.data=value;else{var valIndex=zrUtil.indexOf(dimensions,axisType);lastHover.data===value[valIndex]&&(contentNotChange=!0),lastHover.data=value[valIndex]}"cartesian2d"!==coordSys.type||contentNotChange?"polar"!==coordSys.type||contentNotChange?"single"!==coordSys.type||contentNotChange||this._showSinglePointer(axisPointerModel,coordSys,axisType,point):this._showPolarPointer(axisPointerModel,coordSys,axisType,point):this._showCartesianPointer(axisPointerModel,coordSys,axisType,point),"cross"!==axisPointerType&&this._dispatchAndShowSeriesTooltipContent(coordSys,seriesCoordSysSameAxis.series,point,value,contentNotChange)},this),allNotShow&&this._hide()},/**
	         * Show tooltip on axis of cartesian coordinate
	         * @param {module:echarts/model/Model} axisPointerModel
	         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians
	         * @param {string} axisType
	         * @param {Array.<number>} point
	         * @private
	         */
_showCartesianPointer:function(axisPointerModel,cartesian,axisType,point){/**
	             * @inner
	             */
function moveGridLine(axisType,point,otherExtent){var targetShape="x"===axisType?makeLineShape(point[0],otherExtent[0],point[0],otherExtent[1]):makeLineShape(otherExtent[0],point[1],otherExtent[1],point[1]),pointerEl=self._getPointerElement(cartesian,axisPointerModel,axisType,targetShape);moveAnimation?graphic.updateProps(pointerEl,{shape:targetShape},axisPointerModel):pointerEl.attr({shape:targetShape})}/**
	             * @inner
	             */
function moveGridShadow(axisType,point,otherExtent){var axis=cartesian.getAxis(axisType),bandWidth=axis.getBandWidth(),span=otherExtent[1]-otherExtent[0],targetShape="x"===axisType?makeRectShape(point[0]-bandWidth/2,otherExtent[0],bandWidth,span):makeRectShape(otherExtent[0],point[1]-bandWidth/2,span,bandWidth),pointerEl=self._getPointerElement(cartesian,axisPointerModel,axisType,targetShape);moveAnimation?graphic.updateProps(pointerEl,{shape:targetShape},axisPointerModel):pointerEl.attr({shape:targetShape})}var self=this,axisPointerType=axisPointerModel.get("type"),moveAnimation="cross"!==axisPointerType;if("cross"===axisPointerType)moveGridLine("x",point,cartesian.getAxis("y").getGlobalExtent()),moveGridLine("y",point,cartesian.getAxis("x").getGlobalExtent()),this._updateCrossText(cartesian,point,axisPointerModel);else{var otherAxis=cartesian.getAxis("x"===axisType?"y":"x"),otherExtent=otherAxis.getGlobalExtent();"cartesian2d"===cartesian.type&&("line"===axisPointerType?moveGridLine:moveGridShadow)(axisType,point,otherExtent)}},_showSinglePointer:function(axisPointerModel,single,axisType,point){/**
	             * @inner
	             */
function moveSingleLine(axisType,point,otherExtent){var axis=single.getAxis(),orient=axis.orient,targetShape="horizontal"===orient?makeLineShape(point[0],otherExtent[0],point[0],otherExtent[1]):makeLineShape(otherExtent[0],point[1],otherExtent[1],point[1]),pointerEl=self._getPointerElement(single,axisPointerModel,axisType,targetShape);moveAnimation?graphic.updateProps(pointerEl,{shape:targetShape},axisPointerModel):pointerEl.attr({shape:targetShape})}var self=this,axisPointerType=axisPointerModel.get("type"),moveAnimation="cross"!==axisPointerType,rect=single.getRect(),otherExtent=[rect.y,rect.y+rect.height];moveSingleLine(axisType,point,otherExtent)},/**
	         * Show tooltip on axis of polar coordinate
	         * @param {module:echarts/model/Model} axisPointerModel
	         * @param {Array.<module:echarts/coord/polar/Polar>} polar
	         * @param {string} axisType
	         * @param {Array.<number>} point
	         */
_showPolarPointer:function(axisPointerModel,polar,axisType,point){/**
	             * @inner
	             */
function movePolarLine(axisType,point,otherExtent){var targetShape,mouseCoord=polar.pointToCoord(point);if("angle"===axisType){var p1=polar.coordToPoint([otherExtent[0],mouseCoord[1]]),p2=polar.coordToPoint([otherExtent[1],mouseCoord[1]]);targetShape=makeLineShape(p1[0],p1[1],p2[0],p2[1])}else targetShape={cx:polar.cx,cy:polar.cy,r:mouseCoord[0]};var pointerEl=self._getPointerElement(polar,axisPointerModel,axisType,targetShape);moveAnimation?graphic.updateProps(pointerEl,{shape:targetShape},axisPointerModel):pointerEl.attr({shape:targetShape})}/**
	             * @inner
	             */
function movePolarShadow(axisType,point,otherExtent){var targetShape,axis=polar.getAxis(axisType),bandWidth=axis.getBandWidth(),mouseCoord=polar.pointToCoord(point),radian=Math.PI/180;targetShape="angle"===axisType?makeSectorShape(polar.cx,polar.cy,otherExtent[0],otherExtent[1],
// In ECharts y is negative if angle is positive
(-mouseCoord[1]-bandWidth/2)*radian,(-mouseCoord[1]+bandWidth/2)*radian):makeSectorShape(polar.cx,polar.cy,mouseCoord[0]-bandWidth/2,mouseCoord[0]+bandWidth/2,0,2*Math.PI);var pointerEl=self._getPointerElement(polar,axisPointerModel,axisType,targetShape);moveAnimation?graphic.updateProps(pointerEl,{shape:targetShape},axisPointerModel):pointerEl.attr({shape:targetShape})}var self=this,axisPointerType=axisPointerModel.get("type"),angleAxis=polar.getAngleAxis(),radiusAxis=polar.getRadiusAxis(),moveAnimation="cross"!==axisPointerType;if("cross"===axisPointerType)movePolarLine("angle",point,radiusAxis.getExtent()),movePolarLine("radius",point,angleAxis.getExtent()),this._updateCrossText(polar,point,axisPointerModel);else{var otherAxis=polar.getAxis("radius"===axisType?"angle":"radius"),otherExtent=otherAxis.getExtent();("line"===axisPointerType?movePolarLine:movePolarShadow)(axisType,point,otherExtent)}},_updateCrossText:function(coordSys,point,axisPointerModel){var crossStyleModel=axisPointerModel.getModel("crossStyle"),textStyleModel=crossStyleModel.getModel("textStyle"),tooltipModel=this._tooltipModel,text=this._crossText;text||(text=this._crossText=new graphic.Text({style:{textAlign:"left",textVerticalAlign:"bottom"}}),this.group.add(text));var value=coordSys.pointToData(point),dims=coordSys.dimensions;value=zrUtil.map(value,function(val,idx){var axis=coordSys.getAxis(dims[idx]);return val="category"===axis.type||"time"===axis.type?axis.scale.getLabel(val):formatUtil.addCommas(val.toFixed(axis.getPixelPrecision()))}),text.setStyle({fill:textStyleModel.getTextColor()||crossStyleModel.get("color"),textFont:textStyleModel.getFont(),text:value.join(", "),x:point[0]+5,y:point[1]-5}),text.z=tooltipModel.get("z"),text.zlevel=tooltipModel.get("zlevel")},_getPointerElement:function(coordSys,pointerModel,axisType,initShape){var tooltipModel=this._tooltipModel,z=tooltipModel.get("z"),zlevel=tooltipModel.get("zlevel"),axisPointers=this._axisPointers,coordSysName=coordSys.name;if(axisPointers[coordSysName]=axisPointers[coordSysName]||{},axisPointers[coordSysName][axisType])return axisPointers[coordSysName][axisType];
// Create if not exists
var pointerType=pointerModel.get("type"),styleModel=pointerModel.getModel(pointerType+"Style"),isShadow="shadow"===pointerType,style=styleModel[isShadow?"getAreaStyle":"getLineStyle"](),elementType="polar"===coordSys.type?isShadow?"Sector":"radius"===axisType?"Circle":"Line":isShadow?"Rect":"Line";isShadow?style.stroke=null:style.fill=null;var el=axisPointers[coordSysName][axisType]=new graphic[elementType]({style:style,z:z,zlevel:zlevel,silent:!0,shape:initShape});return this.group.add(el),el},/**
	         * Dispatch actions and show tooltip on series
	         * @param {Array.<module:echarts/model/Series>} seriesList
	         * @param {Array.<number>} point
	         * @param {Array.<number>} value
	         * @param {boolean} contentNotChange
	         * @param {Object} e
	         */
_dispatchAndShowSeriesTooltipContent:function(coordSys,seriesList,point,value,contentNotChange){var rootTooltipModel=this._tooltipModel,tooltipContent=this._tooltipContent,baseAxis=coordSys.getBaseAxis(),payloadBatch=zrUtil.map(seriesList,function(series){return{seriesIndex:series.seriesIndex,dataIndex:series.getAxisTooltipDataIndex?series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim),value,baseAxis):series.getData().indexOfNearest(series.coordDimToDataDim(baseAxis.dim)[0],value["x"===baseAxis.dim||"radius"===baseAxis.dim?0:1])}}),lastHover=this._lastHover,api=this._api;if(
// Dispatch downplay action
lastHover.payloadBatch&&!contentNotChange&&api.dispatchAction({type:"downplay",batch:lastHover.payloadBatch}),
// Dispatch highlight action
contentNotChange||(api.dispatchAction({type:"highlight",batch:payloadBatch}),lastHover.payloadBatch=payloadBatch),
// Dispatch showTip action
api.dispatchAction({type:"showTip",dataIndex:payloadBatch[0].dataIndex,seriesIndex:payloadBatch[0].seriesIndex,from:this.uid}),baseAxis&&rootTooltipModel.get("showContent")){var html,formatter=rootTooltipModel.get("formatter"),positionExpr=rootTooltipModel.get("position"),paramsList=zrUtil.map(seriesList,function(series,index){return series.getDataParams(payloadBatch[index].dataIndex)});
// If only one series
// FIXME
// if (paramsList.length === 1) {
//     paramsList = paramsList[0];
// }
tooltipContent.show(rootTooltipModel);
// Update html content
var firstDataIndex=payloadBatch[0].dataIndex;if(!contentNotChange){if(
// Reset ticket
this._ticket="",formatter){if("string"==typeof formatter)html=formatUtil.formatTpl(formatter,paramsList);else if("function"==typeof formatter){var self=this,ticket="axis_"+coordSys.name+"_"+firstDataIndex,callback=function(cbTicket,html){cbTicket===self._ticket&&(tooltipContent.setContent(html),updatePosition(positionExpr,point[0],point[1],tooltipContent,paramsList,null,api))};self._ticket=ticket,html=formatter(paramsList,ticket,callback)}}else{
// Default tooltip content
// FIXME
// (1) shold be the first data which has name?
// (2) themeRiver, firstDataIndex is array, and first line is unnecessary.
var firstLine=seriesList[0].getData().getName(firstDataIndex);html=(firstLine?firstLine+"<br />":"")+zrUtil.map(seriesList,function(series,index){return series.formatTooltip(payloadBatch[index].dataIndex,!0)}).join("<br />")}tooltipContent.setContent(html)}updatePosition(positionExpr,point[0],point[1],tooltipContent,paramsList,null,api)}},/**
	         * Show tooltip on item
	         * @param {module:echarts/model/Series} seriesModel
	         * @param {number} dataIndex
	         * @param {Object} e
	         */
_showItemTooltipContent:function(seriesModel,dataIndex,e){
// FIXME Graph data
var api=this._api,data=seriesModel.getData(),itemModel=data.getItemModel(dataIndex),rootTooltipModel=this._tooltipModel,tooltipContent=this._tooltipContent,tooltipModel=itemModel.getModel("tooltip");if(
// If series model
tooltipModel.parentModel?tooltipModel.parentModel.parentModel=rootTooltipModel:tooltipModel.parentModel=this._tooltipModel,tooltipModel.get("showContent")){var html,formatter=tooltipModel.get("formatter"),positionExpr=tooltipModel.get("position"),params=seriesModel.getDataParams(dataIndex);if(formatter){if("string"==typeof formatter)html=formatUtil.formatTpl(formatter,params);else if("function"==typeof formatter){var self=this,ticket="item_"+seriesModel.name+"_"+dataIndex,callback=function(cbTicket,html){cbTicket===self._ticket&&(tooltipContent.setContent(html),updatePosition(positionExpr,e.offsetX,e.offsetY,tooltipContent,params,e.target,api))};self._ticket=ticket,html=formatter(params,ticket,callback)}}else html=seriesModel.formatTooltip(dataIndex);tooltipContent.show(tooltipModel),tooltipContent.setContent(html),updatePosition(positionExpr,e.offsetX,e.offsetY,tooltipContent,params,e.target,api)}},/**
	         * Show axis pointer
	         * @param {string} [coordSysName]
	         */
_showAxisPointer:function(coordSysName){if(coordSysName){var axisPointers=this._axisPointers[coordSysName];axisPointers&&zrUtil.each(axisPointers,function(el){el.show()})}else this.group.eachChild(function(child){child.show()}),this.group.show()},_resetLastHover:function(){var lastHover=this._lastHover;lastHover.payloadBatch&&this._api.dispatchAction({type:"downplay",batch:lastHover.payloadBatch}),
// Reset lastHover
this._lastHover={}},/**
	         * Hide axis pointer
	         * @param {string} [coordSysName]
	         */
_hideAxisPointer:function(coordSysName){if(coordSysName){var axisPointers=this._axisPointers[coordSysName];axisPointers&&zrUtil.each(axisPointers,function(el){el.hide()})}else this.group.hide()},_hide:function(){clearTimeout(this._showTimeout),this._hideAxisPointer(),this._resetLastHover(),this._alwaysShowContent||this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")),this._api.dispatchAction({type:"hideTip",from:this.uid}),this._lastX=this._lastY=null},dispose:function(ecModel,api){if(!env.node){var zr=api.getZr();this._tooltipContent.hide(),zr.off("click",this._tryShow),zr.off("mousemove",this._mousemove),zr.off("mouseout",this._hide),zr.off("globalout",this._hide),api.off("showTip",this._manuallyShowTip),api.off("hideTip",this._manuallyHideTip)}}})},/* 271 */
/***/
function(module,exports,__webpack_require__){/**
	     * @param {number} duration
	     * @return {string}
	     * @inner
	     */
function assembleTransition(duration){var transitionCurve="cubic-bezier(0.23, 1, 0.32, 1)",transitionText="left "+duration+"s "+transitionCurve+",top "+duration+"s "+transitionCurve;return zrUtil.map(vendors,function(vendorPrefix){return vendorPrefix+"transition:"+transitionText}).join(";")}/**
	     * @param {Object} textStyle
	     * @return {string}
	     * @inner
	     */
function assembleFont(textStyleModel){var cssText=[],fontSize=textStyleModel.get("fontSize"),color=textStyleModel.getTextColor();return color&&cssText.push("color:"+color),cssText.push("font:"+textStyleModel.getFont()),fontSize&&cssText.push("line-height:"+Math.round(3*fontSize/2)+"px"),each(["decoration","align"],function(name){var val=textStyleModel.get(name);val&&cssText.push("text-"+name+":"+val)}),cssText.join(";")}/**
	     * @param {Object} tooltipModel
	     * @return {string}
	     * @inner
	     */
function assembleCssText(tooltipModel){tooltipModel=tooltipModel;var cssText=[],transitionDuration=tooltipModel.get("transitionDuration"),backgroundColor=tooltipModel.get("backgroundColor"),textStyleModel=tooltipModel.getModel("textStyle"),padding=tooltipModel.get("padding");
// Animation transition
// for ie
// Border style
// Text style
// Padding
return transitionDuration&&cssText.push(assembleTransition(transitionDuration)),backgroundColor&&(cssText.push("background-Color:"+zrColor.toHex(backgroundColor)),cssText.push("filter:alpha(opacity=70)"),cssText.push("background-Color:"+backgroundColor)),each(["width","color","radius"],function(name){var borderName="border-"+name,camelCase=toCamelCase(borderName),val=tooltipModel.get(camelCase);null!=val&&cssText.push(borderName+":"+val+("color"===name?"":"px"))}),cssText.push(assembleFont(textStyleModel)),null!=padding&&cssText.push("padding:"+formatUtil.normalizeCssArray(padding).join("px ")+"px"),cssText.join(";")+";"}/**
	     * @alias module:echarts/component/tooltip/TooltipContent
	     * @constructor
	     */
function TooltipContent(container,api){var el=document.createElement("div"),zr=api.getZr();this.el=el,this._x=api.getWidth()/2,this._y=api.getHeight()/2,container.appendChild(el),this._container=container,this._show=!1,/**
	         * @private
	         */
this._hideTimeout;var self=this;el.onmouseenter=function(){
// clear the timeout in hideLater and keep showing tooltip
self.enterable&&(clearTimeout(self._hideTimeout),self._show=!0),self._inContent=!0},el.onmousemove=function(e){if(!self.enterable){
// Try trigger zrender event to avoid mouse
// in and out shape too frequently
var handler=zr.handler;eventUtil.normalizeEvent(container,e),handler.dispatch("mousemove",e)}},el.onmouseleave=function(){self.enterable&&self._show&&self.hideLater(self._hideDelay),self._inContent=!1},compromiseMobile(el,container)}function compromiseMobile(tooltipContentEl,container){function preventDefault(e){contains(e.target)&&e.preventDefault()}function contains(targetEl){for(;targetEl&&targetEl!==container;){if(targetEl===tooltipContentEl)return!0;targetEl=targetEl.parentNode}}
// Prevent default behavior on mobile. For example,
// default pinch gesture will cause browser zoom.
// We do not preventing event on tooltip contnet el,
// because user may need customization in tooltip el.
eventUtil.addEventListener(container,"touchstart",preventDefault),eventUtil.addEventListener(container,"touchmove",preventDefault),eventUtil.addEventListener(container,"touchend",preventDefault)}/**
	 * @module echarts/component/tooltip/TooltipContent
	 */
var zrUtil=__webpack_require__(3),zrColor=__webpack_require__(38),eventUtil=__webpack_require__(80),formatUtil=__webpack_require__(6),each=zrUtil.each,toCamelCase=formatUtil.toCamelCase,vendors=["","-webkit-","-moz-","-o-"],gCssText="position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";TooltipContent.prototype={constructor:TooltipContent,enterable:!0,/**
	         * Update when tooltip is rendered
	         */
update:function(){var container=this._container,stl=container.currentStyle||document.defaultView.getComputedStyle(container),domStyle=container.style;"absolute"!==domStyle.position&&"absolute"!==stl.position&&(domStyle.position="relative")},show:function(tooltipModel){clearTimeout(this._hideTimeout),this.el.style.cssText=gCssText+assembleCssText(tooltipModel)+";left:"+this._x+"px;top:"+this._y+"px;"+(tooltipModel.get("extraCssText")||""),this._show=!0},setContent:function(content){var el=this.el;el.innerHTML=content,el.style.display=content?"block":"none"},moveTo:function(x,y){var style=this.el.style;style.left=x+"px",style.top=y+"px",this._x=x,this._y=y},hide:function(){this.el.style.display="none",this._show=!1},
// showLater: function ()
hideLater:function(time){!this._show||this._inContent&&this.enterable||(time?(this._hideDelay=time,
// Set show false to avoid invoke hideLater mutiple times
this._show=!1,this._hideTimeout=setTimeout(zrUtil.bind(this.hide,this),time)):this.hide())},isShow:function(){return this._show}},module.exports=TooltipContent},/* 272 */
/***/
function(module,exports,__webpack_require__){"use strict";__webpack_require__(273),__webpack_require__(279),__webpack_require__(281),
// Polar view
__webpack_require__(1).extendComponentView({type:"polar"})},/* 273 */
/***/
function(module,exports,__webpack_require__){/**
	     * Resize method bound to the polar
	     * @param {module:echarts/coord/polar/PolarModel} polarModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
function resizePolar(polarModel,api){var center=polarModel.get("center"),radius=polarModel.get("radius"),width=api.getWidth(),height=api.getHeight(),parsePercent=numberUtil.parsePercent;this.cx=parsePercent(center[0],width),this.cy=parsePercent(center[1],height);var radiusAxis=this.getRadiusAxis(),size=Math.min(width,height)/2;
// var idx = radiusAxis.inverse ? 1 : 0;
radiusAxis.setExtent(0,parsePercent(radius,size))}/**
	     * Update polar
	     */
function updatePolarScale(ecModel,api){var polar=this,angleAxis=polar.getAngleAxis(),radiusAxis=polar.getRadiusAxis();
// Fix extent of category angle axis
if(
// Reset scale
angleAxis.scale.setExtent(1/0,-(1/0)),radiusAxis.scale.setExtent(1/0,-(1/0)),ecModel.eachSeries(function(seriesModel){if(seriesModel.coordinateSystem===polar){var data=seriesModel.getData();radiusAxis.scale.unionExtent(data.getDataExtent("radius","category"!==radiusAxis.type)),angleAxis.scale.unionExtent(data.getDataExtent("angle","category"!==angleAxis.type))}}),niceScaleExtent(angleAxis,angleAxis.model),niceScaleExtent(radiusAxis,radiusAxis.model),"category"===angleAxis.type&&!angleAxis.onBand){var extent=angleAxis.getExtent(),diff=360/angleAxis.scale.count();angleAxis.inverse?extent[1]+=diff:extent[1]-=diff,angleAxis.setExtent(extent[0],extent[1])}}/**
	     * Set common axis properties
	     * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
	     * @param {module:echarts/coord/polar/AxisModel}
	     * @inner
	     */
function setAxis(axis,axisModel){
// FIXME Radius axis not support inverse axis
if(axis.type=axisModel.get("type"),axis.scale=axisHelper.createScaleByModel(axisModel),axis.onBand=axisModel.get("boundaryGap")&&"category"===axis.type,"angleAxis"===axisModel.mainType){var startAngle=axisModel.get("startAngle");axis.inverse=axisModel.get("inverse")^axisModel.get("clockwise"),axis.setExtent(startAngle,startAngle+(axis.inverse?-360:360))}
// Inject axis instance
axisModel.axis=axis,axis.model=axisModel}
// TODO Axis scale
var Polar=__webpack_require__(274),numberUtil=__webpack_require__(7),axisHelper=__webpack_require__(108),niceScaleExtent=axisHelper.niceScaleExtent;
// 依赖 PolarModel 做预处理
__webpack_require__(277);var polarCreator={dimensions:Polar.prototype.dimensions,create:function(ecModel,api){var polarList=[];
// Inject coordinateSystem to series
return ecModel.eachComponent("polar",function(polarModel,idx){var polar=new Polar(idx);
// Inject resize and update method
polar.resize=resizePolar,polar.update=updatePolarScale;var radiusAxis=polar.getRadiusAxis(),angleAxis=polar.getAngleAxis(),radiusAxisModel=polarModel.findAxisModel("radiusAxis"),angleAxisModel=polarModel.findAxisModel("angleAxis");setAxis(radiusAxis,radiusAxisModel),setAxis(angleAxis,angleAxisModel),polar.resize(polarModel,api),polarList.push(polar),polarModel.coordinateSystem=polar}),ecModel.eachSeries(function(seriesModel){"polar"===seriesModel.get("coordinateSystem")&&(seriesModel.coordinateSystem=polarList[seriesModel.get("polarIndex")])}),polarList}};__webpack_require__(25).register("polar",polarCreator)},/* 274 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	 * @module echarts/coord/polar/Polar
	 */
var RadiusAxis=__webpack_require__(275),AngleAxis=__webpack_require__(276),Polar=function(name){/**
	         * @type {string}
	         */
this.name=name||"",/**
	         * x of polar center
	         * @type {number}
	         */
this.cx=0,/**
	         * y of polar center
	         * @type {number}
	         */
this.cy=0,/**
	         * @type {module:echarts/coord/polar/RadiusAxis}
	         * @private
	         */
this._radiusAxis=new RadiusAxis,/**
	         * @type {module:echarts/coord/polar/AngleAxis}
	         * @private
	         */
this._angleAxis=new AngleAxis};Polar.prototype={constructor:Polar,type:"polar",/**
	         * @param {Array.<string>}
	         * @readOnly
	         */
dimensions:["radius","angle"],/**
	         * If contain coord
	         * @param {Array.<number>} point
	         * @return {boolean}
	         */
containPoint:function(point){var coord=this.pointToCoord(point);return this._radiusAxis.contain(coord[0])&&this._angleAxis.contain(coord[1])},/**
	         * If contain data
	         * @param {Array.<number>} data
	         * @return {boolean}
	         */
containData:function(data){return this._radiusAxis.containData(data[0])&&this._angleAxis.containData(data[1])},/**
	         * @param {string} axisType
	         * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
	         */
getAxis:function(axisType){return this["_"+axisType+"Axis"]},/**
	         * Get axes by type of scale
	         * @param {string} scaleType
	         * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
	         */
getAxesByScale:function(scaleType){var axes=[],angleAxis=this._angleAxis,radiusAxis=this._radiusAxis;return angleAxis.scale.type===scaleType&&axes.push(angleAxis),radiusAxis.scale.type===scaleType&&axes.push(radiusAxis),axes},/**
	         * @return {module:echarts/coord/polar/AngleAxis}
	         */
getAngleAxis:function(){return this._angleAxis},/**
	         * @return {module:echarts/coord/polar/RadiusAxis}
	         */
getRadiusAxis:function(){return this._radiusAxis},/**
	         * @param {module:echarts/coord/polar/Axis}
	         * @return {module:echarts/coord/polar/Axis}
	         */
getOtherAxis:function(axis){var angleAxis=this._angleAxis;return axis===angleAxis?this._radiusAxis:angleAxis},/**
	         * Base axis will be used on stacking.
	         *
	         * @return {module:echarts/coord/polar/Axis}
	         */
getBaseAxis:function(){return this.getAxesByScale("ordinal")[0]||this.getAxesByScale("time")[0]||this.getAngleAxis()},/**
	         * Convert series data to a list of (x, y) points
	         * @param {module:echarts/data/List} data
	         * @return {Array}
	         *  Return list of coordinates. For example:
	         *  `[[10, 10], [20, 20], [30, 30]]`
	         */
dataToPoints:function(data){return data.mapArray(this.dimensions,function(radius,angle){return this.dataToPoint([radius,angle])},this)},/**
	         * Convert a single data item to (x, y) point.
	         * Parameter data is an array which the first element is radius and the second is angle
	         * @param {Array.<number>} data
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
dataToPoint:function(data,clamp){return this.coordToPoint([this._radiusAxis.dataToRadius(data[0],clamp),this._angleAxis.dataToAngle(data[1],clamp)])},/**
	         * Convert a (x, y) point to data
	         * @param {Array.<number>} point
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
pointToData:function(point,clamp){var coord=this.pointToCoord(point);return[this._radiusAxis.radiusToData(coord[0],clamp),this._angleAxis.angleToData(coord[1],clamp)]},/**
	         * Convert a (x, y) point to (radius, angle) coord
	         * @param {Array.<number>} point
	         * @return {Array.<number>}
	         */
pointToCoord:function(point){var dx=point[0]-this.cx,dy=point[1]-this.cy,angleAxis=this.getAngleAxis(),extent=angleAxis.getExtent(),minAngle=Math.min(extent[0],extent[1]),maxAngle=Math.max(extent[0],extent[1]);angleAxis.inverse?minAngle=maxAngle-360:maxAngle=minAngle+360;var radius=Math.sqrt(dx*dx+dy*dy);dx/=radius,dy/=radius;for(var radian=Math.atan2(-dy,dx)/Math.PI*180,dir=minAngle>radian?1:-1;minAngle>radian||radian>maxAngle;)radian+=360*dir;return[radius,radian]},/**
	         * Convert a (radius, angle) coord to (x, y) point
	         * @param {Array.<number>} coord
	         * @return {Array.<number>}
	         */
coordToPoint:function(coord){var radius=coord[0],radian=coord[1]/180*Math.PI,x=Math.cos(radian)*radius+this.cx,y=-Math.sin(radian)*radius+this.cy;return[x,y]}},module.exports=Polar},/* 275 */
/***/
function(module,exports,__webpack_require__){"use strict";function RadiusAxis(scale,radiusExtent){Axis.call(this,"radius",scale,radiusExtent),/**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
this.type="category"}var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117);RadiusAxis.prototype={constructor:RadiusAxis,dataToRadius:Axis.prototype.dataToCoord,radiusToData:Axis.prototype.coordToData},zrUtil.inherits(RadiusAxis,Axis),module.exports=RadiusAxis},/* 276 */
/***/
function(module,exports,__webpack_require__){"use strict";function AngleAxis(scale,angleExtent){angleExtent=angleExtent||[0,360],Axis.call(this,"angle",scale,angleExtent),this.type="category"}var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117);AngleAxis.prototype={constructor:AngleAxis,dataToAngle:Axis.prototype.dataToCoord,angleToData:Axis.prototype.coordToData},zrUtil.inherits(AngleAxis,Axis),module.exports=AngleAxis},/* 277 */
/***/
function(module,exports,__webpack_require__){"use strict";__webpack_require__(278),__webpack_require__(1).extendComponentModel({type:"polar",dependencies:["polarAxis","angleAxis"],/**
	         * @type {module:echarts/coord/polar/Polar}
	         */
coordinateSystem:null,/**
	         * @param {string} axisType
	         * @return {module:echarts/coord/polar/AxisModel}
	         */
findAxisModel:function(axisType){var angleAxisModel,ecModel=this.ecModel;return ecModel.eachComponent(axisType,function(axisModel){ecModel.getComponent("polar",axisModel.getShallow("polarIndex"))===this&&(angleAxisModel=axisModel)},this),angleAxisModel},defaultOption:{zlevel:0,z:0,center:["50%","50%"],radius:"80%"}})},/* 278 */
/***/
function(module,exports,__webpack_require__){"use strict";function getAxisType(axisDim,option){
// Default axis with data is category axis
return option.type||(option.data?"category":"value")}var zrUtil=__webpack_require__(3),ComponentModel=__webpack_require__(19),axisModelCreator=__webpack_require__(121),PolarAxisModel=ComponentModel.extend({type:"polarAxis",/**
	         * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
	         */
axis:null});zrUtil.merge(PolarAxisModel.prototype,__webpack_require__(123));var polarAxisDefaultExtendedOption={angle:{polarIndex:0,startAngle:90,clockwise:!0,splitNumber:12,axisLabel:{rotate:!1}},radius:{polarIndex:0,splitNumber:5}};axisModelCreator("angle",PolarAxisModel,getAxisType,polarAxisDefaultExtendedOption.angle),axisModelCreator("radius",PolarAxisModel,getAxisType,polarAxisDefaultExtendedOption.radius)},/* 279 */
/***/
function(module,exports,__webpack_require__){"use strict";__webpack_require__(273),__webpack_require__(280)},/* 280 */
/***/
function(module,exports,__webpack_require__){"use strict";function getAxisLineShape(polar,r0,r,angle){var start=polar.coordToPoint([r0,angle]),end=polar.coordToPoint([r,angle]);return{x1:start[0],y1:start[1],x2:end[0],y2:end[1]}}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),Model=__webpack_require__(8),elementList=["axisLine","axisLabel","axisTick","splitLine","splitArea"];__webpack_require__(1).extendComponentView({type:"angleAxis",render:function(angleAxisModel,ecModel){if(this.group.removeAll(),angleAxisModel.get("show")){var polarModel=ecModel.getComponent("polar",angleAxisModel.get("polarIndex")),angleAxis=angleAxisModel.axis,polar=polarModel.coordinateSystem,radiusExtent=polar.getRadiusAxis().getExtent(),ticksAngles=angleAxis.getTicksCoords();"category"!==angleAxis.type&&
// Remove the last tick which will overlap the first tick
ticksAngles.pop(),zrUtil.each(elementList,function(name){angleAxisModel.get(name+".show")&&this["_"+name](angleAxisModel,polar,ticksAngles,radiusExtent)},this)}},/**
	         * @private
	         */
_axisLine:function(angleAxisModel,polar,ticksAngles,radiusExtent){var lineStyleModel=angleAxisModel.getModel("axisLine.lineStyle"),circle=new graphic.Circle({shape:{cx:polar.cx,cy:polar.cy,r:radiusExtent[1]},style:lineStyleModel.getLineStyle(),z2:1,silent:!0});circle.style.fill=null,this.group.add(circle)},/**
	         * @private
	         */
_axisTick:function(angleAxisModel,polar,ticksAngles,radiusExtent){var tickModel=angleAxisModel.getModel("axisTick"),tickLen=(tickModel.get("inside")?-1:1)*tickModel.get("length"),lines=zrUtil.map(ticksAngles,function(tickAngle){return new graphic.Line({shape:getAxisLineShape(polar,radiusExtent[1],radiusExtent[1]+tickLen,tickAngle)})});this.group.add(graphic.mergePath(lines,{style:tickModel.getModel("lineStyle").getLineStyle()}))},/**
	         * @private
	         */
_axisLabel:function(angleAxisModel,polar,ticksAngles,radiusExtent){
// Use length of ticksAngles because it may remove the last tick to avoid overlapping
for(var axis=angleAxisModel.axis,categoryData=angleAxisModel.get("data"),labelModel=angleAxisModel.getModel("axisLabel"),axisTextStyleModel=labelModel.getModel("textStyle"),labels=angleAxisModel.getFormattedLabels(),labelMargin=labelModel.get("margin"),labelsAngles=axis.getLabelsCoords(),i=0;i<ticksAngles.length;i++){var r=radiusExtent[1],p=polar.coordToPoint([r+labelMargin,labelsAngles[i]]),cx=polar.cx,cy=polar.cy,labelTextAlign=Math.abs(p[0]-cx)/r<.3?"center":p[0]>cx?"left":"right",labelTextBaseline=Math.abs(p[1]-cy)/r<.3?"middle":p[1]>cy?"top":"bottom",textStyleModel=axisTextStyleModel;categoryData&&categoryData[i]&&categoryData[i].textStyle&&(textStyleModel=new Model(categoryData[i].textStyle,axisTextStyleModel)),this.group.add(new graphic.Text({style:{x:p[0],y:p[1],fill:textStyleModel.getTextColor(),text:labels[i],textAlign:labelTextAlign,textVerticalAlign:labelTextBaseline,textFont:textStyleModel.getFont()},silent:!0}))}},/**
	         * @private
	         */
_splitLine:function(angleAxisModel,polar,ticksAngles,radiusExtent){var splitLineModel=angleAxisModel.getModel("splitLine"),lineStyleModel=splitLineModel.getModel("lineStyle"),lineColors=lineStyleModel.get("color"),lineCount=0;lineColors=lineColors instanceof Array?lineColors:[lineColors];for(var splitLines=[],i=0;i<ticksAngles.length;i++){var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[],splitLines[colorIndex].push(new graphic.Line({shape:getAxisLineShape(polar,radiusExtent[0],radiusExtent[1],ticksAngles[i])}))}
// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitLines.length;i++)this.group.add(graphic.mergePath(splitLines[i],{style:zrUtil.defaults({stroke:lineColors[i%lineColors.length]},lineStyleModel.getLineStyle()),silent:!0,z:angleAxisModel.get("z")}))},/**
	         * @private
	         */
_splitArea:function(angleAxisModel,polar,ticksAngles,radiusExtent){var splitAreaModel=angleAxisModel.getModel("splitArea"),areaStyleModel=splitAreaModel.getModel("areaStyle"),areaColors=areaStyleModel.get("color"),lineCount=0;areaColors=areaColors instanceof Array?areaColors:[areaColors];for(var splitAreas=[],RADIAN=Math.PI/180,prevAngle=-ticksAngles[0]*RADIAN,r0=Math.min(radiusExtent[0],radiusExtent[1]),r1=Math.max(radiusExtent[0],radiusExtent[1]),clockwise=angleAxisModel.get("clockwise"),i=1;i<ticksAngles.length;i++){var colorIndex=lineCount++%areaColors.length;splitAreas[colorIndex]=splitAreas[colorIndex]||[],splitAreas[colorIndex].push(new graphic.Sector({shape:{cx:polar.cx,cy:polar.cy,r0:r0,r:r1,startAngle:prevAngle,endAngle:-ticksAngles[i]*RADIAN,clockwise:clockwise},silent:!0})),prevAngle=-ticksAngles[i]*RADIAN}
// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitAreas.length;i++)this.group.add(graphic.mergePath(splitAreas[i],{style:zrUtil.defaults({fill:areaColors[i%areaColors.length]},areaStyleModel.getAreaStyle()),silent:!0}))}})},/* 281 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(273),__webpack_require__(282)},/* 282 */
/***/
function(module,exports,__webpack_require__){"use strict";/**
	     * @inner
	     */
function layoutAxis(polar,radiusAxisModel,axisAngle){return{position:[polar.cx,polar.cy],rotation:axisAngle/180*Math.PI,labelDirection:-1,tickDirection:-1,nameDirection:1,labelRotation:radiusAxisModel.getModel("axisLabel").get("rotate"),
// Over splitLine and splitArea
z2:1}}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),AxisBuilder=__webpack_require__(126),axisBuilderAttrs=["axisLine","axisLabel","axisTick","axisName"],selfBuilderAttrs=["splitLine","splitArea"];__webpack_require__(1).extendComponentView({type:"radiusAxis",render:function(radiusAxisModel,ecModel){if(this.group.removeAll(),radiusAxisModel.get("show")){var polarModel=ecModel.getComponent("polar",radiusAxisModel.get("polarIndex")),angleAxis=polarModel.coordinateSystem.getAngleAxis(),radiusAxis=radiusAxisModel.axis,polar=polarModel.coordinateSystem,ticksCoords=radiusAxis.getTicksCoords(),axisAngle=angleAxis.getExtent()[0],radiusExtent=radiusAxis.getExtent(),layout=layoutAxis(polar,radiusAxisModel,axisAngle),axisBuilder=new AxisBuilder(radiusAxisModel,layout);zrUtil.each(axisBuilderAttrs,axisBuilder.add,axisBuilder),this.group.add(axisBuilder.getGroup()),zrUtil.each(selfBuilderAttrs,function(name){radiusAxisModel.get(name+".show")&&this["_"+name](radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords)},this)}},/**
	         * @private
	         */
_splitLine:function(radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords){var splitLineModel=radiusAxisModel.getModel("splitLine"),lineStyleModel=splitLineModel.getModel("lineStyle"),lineColors=lineStyleModel.get("color"),lineCount=0;lineColors=lineColors instanceof Array?lineColors:[lineColors];for(var splitLines=[],i=0;i<ticksCoords.length;i++){var colorIndex=lineCount++%lineColors.length;splitLines[colorIndex]=splitLines[colorIndex]||[],splitLines[colorIndex].push(new graphic.Circle({shape:{cx:polar.cx,cy:polar.cy,r:ticksCoords[i]},silent:!0}))}
// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitLines.length;i++)this.group.add(graphic.mergePath(splitLines[i],{style:zrUtil.defaults({stroke:lineColors[i%lineColors.length],fill:null},lineStyleModel.getLineStyle()),silent:!0}))},/**
	         * @private
	         */
_splitArea:function(radiusAxisModel,polar,axisAngle,radiusExtent,ticksCoords){var splitAreaModel=radiusAxisModel.getModel("splitArea"),areaStyleModel=splitAreaModel.getModel("areaStyle"),areaColors=areaStyleModel.get("color"),lineCount=0;areaColors=areaColors instanceof Array?areaColors:[areaColors];for(var splitAreas=[],prevRadius=ticksCoords[0],i=1;i<ticksCoords.length;i++){var colorIndex=lineCount++%areaColors.length;splitAreas[colorIndex]=splitAreas[colorIndex]||[],splitAreas[colorIndex].push(new graphic.Sector({shape:{cx:polar.cx,cy:polar.cy,r0:prevRadius,r:ticksCoords[i],startAngle:0,endAngle:2*Math.PI},silent:!0})),prevRadius=ticksCoords[i]}
// Simple optimization
// Batching the lines if color are the same
for(var i=0;i<splitAreas.length;i++)this.group.add(graphic.mergePath(splitAreas[i],{style:zrUtil.defaults({fill:areaColors[i%areaColors.length]},areaStyleModel.getAreaStyle()),silent:!0}))}})},/* 283 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(163),__webpack_require__(284),__webpack_require__(161)},/* 284 */
/***/
function(module,exports,__webpack_require__){"use strict";var MapDraw=__webpack_require__(158);module.exports=__webpack_require__(1).extendComponentView({type:"geo",init:function(ecModel,api){var mapDraw=new MapDraw(api,!0);this._mapDraw=mapDraw,this.group.add(mapDraw.group)},render:function(geoModel,ecModel,api){geoModel.get("show")&&this._mapDraw.draw(geoModel,ecModel,api)}})},/* 285 */
/***/
function(module,exports,__webpack_require__){"use strict";var echarts=__webpack_require__(1),graphic=__webpack_require__(42),layout=__webpack_require__(21);
// Model
echarts.extendComponentModel({type:"title",layoutMode:{type:"box",ignoreSize:!0},defaultOption:{
// 一级层叠
zlevel:0,
// 二级层叠
z:6,show:!0,text:"",
// 超链接跳转
// link: null,
// 仅支持self | blank
target:"blank",subtext:"",
// 超链接跳转
// sublink: null,
// 仅支持self | blank
subtarget:"blank",
// 'center' ¦ 'left' ¦ 'right'
// ¦ {number}（x坐标，单位px）
left:0,
// 'top' ¦ 'bottom' ¦ 'center'
// ¦ {number}（y坐标，单位px）
top:0,
// 水平对齐
// 'auto' | 'left' | 'right'
// 默认根据 x 的位置判断是左对齐还是右对齐
//textAlign: null
backgroundColor:"rgba(0,0,0,0)",
// 标题边框颜色
borderColor:"#ccc",
// 标题边框线宽，单位px，默认为0（无边框）
borderWidth:0,
// 标题内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
padding:5,
// 主副标题纵向间隔，单位px，默认为10，
itemGap:10,textStyle:{fontSize:18,fontWeight:"bolder",
// 主标题文字颜色
color:"#333"},subtextStyle:{
// 副标题文字颜色
color:"#aaa"}}}),
// View
echarts.extendComponentView({type:"title",render:function(titleModel,ecModel,api){if(this.group.removeAll(),titleModel.get("show")){var group=this.group,textStyleModel=titleModel.getModel("textStyle"),subtextStyleModel=titleModel.getModel("subtextStyle"),textAlign=titleModel.get("textAlign"),textEl=new graphic.Text({style:{text:titleModel.get("text"),textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor(),textBaseline:"top"},z2:10}),textRect=textEl.getBoundingRect(),subText=titleModel.get("subtext"),subTextEl=new graphic.Text({style:{text:subText,textFont:subtextStyleModel.getFont(),fill:subtextStyleModel.getTextColor(),y:textRect.height+titleModel.get("itemGap"),textBaseline:"top"},z2:10}),link=titleModel.get("link"),sublink=titleModel.get("sublink");textEl.silent=!link,subTextEl.silent=!sublink,link&&textEl.on("click",function(){window.open(link,"_"+titleModel.get("target"))}),sublink&&subTextEl.on("click",function(){window.open(sublink,"_"+titleModel.get("subtarget"))}),group.add(textEl),subText&&group.add(subTextEl);
// If no subText, but add subTextEl, there will be an empty line.
var groupRect=group.getBoundingRect(),layoutOption=titleModel.getBoxLayoutParams();layoutOption.width=groupRect.width,layoutOption.height=groupRect.height;var layoutRect=layout.getLayoutRect(layoutOption,{width:api.getWidth(),height:api.getHeight()},titleModel.get("padding"));
// Adjust text align based on position
textAlign||(textAlign=titleModel.get("left")||titleModel.get("right"),"middle"===textAlign&&(textAlign="center"),"right"===textAlign?layoutRect.x+=layoutRect.width:"center"===textAlign&&(layoutRect.x+=layoutRect.width/2)),group.position=[layoutRect.x,layoutRect.y],textEl.setStyle("textAlign",textAlign),subTextEl.setStyle("textAlign",textAlign),
// Render background
// Get groupRect again because textAlign has been changed
groupRect=group.getBoundingRect();var padding=layoutRect.margin,style=titleModel.getItemStyle(["color","opacity"]);style.fill=titleModel.get("backgroundColor");var rect=new graphic.Rect({shape:{x:groupRect.x-padding[3],y:groupRect.y-padding[0],width:groupRect.width+padding[1]+padding[3],height:groupRect.height+padding[0]+padding[2]},style:style,silent:!0});graphic.subPixelOptimizeRect(rect),group.add(rect)}}})},/* 286 */
/***/
function(module,exports,__webpack_require__){/**
	 * DataZoom component entry
	 */
__webpack_require__(287),__webpack_require__(288),__webpack_require__(290),__webpack_require__(291),__webpack_require__(292),__webpack_require__(295),__webpack_require__(296),__webpack_require__(298),__webpack_require__(299)},/* 287 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(19).registerSubTypeDefaulter("dataZoom",function(option){
// Default 'slider' when no type specified.
return"slider"})},/* 288 */
/***/
function(module,exports,__webpack_require__){function retrieveRaw(option){var ret={};return each(["start","end","startValue","endValue"],function(name){ret[name]=option[name]}),ret}function processRangeProp(percentProp,valueProp,rawOption,thisOption){
// start/end has higher priority over startValue/endValue,
// but we should make chart.setOption({endValue: 1000}) effective,
// rather than chart.setOption({endValue: 1000, end: null}).
null!=rawOption[valueProp]&&null==rawOption[percentProp]&&(thisOption[percentProp]=null)}/**
	 * @file Data zoom model
	 */
var zrUtil=__webpack_require__(3),env=__webpack_require__(78),echarts=__webpack_require__(1),modelUtil=__webpack_require__(5),AxisProxy=__webpack_require__(289),each=zrUtil.each,eachAxisDim=modelUtil.eachAxisDim,DataZoomModel=echarts.extendComponentModel({type:"dataZoom",dependencies:["xAxis","yAxis","zAxis","radiusAxis","angleAxis","series"],/**
	         * @protected
	         */
defaultOption:{zlevel:0,z:4,// Higher than normal component (z: 2).
orient:null,// Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
xAxisIndex:null,// Default all horizontal category axis.
yAxisIndex:null,// Default all vertical category axis.
angleAxisIndex:null,radiusAxisIndex:null,filterMode:"filter",// Possible values: 'filter' or 'empty'.
// 'filter': data items which are out of window will be removed.
//           This option is applicable when filtering outliers.
// 'empty': data items which are out of window will be set to empty.
//          This option is applicable when user should not neglect
//          that there are some data items out of window.
// Taking line chart as an example, line will be broken in
// the filtered points when filterModel is set to 'empty', but
// be connected when set to 'filter'.
throttle:100,// Dispatch action by the fixed rate, avoid frequency.
// default 100. Do not throttle when use null/undefined.
start:0,// Start percent. 0 ~ 100
end:100,// End percent. 0 ~ 100
startValue:null,// Start value. If startValue specified, start is ignored.
endValue:null},/**
	         * @override
	         */
init:function(option,parentModel,ecModel){/**
	             * key like x_0, y_1
	             * @private
	             * @type {Object}
	             */
this._dataIntervalByAxis={},/**
	             * @private
	             */
this._dataInfo={},/**
	             * key like x_0, y_1
	             * @private
	             */
this._axisProxies={},/**
	             * @readOnly
	             */
this.textStyleModel;var rawOption=retrieveRaw(option);this.mergeDefaultAndTheme(option,ecModel),this.doInit(rawOption)},/**
	         * @override
	         */
mergeOption:function(newOption){var rawOption=retrieveRaw(newOption);
//FIX #2591
zrUtil.merge(this.option,newOption,!0),this.doInit(rawOption)},/**
	         * @protected
	         */
doInit:function(rawOption){var thisOption=this.option;
// Disable realtime view update if canvas is not supported.
env.canvasSupported||(thisOption.realtime=!1),processRangeProp("start","startValue",rawOption,thisOption),processRangeProp("end","endValue",rawOption,thisOption),this.textStyleModel=this.getModel("textStyle"),this._resetTarget(),this._giveAxisProxies()},/**
	         * @private
	         */
_giveAxisProxies:function(){var axisProxies=this._axisProxies;this.eachTargetAxis(function(dimNames,axisIndex,dataZoomModel,ecModel){var axisModel=this.dependentModels[dimNames.axis][axisIndex],axisProxy=axisModel.__dzAxisProxy||(
// Use the first dataZoomModel as the main model of axisProxy.
axisModel.__dzAxisProxy=new AxisProxy(dimNames.name,axisIndex,this,ecModel));
// FIXME
// dispose __dzAxisProxy
axisProxies[dimNames.name+"_"+axisIndex]=axisProxy},this)},/**
	         * @private
	         */
_resetTarget:function(){var thisOption=this.option,autoMode=this._judgeAutoMode();eachAxisDim(function(dimNames){var axisIndexName=dimNames.axisIndex;thisOption[axisIndexName]=modelUtil.normalizeToArray(thisOption[axisIndexName])},this),"axisIndex"===autoMode?this._autoSetAxisIndex():"orient"===autoMode&&this._autoSetOrient()},/**
	         * @private
	         */
_judgeAutoMode:function(){
// Auto set only works for setOption at the first time.
// The following is user's reponsibility. So using merged
// option is OK.
var thisOption=this.option,hasIndexSpecified=!1;eachAxisDim(function(dimNames){null!=thisOption[dimNames.axisIndex]&&(hasIndexSpecified=!0)},this);var orient=thisOption.orient;return null==orient&&hasIndexSpecified?"orient":hasIndexSpecified?void 0:(null==orient&&(thisOption.orient="horizontal"),"axisIndex")},/**
	         * @private
	         */
_autoSetAxisIndex:function(){var autoAxisIndex=!0,orient=this.get("orient",!0),thisOption=this.option;if(autoAxisIndex){
// Find axis that parallel to dataZoom as default.
var dimNames="vertical"===orient?{dim:"y",axisIndex:"yAxisIndex",axis:"yAxis"}:{dim:"x",axisIndex:"xAxisIndex",axis:"xAxis"};this.dependentModels[dimNames.axis].length&&(thisOption[dimNames.axisIndex]=[0],autoAxisIndex=!1)}autoAxisIndex&&
// Find the first category axis as default. (consider polar)
eachAxisDim(function(dimNames){if(autoAxisIndex){var axisIndices=[],axisModels=this.dependentModels[dimNames.axis];if(axisModels.length&&!axisIndices.length)for(var i=0,len=axisModels.length;len>i;i++)"category"===axisModels[i].get("type")&&axisIndices.push(i);thisOption[dimNames.axisIndex]=axisIndices,axisIndices.length&&(autoAxisIndex=!1)}},this),autoAxisIndex&&
// FIXME
// 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），
// 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？
// If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,
// dataZoom component auto adopts series that reference to
// both xAxis and yAxis which type is 'value'.
this.ecModel.eachSeries(function(seriesModel){this._isSeriesHasAllAxesTypeOf(seriesModel,"value")&&eachAxisDim(function(dimNames){var axisIndices=thisOption[dimNames.axisIndex],axisIndex=seriesModel.get(dimNames.axisIndex);zrUtil.indexOf(axisIndices,axisIndex)<0&&axisIndices.push(axisIndex)})},this)},/**
	         * @private
	         */
_autoSetOrient:function(){var dim;
// Find the first axis
this.eachTargetAxis(function(dimNames){!dim&&(dim=dimNames.name)},this),this.option.orient="y"===dim?"vertical":"horizontal"},/**
	         * @private
	         */
_isSeriesHasAllAxesTypeOf:function(seriesModel,axisType){
// FIXME
// 需要series的xAxisIndex和yAxisIndex都首先自动设置上。
// 例如series.type === scatter时。
var is=!0;return eachAxisDim(function(dimNames){var seriesAxisIndex=seriesModel.get(dimNames.axisIndex),axisModel=this.dependentModels[dimNames.axis][seriesAxisIndex];axisModel&&axisModel.get("type")===axisType||(is=!1)},this),is},/**
	         * @public
	         */
getFirstTargetAxisModel:function(){var firstAxisModel;return eachAxisDim(function(dimNames){if(null==firstAxisModel){var indices=this.get(dimNames.axisIndex);indices.length&&(firstAxisModel=this.dependentModels[dimNames.axis][indices[0]])}},this),firstAxisModel},/**
	         * @public
	         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
	         */
eachTargetAxis:function(callback,context){var ecModel=this.ecModel;eachAxisDim(function(dimNames){each(this.get(dimNames.axisIndex),function(axisIndex){callback.call(context,dimNames,axisIndex,this,ecModel)},this)},this)},getAxisProxy:function(dimName,axisIndex){return this._axisProxies[dimName+"_"+axisIndex]},/**
	         * If not specified, set to undefined.
	         *
	         * @public
	         * @param {Object} opt
	         * @param {number} [opt.start]
	         * @param {number} [opt.end]
	         * @param {number} [opt.startValue]
	         * @param {number} [opt.endValue]
	         */
setRawRange:function(opt){each(["start","end","startValue","endValue"],function(name){
// If any of those prop is null/undefined, we should alos set
// them, because only one pair between start/end and
// startValue/endValue can work.
this.option[name]=opt[name]},this)},/**
	         * @public
	         * @return {Array.<number>} [startPercent, endPercent]
	         */
getPercentRange:function(){var axisProxy=this.findRepresentativeAxisProxy();return axisProxy?axisProxy.getDataPercentWindow():void 0},/**
	         * @public
	         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
	         *
	         * @param {string} [axisDimName]
	         * @param {number} [axisIndex]
	         * @return {Array.<number>} [startValue, endValue]
	         */
getValueRange:function(axisDimName,axisIndex){if(null!=axisDimName||null!=axisIndex)return this.getAxisProxy(axisDimName,axisIndex).getDataValueWindow();var axisProxy=this.findRepresentativeAxisProxy();return axisProxy?axisProxy.getDataValueWindow():void 0},/**
	         * @public
	         * @return {module:echarts/component/dataZoom/AxisProxy}
	         */
findRepresentativeAxisProxy:function(){
// Find the first hosted axisProxy
var axisProxies=this._axisProxies;for(var key in axisProxies)if(axisProxies.hasOwnProperty(key)&&axisProxies[key].hostedBy(this))return axisProxies[key];
// If no hosted axis find not hosted axisProxy.
// Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,
// and the option.start or option.end settings are different. The percentRange
// should follow axisProxy.
// (We encounter this problem in toolbox data zoom.)
for(var key in axisProxies)if(axisProxies.hasOwnProperty(key)&&!axisProxies[key].hostedBy(this))return axisProxies[key]}});module.exports=DataZoomModel},/* 289 */
/***/
function(module,exports,__webpack_require__){function calculateDataExtent(axisDim,seriesModels){var dataExtent=[1/0,-(1/0)];return each(seriesModels,function(seriesModel){var seriesData=seriesModel.getData();seriesData&&each(seriesModel.coordDimToDataDim(axisDim),function(dim){var seriesExtent=seriesData.getDataExtent(dim);seriesExtent[0]<dataExtent[0]&&(dataExtent[0]=seriesExtent[0]),seriesExtent[1]>dataExtent[1]&&(dataExtent[1]=seriesExtent[1])})},this),dataExtent}function calculateDataWindow(opt,dataExtent,axisProxy){var axisModel=axisProxy.getAxisModel(),scale=axisModel.axis.scale,percentExtent=[0,100],percentWindow=[opt.start,opt.end],valueWindow=[];
// In percent range is used and axis min/max/scale is set,
// window should be based on min/max/0, but should not be
// based on the extent of filtered data.
// Normalize bound.
return dataExtent=dataExtent.slice(),fixExtendByAxis(dataExtent,axisModel,scale),each(["startValue","endValue"],function(prop){valueWindow.push(null!=opt[prop]?scale.parse(opt[prop]):null)}),each([0,1],function(idx){function round(val){return Math[0===idx?"floor":"ceil"](1e12*val)/1e12}var boundValue=valueWindow[idx],boundPercent=percentWindow[idx];null!=boundPercent||null==boundValue?(null==boundPercent&&(boundPercent=percentExtent[idx]),boundValue=scale.parse(numberUtil.linearMap(boundPercent,percentExtent,dataExtent,!0))):boundPercent=numberUtil.linearMap(boundValue,dataExtent,percentExtent,!0),valueWindow[idx]=round(boundValue),percentWindow[idx]=round(boundPercent)}),{valueWindow:asc(valueWindow),percentWindow:asc(percentWindow)}}function fixExtendByAxis(dataExtent,axisModel,scale){return each(["min","max"],function(minMax,index){var axisMax=axisModel.get(minMax,!0);
// Consider 'dataMin', 'dataMax'
null!=axisMax&&(axisMax+"").toLowerCase()!=="data"+minMax&&(dataExtent[index]=scale.parse(axisMax))}),axisModel.get("scale",!0)||(dataExtent[0]>0&&(dataExtent[0]=0),dataExtent[1]<0&&(dataExtent[1]=0)),dataExtent}function setAxisModel(axisProxy,isRestore){var axisModel=axisProxy.getAxisModel(),percentWindow=axisProxy._percentWindow,valueWindow=axisProxy._valueWindow;if(percentWindow){var isFull=isRestore||0===percentWindow[0]&&100===percentWindow[1],precision=!isRestore&&numberUtil.getPixelPrecision(valueWindow,[0,500]),invalidPrecision=!(isRestore||20>precision&&precision>=0),useOrigin=isRestore||isFull||invalidPrecision;axisModel.setRange&&axisModel.setRange(useOrigin?null:+valueWindow[0].toFixed(precision),useOrigin?null:+valueWindow[1].toFixed(precision))}}/**
	 * @file Axis operator
	 */
var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),each=zrUtil.each,asc=numberUtil.asc,AxisProxy=function(dimName,axisIndex,dataZoomModel,ecModel){/**
	         * @private
	         * @type {string}
	         */
this._dimName=dimName,/**
	         * @private
	         */
this._axisIndex=axisIndex,/**
	         * @private
	         * @type {Array.<number>}
	         */
this._valueWindow,/**
	         * @private
	         * @type {Array.<number>}
	         */
this._percentWindow,/**
	         * @private
	         * @type {Array.<number>}
	         */
this._dataExtent,/**
	         * @readOnly
	         * @type {module: echarts/model/Global}
	         */
this.ecModel=ecModel,/**
	         * @private
	         * @type {module: echarts/component/dataZoom/DataZoomModel}
	         */
this._dataZoomModel=dataZoomModel};AxisProxy.prototype={constructor:AxisProxy,/**
	         * Whether the axisProxy is hosted by dataZoomModel.
	         *
	         * @public
	         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
	         * @return {boolean}
	         */
hostedBy:function(dataZoomModel){return this._dataZoomModel===dataZoomModel},/**
	         * @return {Array.<number>}
	         */
getDataExtent:function(){return this._dataExtent.slice()},/**
	         * @return {Array.<number>}
	         */
getDataValueWindow:function(){return this._valueWindow.slice()},/**
	         * @return {Array.<number>}
	         */
getDataPercentWindow:function(){return this._percentWindow.slice()},/**
	         * @public
	         * @param {number} axisIndex
	         * @return {Array} seriesModels
	         */
getTargetSeriesModels:function(){var seriesModels=[];return this.ecModel.eachSeries(function(seriesModel){this._axisIndex===seriesModel.get(this._dimName+"AxisIndex")&&seriesModels.push(seriesModel)},this),seriesModels},getAxisModel:function(){return this.ecModel.getComponent(this._dimName+"Axis",this._axisIndex)},getOtherAxisModel:function(){var otherAxisDim,coordSysIndexName,axisDim=this._dimName,ecModel=this.ecModel,axisModel=this.getAxisModel(),isCartesian="x"===axisDim||"y"===axisDim;isCartesian?(coordSysIndexName="gridIndex",otherAxisDim="x"===axisDim?"y":"x"):(coordSysIndexName="polarIndex",otherAxisDim="angle"===axisDim?"radius":"angle");var foundOtherAxisModel;return ecModel.eachComponent(otherAxisDim+"Axis",function(otherAxisModel){(otherAxisModel.get(coordSysIndexName)||0)===(axisModel.get(coordSysIndexName)||0)&&(foundOtherAxisModel=otherAxisModel)}),foundOtherAxisModel},/**
	         * Notice: reset should not be called before series.restoreData() called,
	         * so it is recommanded to be called in "process stage" but not "model init
	         * stage".
	         *
	         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
	         */
reset:function(dataZoomModel){if(dataZoomModel===this._dataZoomModel){
// Culculate data window and data extent, and record them.
var dataExtent=this._dataExtent=calculateDataExtent(this._dimName,this.getTargetSeriesModels()),dataWindow=calculateDataWindow(dataZoomModel.option,dataExtent,this);this._valueWindow=dataWindow.valueWindow,this._percentWindow=dataWindow.percentWindow,
// Update axis setting then.
setAxisModel(this)}},/**
	         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
	         */
restore:function(dataZoomModel){dataZoomModel===this._dataZoomModel&&(this._valueWindow=this._percentWindow=null,setAxisModel(this,!0))},/**
	         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
	         */
filterData:function(dataZoomModel){function isInWindow(value){return value>=valueWindow[0]&&value<=valueWindow[1]}if(dataZoomModel===this._dataZoomModel){var axisDim=this._dimName,seriesModels=this.getTargetSeriesModels(),filterMode=dataZoomModel.get("filterMode"),valueWindow=this._valueWindow,otherAxisModel=this.getOtherAxisModel();dataZoomModel.get("$fromToolbox")&&otherAxisModel&&"category"===otherAxisModel.get("type")&&(filterMode="empty"),
// Process series data
each(seriesModels,function(seriesModel){var seriesData=seriesModel.getData();seriesData&&each(seriesModel.coordDimToDataDim(axisDim),function(dim){"empty"===filterMode?seriesModel.setData(seriesData.map(dim,function(value){return isInWindow(value)?value:NaN})):seriesData.filterSelf(dim,isInWindow)})})}}},module.exports=AxisProxy},/* 290 */
/***/
function(module,exports,__webpack_require__){var ComponentView=__webpack_require__(28);module.exports=ComponentView.extend({type:"dataZoom",render:function(dataZoomModel,ecModel,api,payload){this.dataZoomModel=dataZoomModel,this.ecModel=ecModel,this.api=api},/**
	         * Find the first target coordinate system.
	         *
	         * @protected
	         * @return {Object} {
	         *                   cartesians: [
	         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
	         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
	         *                       ...
	         *                   ],  // cartesians must not be null/undefined.
	         *                   polars: [
	         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
	         *                       ...
	         *                   ],  // polars must not be null/undefined.
	         *                   axisModels: [axis0, axis1, axis2, axis3, axis4]
	         *                       // axisModels must not be null/undefined.
	         *                  }
	         */
getTargetInfo:function(){function save(coordModel,axisModel,store,coordIndex){for(var item,i=0;i<store.length;i++)if(store[i].model===coordModel){item=store[i];break}item||store.push(item={model:coordModel,axisModels:[],coordIndex:coordIndex}),item.axisModels.push(axisModel)}var dataZoomModel=this.dataZoomModel,ecModel=this.ecModel,cartesians=[],polars=[],axisModels=[];return dataZoomModel.eachTargetAxis(function(dimNames,axisIndex){var axisModel=ecModel.getComponent(dimNames.axis,axisIndex);if(axisModel){axisModels.push(axisModel);var gridIndex=axisModel.get("gridIndex"),polarIndex=axisModel.get("polarIndex");if(null!=gridIndex){var coordModel=ecModel.getComponent("grid",gridIndex);save(coordModel,axisModel,cartesians,gridIndex)}else if(null!=polarIndex){var coordModel=ecModel.getComponent("polar",polarIndex);save(coordModel,axisModel,polars,polarIndex)}}},this),{cartesians:cartesians,polars:polars,axisModels:axisModels}}})},/* 291 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data zoom model
	 */
var DataZoomModel=__webpack_require__(288),SliderZoomModel=(__webpack_require__(21),__webpack_require__(3),DataZoomModel.extend({type:"dataZoom.slider",layoutMode:"box",/**
	         * @protected
	         */
defaultOption:{show:!0,
// ph => placeholder. Using placehoder here because
// deault value can only be drived in view stage.
right:"ph",// Default align to grid rect.
top:"ph",// Default align to grid rect.
width:"ph",// Default align to grid rect.
height:"ph",// Default align to grid rect.
left:null,// Default align to grid rect.
bottom:null,// Default align to grid rect.
backgroundColor:"rgba(47,69,84,0)",// Background of slider zoom component.
dataBackgroundColor:"#ddd",// Background of data shadow.
fillerColor:"rgba(47,69,84,0.15)",// Color of selected area.
handleColor:"rgba(148,164,165,0.95)",// Color of handle.
handleSize:10,labelPrecision:null,labelFormatter:null,showDetail:!0,showDataShadow:"auto",// Default auto decision.
realtime:!0,zoomLock:!1,// Whether disable zoom.
textStyle:{color:"#333"}},/**
	         * @override
	         */
mergeOption:function(option){SliderZoomModel.superApply(this,"mergeOption",arguments)}}));module.exports=SliderZoomModel},/* 292 */
/***/
function(module,exports,__webpack_require__){function getOtherDim(thisDim){
// FIXME
// 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
return"x"===thisDim?"y":"x"}var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),throttle=__webpack_require__(293),DataZoomView=__webpack_require__(290),Rect=graphic.Rect,numberUtil=__webpack_require__(7),linearMap=numberUtil.linearMap,layout=__webpack_require__(21),sliderMove=__webpack_require__(294),asc=numberUtil.asc,bind=zrUtil.bind,mathRound=Math.round,mathMax=Math.max,each=zrUtil.each,DEFAULT_LOCATION_EDGE_GAP=7,DEFAULT_FRAME_BORDER_WIDTH=1,DEFAULT_FILLER_SIZE=30,HORIZONTAL="horizontal",VERTICAL="vertical",LABEL_GAP=5,SHOW_DATA_SHADOW_SERIES_TYPE=["line","bar","candlestick","scatter"],SliderZoomView=DataZoomView.extend({type:"dataZoom.slider",init:function(ecModel,api){/**
	             * @private
	             * @type {Object}
	             */
this._displayables={},/**
	             * @private
	             * @type {string}
	             */
this._orient,/**
	             * [0, 100]
	             * @private
	             */
this._range,/**
	             * [coord of the first handle, coord of the second handle]
	             * @private
	             */
this._handleEnds,/**
	             * [length, thick]
	             * @private
	             * @type {Array.<number>}
	             */
this._size,/**
	             * @private
	             * @type {number}
	             */
this._halfHandleSize,/**
	             * @private
	             */
this._location,/**
	             * @private
	             */
this._dragging,/**
	             * @private
	             */
this._dataShadowInfo,this.api=api},/**
	         * @override
	         */
render:function(dataZoomModel,ecModel,api,payload){
// Notice: this._resetInterval() should not be executed when payload.type
// is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
// or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,
return SliderZoomView.superApply(this,"render",arguments),throttle.createOrUpdate(this,"_dispatchZoomAction",this.dataZoomModel.get("throttle"),"fixRate"),this._orient=dataZoomModel.get("orient"),this._halfHandleSize=mathRound(dataZoomModel.get("handleSize")/2),this.dataZoomModel.get("show")===!1?void this.group.removeAll():(payload&&"dataZoom"===payload.type&&payload.from===this.uid||this._buildView(),void this._updateView())},/**
	         * @override
	         */
remove:function(){SliderZoomView.superApply(this,"remove",arguments),throttle.clear(this,"_dispatchZoomAction")},/**
	         * @override
	         */
dispose:function(){SliderZoomView.superApply(this,"dispose",arguments),throttle.clear(this,"_dispatchZoomAction")},_buildView:function(){var thisGroup=this.group;thisGroup.removeAll(),this._resetLocation(),this._resetInterval();var barGroup=this._displayables.barGroup=new graphic.Group;this._renderBackground(),this._renderDataShadow(),this._renderHandle(),thisGroup.add(barGroup),this._positionGroup()},/**
	         * @private
	         */
_resetLocation:function(){var dataZoomModel=this.dataZoomModel,api=this.api,coordRect=this._findCoordRect(),ecSize={width:api.getWidth(),height:api.getHeight()},positionInfo=this._orient===HORIZONTAL?{
// Why using 'right', because right should be used in vertical,
// and it is better to be consistent for dealing with position param merge.
right:ecSize.width-coordRect.x-coordRect.width,top:ecSize.height-DEFAULT_FILLER_SIZE-DEFAULT_LOCATION_EDGE_GAP,width:coordRect.width,height:DEFAULT_FILLER_SIZE}:{// vertical
right:DEFAULT_LOCATION_EDGE_GAP,top:coordRect.y,width:DEFAULT_FILLER_SIZE,height:coordRect.height},layoutParams=layout.getLayoutParams(dataZoomModel.option);
// Replace the placeholder value.
zrUtil.each(["right","top","width","height"],function(name){"ph"===layoutParams[name]&&(layoutParams[name]=positionInfo[name])});var layoutRect=layout.getLayoutRect(layoutParams,ecSize,dataZoomModel.padding);this._location={x:layoutRect.x,y:layoutRect.y},this._size=[layoutRect.width,layoutRect.height],this._orient===VERTICAL&&this._size.reverse()},/**
	         * @private
	         */
_positionGroup:function(){var thisGroup=this.group,location=this._location,orient=this._orient,targetAxisModel=this.dataZoomModel.getFirstTargetAxisModel(),inverse=targetAxisModel&&targetAxisModel.get("inverse"),barGroup=this._displayables.barGroup,otherAxisInverse=(this._dataShadowInfo||{}).otherAxisInverse;
// Transform barGroup.
barGroup.attr(orient!==HORIZONTAL||inverse?orient===HORIZONTAL&&inverse?{scale:otherAxisInverse?[-1,1]:[-1,-1]}:orient!==VERTICAL||inverse?{scale:otherAxisInverse?[-1,-1]:[-1,1],rotation:Math.PI/2}:{scale:otherAxisInverse?[1,-1]:[1,1],rotation:Math.PI/2}:{scale:otherAxisInverse?[1,1]:[1,-1]});
// Position barGroup
var rect=thisGroup.getBoundingRect([barGroup]);thisGroup.position[0]=location.x-rect.x,thisGroup.position[1]=location.y-rect.y},/**
	         * @private
	         */
_getViewExtent:function(){
// View total length.
var halfHandleSize=this._halfHandleSize,totalLength=mathMax(this._size[0],4*halfHandleSize),extent=[halfHandleSize,totalLength-halfHandleSize];return extent},_renderBackground:function(){var dataZoomModel=this.dataZoomModel,size=this._size;this._displayables.barGroup.add(new Rect({silent:!0,shape:{x:0,y:0,width:size[0],height:size[1]},style:{fill:dataZoomModel.get("backgroundColor")}}))},_renderDataShadow:function(){var info=this._dataShadowInfo=this._prepareDataShadowInfo();if(info){var size=this._size,seriesModel=info.series,data=seriesModel.getRawData(),otherDim=seriesModel.getShadowDim?seriesModel.getShadowDim():info.otherDim,otherDataExtent=data.getDataExtent(otherDim),otherOffset=.3*(otherDataExtent[1]-otherDataExtent[0]);otherDataExtent=[otherDataExtent[0]-otherOffset,otherDataExtent[1]+otherOffset];var otherShadowExtent=[0,size[1]],thisShadowExtent=[0,size[0]],points=[[size[0],0],[0,0]],step=thisShadowExtent[1]/(data.count()-1),thisCoord=0,stride=Math.round(data.count()/size[0]);data.each([otherDim],function(value,index){if(stride>0&&index%stride)return void(thisCoord+=step);
// FIXME
// 应该使用统计的空判断？还是在list里进行空判断？
var otherCoord=null==value||isNaN(value)||""===value?null:linearMap(value,otherDataExtent,otherShadowExtent,!0);null!=otherCoord&&points.push([thisCoord,otherCoord]),thisCoord+=step}),this._displayables.barGroup.add(new graphic.Polyline({shape:{points:points},style:{fill:this.dataZoomModel.get("dataBackgroundColor"),lineWidth:0},silent:!0,z2:-20}))}},_prepareDataShadowInfo:function(){var dataZoomModel=this.dataZoomModel,showDataShadow=dataZoomModel.get("showDataShadow");if(showDataShadow!==!1){
// Find a representative series.
var result,ecModel=this.ecModel;return dataZoomModel.eachTargetAxis(function(dimNames,axisIndex){var seriesModels=dataZoomModel.getAxisProxy(dimNames.name,axisIndex).getTargetSeriesModels();zrUtil.each(seriesModels,function(seriesModel){if(!(result||showDataShadow!==!0&&zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE,seriesModel.get("type"))<0)){var otherDim=getOtherDim(dimNames.name),thisAxis=ecModel.getComponent(dimNames.axis,axisIndex).axis;result={thisAxis:thisAxis,series:seriesModel,thisDim:dimNames.name,otherDim:otherDim,otherAxisInverse:seriesModel.coordinateSystem.getOtherAxis(thisAxis).inverse}}},this)},this),result}},_renderHandle:function(){var displaybles=this._displayables,handles=displaybles.handles=[],handleLabels=displaybles.handleLabels=[],barGroup=this._displayables.barGroup,size=this._size;barGroup.add(displaybles.filler=new Rect({draggable:!0,cursor:"move",drift:bind(this._onDragMove,this,"all"),ondragend:bind(this._onDragEnd,this),onmouseover:bind(this._showDataInfo,this,!0),onmouseout:bind(this._showDataInfo,this,!1),style:{fill:this.dataZoomModel.get("fillerColor"),
// text: ':::',
textPosition:"inside"}})),
// Frame border.
barGroup.add(new Rect(graphic.subPixelOptimizeRect({silent:!0,shape:{x:0,y:0,width:size[0],height:size[1]},style:{stroke:this.dataZoomModel.get("dataBackgroundColor"),lineWidth:DEFAULT_FRAME_BORDER_WIDTH,fill:"rgba(0,0,0,0)"}}))),each([0,1],function(handleIndex){barGroup.add(handles[handleIndex]=new Rect({style:{fill:this.dataZoomModel.get("handleColor")},cursor:"move",draggable:!0,drift:bind(this._onDragMove,this,handleIndex),ondragend:bind(this._onDragEnd,this),onmouseover:bind(this._showDataInfo,this,!0),onmouseout:bind(this._showDataInfo,this,!1)}));var textStyleModel=this.dataZoomModel.textStyleModel;this.group.add(handleLabels[handleIndex]=new graphic.Text({silent:!0,invisible:!0,style:{x:0,y:0,text:"",textVerticalAlign:"middle",textAlign:"center",fill:textStyleModel.getTextColor(),textFont:textStyleModel.getFont()}}))},this)},/**
	         * @private
	         */
_resetInterval:function(){var range=this._range=this.dataZoomModel.getPercentRange(),viewExtent=this._getViewExtent();this._handleEnds=[linearMap(range[0],[0,100],viewExtent,!0),linearMap(range[1],[0,100],viewExtent,!0)]},/**
	         * @private
	         * @param {(number|string)} handleIndex 0 or 1 or 'all'
	         * @param {number} dx
	         * @param {number} dy
	         */
_updateInterval:function(handleIndex,delta){var handleEnds=this._handleEnds,viewExtend=this._getViewExtent();sliderMove(delta,handleEnds,viewExtend,"all"===handleIndex||this.dataZoomModel.get("zoomLock")?"rigid":"cross",handleIndex),this._range=asc([linearMap(handleEnds[0],viewExtend,[0,100],!0),linearMap(handleEnds[1],viewExtend,[0,100],!0)])},/**
	         * @private
	         */
_updateView:function(){var displaybles=this._displayables,handleEnds=this._handleEnds,handleInterval=asc(handleEnds.slice()),size=this._size,halfHandleSize=this._halfHandleSize;each([0,1],function(handleIndex){
// Handles
var handle=displaybles.handles[handleIndex];handle.setShape({x:handleEnds[handleIndex]-halfHandleSize,y:-1,width:2*halfHandleSize,height:size[1]+2,r:1})},this),
// Filler
displaybles.filler.setShape({x:handleInterval[0],y:0,width:handleInterval[1]-handleInterval[0],height:this._size[1]}),this._updateDataInfo()},/**
	         * @private
	         */
_updateDataInfo:function(){function setLabel(handleIndex){
// Label
// Text should not transform by barGroup.
var barTransform=graphic.getTransform(displaybles.handles[handleIndex],this.group),direction=graphic.transformDirection(0===handleIndex?"right":"left",barTransform),offset=this._halfHandleSize+LABEL_GAP,textPoint=graphic.applyTransform([orderedHandleEnds[handleIndex]+(0===handleIndex?-offset:offset),this._size[1]/2],barTransform);handleLabels[handleIndex].setStyle({x:textPoint[0],y:textPoint[1],textVerticalAlign:orient===HORIZONTAL?"middle":direction,textAlign:orient===HORIZONTAL?direction:"center",text:labelTexts[handleIndex]})}var dataZoomModel=this.dataZoomModel,displaybles=this._displayables,handleLabels=displaybles.handleLabels,orient=this._orient,labelTexts=["",""];
// FIXME
// date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）
if(dataZoomModel.get("showDetail")){var dataInterval,axis;dataZoomModel.eachTargetAxis(function(dimNames,axisIndex){
// Using dataInterval of the first axis.
dataInterval||(dataInterval=dataZoomModel.getAxisProxy(dimNames.name,axisIndex).getDataValueWindow(),axis=this.ecModel.getComponent(dimNames.axis,axisIndex).axis)},this),dataInterval&&(labelTexts=[this._formatLabel(dataInterval[0],axis),this._formatLabel(dataInterval[1],axis)])}var orderedHandleEnds=asc(this._handleEnds.slice());setLabel.call(this,0),setLabel.call(this,1)},/**
	         * @private
	         */
_formatLabel:function(value,axis){var dataZoomModel=this.dataZoomModel,labelFormatter=dataZoomModel.get("labelFormatter");if(zrUtil.isFunction(labelFormatter))return labelFormatter(value);var labelPrecision=dataZoomModel.get("labelPrecision");return null!=labelPrecision&&"auto"!==labelPrecision||(labelPrecision=axis.getPixelPrecision()),value=null==value&&isNaN(value)?"":"category"===axis.type||"time"===axis.type?axis.scale.getLabel(Math.round(value)):value.toFixed(Math.min(labelPrecision,20)),zrUtil.isString(labelFormatter)&&(value=labelFormatter.replace("{value}",value)),value},/**
	         * @private
	         * @param {boolean} showOrHide true: show, false: hide
	         */
_showDataInfo:function(showOrHide){
// Always show when drgging.
showOrHide=this._dragging||showOrHide;var handleLabels=this._displayables.handleLabels;handleLabels[0].attr("invisible",!showOrHide),handleLabels[1].attr("invisible",!showOrHide)},_onDragMove:function(handleIndex,dx,dy){this._dragging=!0;
// Transform dx, dy to bar coordination.
var vertex=this._applyBarTransform([dx,dy],!0);this._updateInterval(handleIndex,vertex[0]),this._updateView(),this.dataZoomModel.get("realtime")&&this._dispatchZoomAction()},_onDragEnd:function(){this._dragging=!1,this._showDataInfo(!1),this._dispatchZoomAction()},/**
	         * This action will be throttled.
	         * @private
	         */
_dispatchZoomAction:function(){var range=this._range;this.api.dispatchAction({type:"dataZoom",from:this.uid,dataZoomId:this.dataZoomModel.id,start:range[0],end:range[1]})},/**
	         * @private
	         */
_applyBarTransform:function(vertex,inverse){var barTransform=this._displayables.barGroup.getLocalTransform();return graphic.applyTransform(vertex,barTransform,inverse)},/**
	         * @private
	         */
_findCoordRect:function(){
// Find the grid coresponding to the first axis referred by dataZoom.
var rect,targetInfo=this.getTargetInfo();if(targetInfo.cartesians.length)rect=targetInfo.cartesians[0].model.coordinateSystem.getRect();else{// Polar
// FIXME
// 暂时随便写的
var width=this.api.getWidth(),height=this.api.getHeight();rect={x:.2*width,y:.2*height,width:.6*width,height:.6*height}}return rect}});module.exports=SliderZoomView},/* 293 */
/***/
function(module,exports){var lib={},ORIGIN_METHOD="\x00__throttleOriginMethod",RATE="\x00__throttleRate";/**
	     * 频率控制 返回函数连续调用时，fn 执行频率限定为每多少时间执行一次
	     * 例如常见效果：
	     * notifyWhenChangesStop
	     *      频繁调用时，只保证最后一次执行
	     *      配成：trailing：true；debounce：true 即可
	     * notifyAtFixRate
	     *      频繁调用时，按规律心跳执行
	     *      配成：trailing：true；debounce：false 即可
	     * 注意：
	     *     根据model更新view的时候，可以使用throttle，
	     *     但是根据view更新model的时候，避免使用这种延迟更新的方式。
	     *     因为这可能导致model和server同步出现问题。
	     *
	     * @public
	     * @param {(Function|Array.<Function>)} fn 需要调用的函数
	     *                                         如果fn为array，则表示可以对多个函数进行throttle。
	     *                                         他们共享同一个timer。
	     * @param {number} delay 延迟时间，单位毫秒
	     * @param {bool} trailing 是否保证最后一次触发的执行
	     *                        true：表示保证最后一次调用会触发执行。
	     *                        但任何调用后不可能立即执行，总会delay。
	     *                        false：表示不保证最后一次调用会触发执行。
	     *                        但只要间隔大于delay，调用就会立即执行。
	     * @param {bool} debounce 节流
	     *                        true：表示：频繁调用（间隔小于delay）时，根本不执行
	     *                        false：表示：频繁调用（间隔小于delay）时，按规律心跳执行
	     * @return {(Function|Array.<Function>)} 实际调用函数。
	     *                                       当输入的fn为array时，返回值也为array。
	     *                                       每项是Function。
	     */
lib.throttle=function(fn,delay,trailing,debounce){function createCallback(index){function exec(){lastExec=(new Date).getTime(),timer=null,(isSingle?fn:fn[index]).apply(scope,args||[])}var cb=function(){currCall=(new Date).getTime(),scope=this,args=arguments,diff=currCall-(debounce?lastCall:lastExec)-delay,clearTimeout(timer),debounce?trailing?timer=setTimeout(exec,delay):diff>=0&&exec():diff>=0?exec():trailing&&(timer=setTimeout(exec,-diff)),lastCall=currCall};/**
	             * Clear throttle.
	             * @public
	             */
return cb.clear=function(){timer&&(clearTimeout(timer),timer=null)},cb}var diff,scope,args,currCall=(new Date).getTime(),lastCall=0,lastExec=0,timer=null,isSingle="function"==typeof fn;if(delay=delay||0,isSingle)return createCallback();for(var ret=[],i=0;i<fn.length;i++)ret[i]=createCallback(i);return ret},/**
	     * 按一定频率执行，最后一次调用总归会执行
	     *
	     * @public
	     */
lib.fixRate=function(fn,delay){return null!=delay?lib.throttle(fn,delay,!0,!1):fn},/**
	     * 直到不频繁调用了才会执行，最后一次调用总归会执行
	     *
	     * @public
	     */
lib.debounce=function(fn,delay){return null!=delay?lib.throttle(fn,delay,!0,!0):fn},/**
	     * Create throttle method or update throttle rate.
	     *
	     * @example
	     * ComponentView.prototype.render = function () {
	     *     ...
	     *     throttle.createOrUpdate(
	     *         this,
	     *         '_dispatchAction',
	     *         this.model.get('throttle'),
	     *         'fixRate'
	     *     );
	     * };
	     * ComponentView.prototype.remove = function () {
	     *     throttle.clear(this, '_dispatchAction');
	     * };
	     * ComponentView.prototype.dispose = function () {
	     *     throttle.clear(this, '_dispatchAction');
	     * };
	     *
	     * @public
	     * @param {Object} obj
	     * @param {string} fnAttr
	     * @param {number} rate
	     * @param {string} throttleType 'fixRate' or 'debounce'
	     */
lib.createOrUpdate=function(obj,fnAttr,rate,throttleType){var fn=obj[fnAttr];if(fn&&null!=rate&&throttleType){var originFn=fn[ORIGIN_METHOD]||fn,lastRate=fn[RATE];lastRate!==rate&&(fn=obj[fnAttr]=lib[throttleType](originFn,rate),fn[ORIGIN_METHOD]=originFn,fn[RATE]=rate)}},/**
	     * Clear throttle. Example see throttle.createOrUpdate.
	     *
	     * @public
	     * @param {Object} obj
	     * @param {string} fnAttr
	     */
lib.clear=function(obj,fnAttr){var fn=obj[fnAttr];fn&&fn[ORIGIN_METHOD]&&(obj[fnAttr]=fn[ORIGIN_METHOD])},module.exports=lib},/* 294 */
/***/
function(module,exports){/**
	     * Calculate slider move result.
	     *
	     * @param {number} delta Move length.
	     * @param {Array.<number>} handleEnds handleEnds[0] and be bigger then handleEnds[1].
	     *                                    handleEnds will be modified in this method.
	     * @param {Array.<number>} extent handleEnds is restricted by extent.
	     *                                extent[0] should less or equals than extent[1].
	     * @param {string} mode 'rigid': Math.abs(handleEnds[0] - handleEnds[1]) remain unchanged,
	     *                      'cross' handleEnds[0] can be bigger then handleEnds[1],
	     *                      'push' handleEnds[0] can not be bigger then handleEnds[1],
	     *                              when they touch, one push other.
	     * @param {number} handleIndex If mode is 'rigid', handleIndex is not required.
	     * @param {Array.<number>} The input handleEnds.
	     */
module.exports=function(delta,handleEnds,extent,mode,handleIndex){function getRealDelta(delta,handleEnds,extent){var handleMinMax=handleEnds.length?handleEnds.slice():[handleEnds,handleEnds];return handleEnds[0]>handleEnds[1]&&handleMinMax.reverse(),0>delta&&handleMinMax[0]+delta<extent[0]&&(delta=extent[0]-handleMinMax[0]),delta>0&&handleMinMax[1]+delta>extent[1]&&(delta=extent[1]-handleMinMax[1]),delta}return delta?("rigid"===mode?(delta=getRealDelta(delta,handleEnds,extent),handleEnds[0]+=delta,handleEnds[1]+=delta):(delta=getRealDelta(delta,handleEnds[handleIndex],extent),handleEnds[handleIndex]+=delta,"push"===mode&&handleEnds[0]>handleEnds[1]&&(handleEnds[1-handleIndex]=handleEnds[handleIndex])),handleEnds):handleEnds}},/* 295 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data zoom model
	 */
module.exports=__webpack_require__(288).extend({type:"dataZoom.inside",/**
	         * @protected
	         */
defaultOption:{zoomLock:!1}})},/* 296 */
/***/
function(module,exports,__webpack_require__){function panCartesian(pixelDeltas,range,controller,coordInfo){range=range.slice();
// Calculate transform by the first axis.
var axisModel=coordInfo.axisModels[0];if(axisModel){var directionInfo=getDirectionInfo(pixelDeltas,axisModel,controller),percentDelta=directionInfo.signal*(range[1]-range[0])*directionInfo.pixel/directionInfo.pixelLength;return sliderMove(percentDelta,range,[0,100],"rigid"),range}}function scaleCartesian(scale,mousePoint,range,controller,coordInfo,dataZoomModel){range=range.slice();
// Calculate transform by the first axis.
var axisModel=coordInfo.axisModels[0];if(axisModel){var directionInfo=getDirectionInfo(mousePoint,axisModel,controller),mouse=directionInfo.pixel-directionInfo.pixelStart,percentPoint=mouse/directionInfo.pixelLength*(range[1]-range[0])+range[0];return scale=Math.max(scale,0),range[0]=(range[0]-percentPoint)*scale+percentPoint,range[1]=(range[1]-percentPoint)*scale+percentPoint,fixRange(range)}}function getDirectionInfo(xy,axisModel,controller){var axis=axisModel.axis,rect=controller.rect,ret={};// axis.dim === 'y'
return"x"===axis.dim?(ret.pixel=xy[0],ret.pixelLength=rect.width,ret.pixelStart=rect.x,ret.signal=axis.inverse?1:-1):(ret.pixel=xy[1],ret.pixelLength=rect.height,ret.pixelStart=rect.y,ret.signal=axis.inverse?-1:1),ret}function fixRange(range){
// Clamp, using !(<= or >=) to handle NaN.
// jshint ignore:start
var bound=[0,100];
// jshint ignore:end
return!(range[0]<=bound[1])&&(range[0]=bound[1]),!(range[1]<=bound[1])&&(range[1]=bound[1]),!(range[0]>=bound[0])&&(range[0]=bound[0]),!(range[1]>=bound[0])&&(range[1]=bound[0]),range}var DataZoomView=__webpack_require__(290),zrUtil=__webpack_require__(3),sliderMove=__webpack_require__(294),roams=__webpack_require__(297),bind=zrUtil.bind,InsideZoomView=DataZoomView.extend({type:"dataZoom.inside",/**
	         * @override
	         */
init:function(ecModel,api){/**
	             * 'throttle' is used in this.dispatchAction, so we save range
	             * to avoid missing some 'pan' info.
	             * @private
	             * @type {Array.<number>}
	             */
this._range},/**
	         * @override
	         */
render:function(dataZoomModel,ecModel,api,payload){InsideZoomView.superApply(this,"render",arguments),
// Notice: origin this._range should be maintained, and should not be re-fetched
// from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'
// info will be missed because of 'throttle' of this.dispatchAction.
roams.shouldRecordRange(payload,dataZoomModel.id)&&(this._range=dataZoomModel.getPercentRange());
// Reset controllers.
var coordInfoList=this.getTargetInfo().cartesians,allCoordIds=zrUtil.map(coordInfoList,function(coordInfo){return roams.generateCoordId(coordInfo.model)});zrUtil.each(coordInfoList,function(coordInfo){var coordModel=coordInfo.model;roams.register(api,{coordId:roams.generateCoordId(coordModel),allCoordIds:allCoordIds,coordinateSystem:coordModel.coordinateSystem,dataZoomId:dataZoomModel.id,throttleRage:dataZoomModel.get("throttle",!0),panGetRange:bind(this._onPan,this,coordInfo),zoomGetRange:bind(this._onZoom,this,coordInfo)})},this)},/**
	         * @override
	         */
remove:function(){roams.unregister(this.api,this.dataZoomModel.id),InsideZoomView.superApply(this,"remove",arguments),this._range=null},/**
	         * @override
	         */
dispose:function(){roams.unregister(this.api,this.dataZoomModel.id),InsideZoomView.superApply(this,"dispose",arguments),this._range=null},/**
	         * @private
	         */
_onPan:function(coordInfo,controller,dx,dy){return this._range=panCartesian([dx,dy],this._range,controller,coordInfo)},/**
	         * @private
	         */
_onZoom:function(coordInfo,controller,scale,mouseX,mouseY){var dataZoomModel=this.dataZoomModel;return dataZoomModel.option.zoomLock?this._range:this._range=scaleCartesian(1/scale,[mouseX,mouseY],this._range,controller,coordInfo,dataZoomModel)}});module.exports=InsideZoomView},/* 297 */
/***/
function(module,exports,__webpack_require__){/**
	     * Key: coordId, value: {dataZoomInfos: [], count, controller}
	     * @type {Array.<Object>}
	     */
function giveStore(api){
// Mount store on zrender instance, so that we do not
// need to worry about dispose.
var zr=api.getZr();return zr[ATTR]||(zr[ATTR]={})}function createController(api,dataZoomInfo,newRecord){var controller=new RoamController(api.getZr());return controller.enable(),controller.on("pan",curry(onPan,newRecord)),controller.on("zoom",curry(onZoom,newRecord)),controller}function cleanStore(store){zrUtil.each(store,function(record,coordId){record.count||(record.controller.off("pan").off("zoom"),delete store[coordId])})}function onPan(record,dx,dy){wrapAndDispatch(record,function(info){return info.panGetRange(record.controller,dx,dy)})}function onZoom(record,scale,mouseX,mouseY){wrapAndDispatch(record,function(info){return info.zoomGetRange(record.controller,scale,mouseX,mouseY)})}function wrapAndDispatch(record,getRange){var batch=[];zrUtil.each(record.dataZoomInfos,function(info){var range=getRange(info);range&&batch.push({dataZoomId:info.dataZoomId,start:range[0],end:range[1]})}),record.dispatchAction(batch)}/**
	     * This action will be throttled.
	     */
function dispatchAction(api,batch){api.dispatchAction({type:"dataZoom",batch:batch})}/**
	 * @file Roam controller manager.
	 */
// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.
var zrUtil=__webpack_require__(3),RoamController=__webpack_require__(159),throttle=__webpack_require__(293),curry=zrUtil.curry,ATTR="\x00_ec_dataZoom_roams",roams={/**
	         * @public
	         * @param {module:echarts/ExtensionAPI} api
	         * @param {Object} dataZoomInfo
	         * @param {string} dataZoomInfo.coordId
	         * @param {Object} dataZoomInfo.coordinateSystem
	         * @param {Array.<string>} dataZoomInfo.allCoordIds
	         * @param {string} dataZoomInfo.dataZoomId
	         * @param {number} dataZoomInfo.throttleRate
	         * @param {Function} dataZoomInfo.panGetRange
	         * @param {Function} dataZoomInfo.zoomGetRange
	         */
register:function(api,dataZoomInfo){var store=giveStore(api),theDataZoomId=dataZoomInfo.dataZoomId,theCoordId=dataZoomInfo.coordId;
// Do clean when a dataZoom changes its target coordnate system.
zrUtil.each(store,function(record,coordId){var dataZoomInfos=record.dataZoomInfos;dataZoomInfos[theDataZoomId]&&zrUtil.indexOf(dataZoomInfo.allCoordIds,theCoordId)<0&&(delete dataZoomInfos[theDataZoomId],record.count--)}),cleanStore(store);var record=store[theCoordId];
// Create if needed.
record||(record=store[theCoordId]={coordId:theCoordId,dataZoomInfos:{},count:0},record.controller=createController(api,dataZoomInfo,record),record.dispatchAction=zrUtil.curry(dispatchAction,api)),
// Consider resize, area should be always updated.
record.controller.rect=dataZoomInfo.coordinateSystem.getRect().clone(),
// Update throttle.
throttle.createOrUpdate(record,"dispatchAction",dataZoomInfo.throttleRate,"fixRate"),
// Update reference of dataZoom.
!record.dataZoomInfos[theDataZoomId]&&record.count++,record.dataZoomInfos[theDataZoomId]=dataZoomInfo},/**
	         * @public
	         * @param {module:echarts/ExtensionAPI} api
	         * @param {string} dataZoomId
	         */
unregister:function(api,dataZoomId){var store=giveStore(api);zrUtil.each(store,function(record){var dataZoomInfos=record.dataZoomInfos;dataZoomInfos[dataZoomId]&&(delete dataZoomInfos[dataZoomId],record.count--)}),cleanStore(store)},/**
	         * @public
	         */
shouldRecordRange:function(payload,dataZoomId){if(payload&&"dataZoom"===payload.type&&payload.batch)for(var i=0,len=payload.batch.length;len>i;i++)if(payload.batch[i].dataZoomId===dataZoomId)return!1;return!0},/**
	         * @public
	         */
generateCoordId:function(coordModel){return coordModel.type+"\x00_"+coordModel.id}};module.exports=roams},/* 298 */
/***/
function(module,exports,__webpack_require__){function resetSingleAxis(dimNames,axisIndex,dataZoomModel){dataZoomModel.getAxisProxy(dimNames.name,axisIndex).reset(dataZoomModel)}function filterSingleAxis(dimNames,axisIndex,dataZoomModel){dataZoomModel.getAxisProxy(dimNames.name,axisIndex).filterData(dataZoomModel)}/**
	 * @file Data zoom processor
	 */
var echarts=__webpack_require__(1);echarts.registerProcessor("filter",function(ecModel,api){ecModel.eachComponent("dataZoom",function(dataZoomModel){
// We calculate window and reset axis here but not in model
// init stage and not after action dispatch handler, because
// reset should be called after seriesData.restoreData.
dataZoomModel.eachTargetAxis(resetSingleAxis),
// Caution: data zoom filtering is order sensitive when using
// percent range and no min/max/scale set on axis.
// For example, we have dataZoom definition:
// [
//      {xAxisIndex: 0, start: 30, end: 70},
//      {yAxisIndex: 0, start: 20, end: 80}
// ]
// In this case, [20, 80] of y-dataZoom should be based on data
// that have filtered by x-dataZoom using range of [30, 70],
// but should not be based on full raw data. Thus sliding
// x-dataZoom will change both ranges of xAxis and yAxis,
// while sliding y-dataZoom will only change the range of yAxis.
// So we should filter x-axis after reset x-axis immediately,
// and then reset y-axis and filter y-axis.
dataZoomModel.eachTargetAxis(filterSingleAxis)}),ecModel.eachComponent("dataZoom",function(dataZoomModel){
// Fullfill all of the range props so that user
// is able to get them from chart.getOption().
var axisProxy=dataZoomModel.findRepresentativeAxisProxy(),percentRange=axisProxy.getDataPercentWindow(),valueRange=axisProxy.getDataValueWindow();dataZoomModel.setRawRange({start:percentRange[0],end:percentRange[1],startValue:valueRange[0],endValue:valueRange[1]})})})},/* 299 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data zoom action
	 */
var zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),echarts=__webpack_require__(1);echarts.registerAction("dataZoom",function(payload,ecModel){var linkedNodesFinder=modelUtil.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent,ecModel,"dataZoom"),modelUtil.eachAxisDim,function(model,dimNames){return model.get(dimNames.axisIndex)}),effectedModels=[];ecModel.eachComponent({mainType:"dataZoom",query:payload},function(model,index){effectedModels.push.apply(effectedModels,linkedNodesFinder(model).nodes)}),zrUtil.each(effectedModels,function(dataZoomModel,index){dataZoomModel.setRawRange({start:payload.start,end:payload.end,startValue:payload.startValue,endValue:payload.endValue})})})},/* 300 */
/***/
function(module,exports,__webpack_require__){/**
	 * visualMap component entry
	 */
__webpack_require__(301),__webpack_require__(312)},/* 301 */
/***/
function(module,exports,__webpack_require__){/**
	 * DataZoom component entry
	 */
__webpack_require__(1).registerPreprocessor(__webpack_require__(302)),__webpack_require__(303),__webpack_require__(304),__webpack_require__(305),__webpack_require__(308),__webpack_require__(311)},/* 302 */
/***/
function(module,exports,__webpack_require__){function has(obj,name){return obj&&obj.hasOwnProperty&&obj.hasOwnProperty(name)}/**
	 * @file VisualMap preprocessor
	 */
var zrUtil=__webpack_require__(3),each=zrUtil.each;module.exports=function(option){var visualMap=option&&option.visualMap;zrUtil.isArray(visualMap)||(visualMap=visualMap?[visualMap]:[]),each(visualMap,function(opt){if(opt){
// rename splitList to pieces
has(opt,"splitList")&&!has(opt,"pieces")&&(opt.pieces=opt.splitList,delete opt.splitList);var pieces=opt.pieces;pieces&&zrUtil.isArray(pieces)&&each(pieces,function(piece){zrUtil.isObject(piece)&&(has(piece,"start")&&!has(piece,"min")&&(piece.min=piece.start),has(piece,"end")&&!has(piece,"max")&&(piece.max=piece.end))})}})}},/* 303 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(19).registerSubTypeDefaulter("visualMap",function(option){
// Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
return option.categories||(option.pieces?option.pieces.length>0:option.splitNumber>0)&&!option.calculable?"piecewise":"continuous"})},/* 304 */
/***/
function(module,exports,__webpack_require__){function processSingleVisualMap(visualMapModel,ecModel){var visualMappings=visualMapModel.targetVisuals,visualTypesMap={};zrUtil.each(["inRange","outOfRange"],function(state){var visualTypes=VisualMapping.prepareVisualTypes(visualMappings[state]);visualTypesMap[state]=visualTypes}),visualMapModel.eachTargetSeries(function(seriesModel){function getVisual(key){return data.getItemVisual(dataIndex,key)}function setVisual(key,value){data.setItemVisual(dataIndex,key,value)}var dataIndex,data=seriesModel.getData(),dimension=visualMapModel.getDataDimension(data);data.each([dimension],function(value,index){
// For performance consideration, do not use curry.
dataIndex=index;for(var valueState=visualMapModel.getValueState(value),mappings=visualMappings[valueState],visualTypes=visualTypesMap[valueState],i=0,len=visualTypes.length;len>i;i++){var type=visualTypes[i];mappings[type]&&mappings[type].applyVisual(value,getVisual,setVisual)}})})}/**
	 * @file Data range visual coding.
	 */
var echarts=__webpack_require__(1),VisualMapping=__webpack_require__(187),zrUtil=__webpack_require__(3);echarts.registerVisualCoding("component",function(ecModel){ecModel.eachComponent("visualMap",function(visualMapModel){processSingleVisualMap(visualMapModel,ecModel)})})},/* 305 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data zoom model
	 */
var VisualMapModel=__webpack_require__(306),zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),DEFAULT_BAR_BOUND=[20,140],ContinuousModel=VisualMapModel.extend({type:"visualMap.continuous",/**
	         * @protected
	         */
defaultOption:{align:"auto",// 'auto', 'left', 'right', 'top', 'bottom'
calculable:!1,// 是否值域漫游，启用后无视splitNumber和pieces，线性渐变
range:[-(1/0),1/0],// 当前选中范围
hoverLink:!0,realtime:!0,itemWidth:null,// 值域图形宽度
itemHeight:null},/**
	         * @override
	         */
doMergeOption:function(newOption,isInit){ContinuousModel.superApply(this,"doMergeOption",arguments),this.resetTargetSeries(newOption,isInit),this.resetExtent(),this.resetVisual(function(mappingOption){mappingOption.mappingMethod="linear"}),this._resetRange()},/**
	         * @protected
	         * @override
	         */
resetItemSize:function(){VisualMapModel.prototype.resetItemSize.apply(this,arguments);var itemSize=this.itemSize;"horizontal"===this._orient&&itemSize.reverse(),(null==itemSize[0]||isNaN(itemSize[0]))&&(itemSize[0]=DEFAULT_BAR_BOUND[0]),(null==itemSize[1]||isNaN(itemSize[1]))&&(itemSize[1]=DEFAULT_BAR_BOUND[1])},/**
	         * @private
	         */
_resetRange:function(){var dataExtent=this.getExtent(),range=this.option.range;range[0]>range[1]&&range.reverse(),range[0]=Math.max(range[0],dataExtent[0]),range[1]=Math.min(range[1],dataExtent[1])},/**
	         * @protected
	         * @override
	         */
completeVisualOption:function(){VisualMapModel.prototype.completeVisualOption.apply(this,arguments),zrUtil.each(this.stateList,function(state){var symbolSize=this.option.controller[state].symbolSize;symbolSize&&symbolSize[0]!==symbolSize[1]&&(symbolSize[0]=0)},this)},/**
	         * @public
	         * @override
	         */
setSelected:function(selected){this.option.range=selected.slice(),this._resetRange()},/**
	         * @public
	         */
getSelected:function(){var dataExtent=this.getExtent(),dataInterval=numberUtil.asc((this.get("range")||[]).slice());
// Clamp
return dataInterval[0]>dataExtent[1]&&(dataInterval[0]=dataExtent[1]),dataInterval[1]>dataExtent[1]&&(dataInterval[1]=dataExtent[1]),dataInterval[0]<dataExtent[0]&&(dataInterval[0]=dataExtent[0]),dataInterval[1]<dataExtent[0]&&(dataInterval[1]=dataExtent[0]),dataInterval},/**
	         * @public
	         * @override
	         */
getValueState:function(value){var range=this.option.range,dataExtent=this.getExtent();
// When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
// range[1] is processed likewise.
return(range[0]<=dataExtent[0]||range[0]<=value)&&(range[1]>=dataExtent[1]||value<=range[1])?"inRange":"outOfRange"}});module.exports=ContinuousModel},/* 306 */
/***/
function(module,exports,__webpack_require__){function replaceVisualOption(targetOption,sourceOption){zrUtil.each(["inRange","outOfRange","target","controller","color"],function(key){sourceOption.hasOwnProperty(key)?targetOption[key]=zrUtil.clone(sourceOption[key]):delete targetOption[key]})}/**
	 * @file Data zoom model
	 */
var zrUtil=__webpack_require__(3),env=__webpack_require__(78),echarts=__webpack_require__(1),modelUtil=__webpack_require__(5),visualDefault=__webpack_require__(307),VisualMapping=__webpack_require__(187),mapVisual=VisualMapping.mapVisual,eachVisual=VisualMapping.eachVisual,numberUtil=__webpack_require__(7),isArray=zrUtil.isArray,each=zrUtil.each,asc=numberUtil.asc,linearMap=numberUtil.linearMap,VisualMapModel=echarts.extendComponentModel({type:"visualMap",dependencies:["series"],/**
	         * [lowerBound, upperBound]
	         *
	         * @readOnly
	         * @type {Array.<number>}
	         */
dataBound:[-(1/0),1/0],/**
	         * @readOnly
	         * @type {Array.<string>}
	         */
stateList:["inRange","outOfRange"],/**
	         * @readOnly
	         * @type {string|Object}
	         */
layoutMode:{type:"box",ignoreSize:!0},/**
	         * @protected
	         */
defaultOption:{show:!0,zlevel:0,z:4,
// set min: 0, max: 200, only for campatible with ec2.
// In fact min max should not have default value.
min:0,// min value, must specified if pieces is not specified.
max:200,// max value, must specified if pieces is not specified.
dimension:null,inRange:null,// 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',
// 'symbol', 'symbolSize'
outOfRange:null,// 'color', 'colorHue', 'colorSaturation',
// 'colorLightness', 'colorAlpha',
// 'symbol', 'symbolSize'
left:0,// 'center' ¦ 'left' ¦ 'right' ¦ {number} (px)
right:null,// The same as left.
top:null,// 'top' ¦ 'bottom' ¦ 'center' ¦ {number} (px)
bottom:0,// The same as top.
itemWidth:null,itemHeight:null,inverse:!1,orient:"vertical",// 'horizontal' ¦ 'vertical'
seriesIndex:null,// 所控制的series indices，默认所有有value的series.
backgroundColor:"rgba(0,0,0,0)",borderColor:"#ccc",// 值域边框颜色
contentColor:"#5793f3",inactiveColor:"#aaa",borderWidth:0,// 值域边框线宽，单位px，默认为0（无边框）
padding:5,// 值域内边距，单位px，默认各方向内边距为5，
// 接受数组分别设定上右下左边距，同css
textGap:10,//
precision:0,// 小数精度，默认为0，无小数点
color:["#bf444c","#d88273","#f6efa6"],//颜色（deprecated，兼容ec2，顺序同pieces，不同于inRange/outOfRange）
formatter:null,text:null,// 文本，如['高', '低']，兼容ec2，text[0]对应高值，text[1]对应低值
textStyle:{color:"#333"}},/**
	         * @protected
	         */
init:function(option,parentModel,ecModel){/**
	             * @private
	             * @type {Array.<number>}
	             */
this._dataExtent,/**
	             * @readOnly
	             */
this.controllerVisuals={},/**
	             * @readOnly
	             */
this.targetVisuals={},/**
	             * @readOnly
	             */
this.textStyleModel,/**
	             * [width, height]
	             * @readOnly
	             * @type {Array.<number>}
	             */
this.itemSize,this.mergeDefaultAndTheme(option,ecModel),this.doMergeOption({},!0)},/**
	         * @public
	         */
mergeOption:function(option){VisualMapModel.superApply(this,"mergeOption",arguments),this.doMergeOption(option,!1)},/**
	         * @protected
	         */
doMergeOption:function(newOption,isInit){var thisOption=this.option;
// Visual attributes merge is not supported, otherwise it
// brings overcomplicated merge logic. See #2853.
!isInit&&replaceVisualOption(thisOption,newOption),
// FIXME
// necessary?
// Disable realtime view update if canvas is not supported.
env.canvasSupported||(thisOption.realtime=!1),this.textStyleModel=this.getModel("textStyle"),this.resetItemSize(),this.completeVisualOption()},/**
	         * @example
	         * this.formatValueText(someVal); // format single numeric value to text.
	         * this.formatValueText(someVal, true); // format single category value to text.
	         * this.formatValueText([min, max]); // format numeric min-max to text.
	         * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
	         * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
	         *
	         * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].
	         * @param {boolean} [isCategory=false] Only available when value is number.
	         * @return {string}
	         * @protected
	         */
formatValueText:function(value,isCategory){function toFixed(val){return val===dataBound[0]?"min":val===dataBound[1]?"max":(+val).toFixed(precision)}var isMinMax,textValue,option=this.option,precision=option.precision,dataBound=this.dataBound,formatter=option.formatter;return zrUtil.isArray(value)&&(value=value.slice(),isMinMax=!0),textValue=isCategory?value:isMinMax?[toFixed(value[0]),toFixed(value[1])]:toFixed(value),zrUtil.isString(formatter)?formatter.replace("{value}",isMinMax?textValue[0]:textValue).replace("{value2}",isMinMax?textValue[1]:textValue):zrUtil.isFunction(formatter)?isMinMax?formatter(value[0],value[1]):formatter(value):isMinMax?value[0]===dataBound[0]?"< "+textValue[1]:value[1]===dataBound[1]?"> "+textValue[0]:textValue[0]+" - "+textValue[1]:textValue},/**
	         * @protected
	         */
resetTargetSeries:function(newOption,isInit){var thisOption=this.option,allSeriesIndex=null==thisOption.seriesIndex;thisOption.seriesIndex=allSeriesIndex?[]:modelUtil.normalizeToArray(thisOption.seriesIndex),allSeriesIndex&&this.ecModel.eachSeries(function(seriesModel,index){var data=seriesModel.getData();
// FIXME
// 只考虑了list，还没有考虑map等。
// FIXME
// 这里可能应该这么判断：data.dimensions中有超出其所属coordSystem的量。
"list"===data.type&&thisOption.seriesIndex.push(index)})},/**
	         * @protected
	         */
resetExtent:function(){var thisOption=this.option,extent=asc([thisOption.min,thisOption.max]);this._dataExtent=extent},/**
	         * @protected
	         */
getDataDimension:function(list){var optDim=this.option.dimension;return null!=optDim?optDim:list.dimensions.length-1},/**
	         * @public
	         * @override
	         */
getExtent:function(){return this._dataExtent.slice()},/**
	         * @protected
	         */
resetVisual:function(fillVisualOption){function doReset(baseAttr,visualMappings){each(this.stateList,function(state){var mappings=visualMappings[state]||(visualMappings[state]=createMappings()),visaulOption=this.option[baseAttr][state]||{};each(visaulOption,function(visualData,visualType){if(VisualMapping.isValidType(visualType)){var mappingOption={type:visualType,dataExtent:dataExtent,visual:visualData};fillVisualOption&&fillVisualOption.call(this,mappingOption,state),mappings[visualType]=new VisualMapping(mappingOption),
// Prepare a alpha for opacity, for some case that opacity
// is not supported, such as rendering using gradient color.
"controller"===baseAttr&&"opacity"===visualType&&(mappingOption=zrUtil.clone(mappingOption),mappingOption.type="colorAlpha",mappings.__hidden.__alphaForOpacity=new VisualMapping(mappingOption))}},this)},this)}function createMappings(){var Creater=function(){};
// Make sure hidden fields will not be visited by
// object iteration (with hasOwnProperty checking).
Creater.prototype.__hidden=Creater.prototype;var obj=new Creater;return obj}var dataExtent=this.getExtent();doReset.call(this,"controller",this.controllerVisuals),doReset.call(this,"target",this.targetVisuals)},/**
	         * @protected
	         */
completeVisualOption:function(){function completeSingle(base){
// Compatible with ec2 dataRange.color.
// The mapping order of dataRange.color is: [high value, ..., low value]
// whereas inRange.color and outOfRange.color is [low value, ..., high value]
// Notice: ec2 has no inverse.
isArray(thisOption.color)&&!base.inRange&&(base.inRange={color:thisOption.color.slice().reverse()}),
// If using shortcut like: {inRange: 'symbol'}, complete default value.
each(this.stateList,function(state){var visualType=base[state];if(zrUtil.isString(visualType)){var defa=visualDefault.get(visualType,"active",isCategory);defa?(base[state]={},base[state][visualType]=defa):
// Mark as not specified.
delete base[state]}},this)}function completeInactive(base,stateExist,stateAbsent){var optExist=base[stateExist],optAbsent=base[stateAbsent];optExist&&!optAbsent&&(optAbsent=base[stateAbsent]={},each(optExist,function(visualData,visualType){var defa=visualDefault.get(visualType,"inactive",isCategory);VisualMapping.isValidType(visualType)&&defa&&(optAbsent[visualType]=defa)}))}function completeController(controller){var symbolExists=(controller.inRange||{}).symbol||(controller.outOfRange||{}).symbol,symbolSizeExists=(controller.inRange||{}).symbolSize||(controller.outOfRange||{}).symbolSize,inactiveColor=this.get("inactiveColor");each(this.stateList,function(state){var itemSize=this.itemSize,visuals=controller[state];
// Set inactive color for controller if no other color attr (like colorAlpha) specified.
visuals||(visuals=controller[state]={color:isCategory?inactiveColor:[inactiveColor]}),
// Consistent symbol and symbolSize if not specified.
visuals.symbol||(visuals.symbol=symbolExists&&zrUtil.clone(symbolExists)||(isCategory?"roundRect":["roundRect"])),visuals.symbolSize||(visuals.symbolSize=symbolSizeExists&&zrUtil.clone(symbolSizeExists)||(isCategory?itemSize[0]:[itemSize[0],itemSize[0]])),
// Filter square and none.
visuals.symbol=mapVisual(visuals.symbol,function(symbol){return"none"===symbol||"square"===symbol?"roundRect":symbol});
// Normalize symbolSize
var symbolSize=visuals.symbolSize;if(symbolSize){var max=-(1/0);
// symbolSize can be object when categories defined.
eachVisual(symbolSize,function(value){value>max&&(max=value)}),visuals.symbolSize=mapVisual(symbolSize,function(value){return linearMap(value,[0,max],[0,itemSize[0]],!0)})}},this)}var thisOption=this.option,base={inRange:thisOption.inRange,outOfRange:thisOption.outOfRange},target=thisOption.target||(thisOption.target={}),controller=thisOption.controller||(thisOption.controller={});zrUtil.merge(target,base),// Do not override
zrUtil.merge(controller,base);// Do not override
var isCategory=this.isCategory();completeSingle.call(this,target),completeSingle.call(this,controller),completeInactive.call(this,target,"inRange","outOfRange"),completeInactive.call(this,target,"outOfRange","inRange"),completeController.call(this,controller)},/**
	         * @public
	         */
eachTargetSeries:function(callback,context){zrUtil.each(this.option.seriesIndex,function(seriesIndex){callback.call(context,this.ecModel.getSeriesByIndex(seriesIndex))},this)},/**
	         * @public
	         */
isCategory:function(){return!!this.option.categories},/**
	         * @protected
	         */
resetItemSize:function(){this.itemSize=[parseFloat(this.get("itemWidth")),parseFloat(this.get("itemHeight"))]},/**
	         * @public
	         * @abstract
	         */
setSelected:zrUtil.noop,/**
	         * @public
	         * @abstract
	         */
getValueState:zrUtil.noop});module.exports=VisualMapModel},/* 307 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Visual mapping.
	 */
var zrUtil=__webpack_require__(3),visualDefault={/**
	         * @public
	         */
get:function(visualType,key,isCategory){var value=zrUtil.clone((defaultOption[visualType]||{})[key]);return isCategory&&zrUtil.isArray(value)?value[value.length-1]:value}},defaultOption={color:{active:["#006edd","#e0ffff"],inactive:["rgba(0,0,0,0)"]},colorHue:{active:[0,360],inactive:[0,0]},colorSaturation:{active:[.3,1],inactive:[0,0]},colorLightness:{active:[.9,.5],inactive:[0,0]},colorAlpha:{active:[.3,1],inactive:[0,0]},symbol:{active:["circle","roundRect","diamond"],inactive:["none"]},symbolSize:{active:[10,50],inactive:[0,0]}};module.exports=visualDefault},/* 308 */
/***/
function(module,exports,__webpack_require__){function createPolygon(points,onDrift,cursor){return new graphic.Polygon({shape:{points:points},draggable:!!onDrift,cursor:cursor,drift:onDrift})}function createHandlePoints(handleIndex,textSize){return 0===handleIndex?[[0,0],[textSize,0],[textSize,-textSize]]:[[0,0],[textSize,0],[textSize,textSize]]}var VisualMapView=__webpack_require__(309),graphic=__webpack_require__(42),zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),sliderMove=__webpack_require__(294),linearMap=numberUtil.linearMap,LinearGradient=__webpack_require__(75),helper=__webpack_require__(310),each=zrUtil.each,ContinuousVisualMapView=VisualMapView.extend({type:"visualMap.continuous",/**
	         * @override
	         */
init:function(){VisualMapView.prototype.init.apply(this,arguments),/**
	             * @private
	             */
this._shapes={},/**
	             * @private
	             */
this._dataInterval=[],/**
	             * @private
	             */
this._handleEnds=[],/**
	             * @private
	             */
this._orient,/**
	             * @private
	             */
this._useHandle},/**
	         * @protected
	         * @override
	         */
doRender:function(visualMapModel,ecModel,api,payload){payload&&"selectDataRange"===payload.type&&payload.from===this.uid?this._updateView():this._buildView()},/**
	         * @private
	         */
_buildView:function(){this.group.removeAll();var visualMapModel=this.visualMapModel,thisGroup=this.group;this._orient=visualMapModel.get("orient"),this._useHandle=visualMapModel.get("calculable"),this._resetInterval(),this._renderBar(thisGroup);var dataRangeText=visualMapModel.get("text");this._renderEndsText(thisGroup,dataRangeText,0),this._renderEndsText(thisGroup,dataRangeText,1),
// Do this for background size calculation.
this._updateView(!0),
// After updating view, inner shapes is built completely,
// and then background can be rendered.
this.renderBackground(thisGroup),
// Real update view
this._updateView(),this.positionGroup(thisGroup)},/**
	         * @private
	         */
_renderEndsText:function(group,dataRangeText,endsIndex){if(dataRangeText){
// Compatible with ec2, text[0] map to high value, text[1] map low value.
var text=dataRangeText[1-endsIndex];text=null!=text?text+"":"";var visualMapModel=this.visualMapModel,textGap=visualMapModel.get("textGap"),itemSize=visualMapModel.itemSize,barGroup=this._shapes.barGroup,position=this._applyTransform([itemSize[0]/2,0===endsIndex?-textGap:itemSize[1]+textGap],barGroup),align=this._applyTransform(0===endsIndex?"bottom":"top",barGroup),orient=this._orient,textStyleModel=this.visualMapModel.textStyleModel;this.group.add(new graphic.Text({style:{x:position[0],y:position[1],textVerticalAlign:"horizontal"===orient?"middle":align,textAlign:"horizontal"===orient?align:"center",text:text,textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor()}}))}},/**
	         * @private
	         */
_renderBar:function(targetGroup){var visualMapModel=this.visualMapModel,shapes=this._shapes,itemSize=visualMapModel.itemSize,orient=this._orient,useHandle=this._useHandle,itemAlign=helper.getItemAlign(visualMapModel,this.api,itemSize),barGroup=shapes.barGroup=this._createBarGroup(itemAlign);
// Bar
barGroup.add(shapes.outOfRange=createPolygon()),barGroup.add(shapes.inRange=createPolygon(null,zrUtil.bind(this._modifyHandle,this,"all"),useHandle?"move":null));var textRect=visualMapModel.textStyleModel.getTextRect("国"),textSize=Math.max(textRect.width,textRect.height);
// Handle
useHandle&&(shapes.handleGroups=[],shapes.handleThumbs=[],shapes.handleLabels=[],shapes.handleLabelPoints=[],this._createHandle(barGroup,0,itemSize,textSize,orient,itemAlign),this._createHandle(barGroup,1,itemSize,textSize,orient,itemAlign)),
// Indicator
// FIXME
targetGroup.add(barGroup)},/**
	         * @private
	         */
_createHandle:function(barGroup,handleIndex,itemSize,textSize,orient){var handleGroup=new graphic.Group({position:[itemSize[0],0]}),handleThumb=createPolygon(createHandlePoints(handleIndex,textSize),zrUtil.bind(this._modifyHandle,this,handleIndex),"move");handleGroup.add(handleThumb);
// For text locating. Text is always horizontal layout
// but should not be effected by transform.
var handleLabelPoint={x:"horizontal"===orient?textSize/2:1.5*textSize,y:"horizontal"===orient?0===handleIndex?-(1.5*textSize):1.5*textSize:0===handleIndex?-textSize/2:textSize/2},textStyleModel=this.visualMapModel.textStyleModel,handleLabel=new graphic.Text({silent:!0,style:{x:0,y:0,text:"",textVerticalAlign:"middle",textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor()}});this.group.add(handleLabel);// Text do not transform
var shapes=this._shapes;shapes.handleThumbs[handleIndex]=handleThumb,shapes.handleGroups[handleIndex]=handleGroup,shapes.handleLabelPoints[handleIndex]=handleLabelPoint,shapes.handleLabels[handleIndex]=handleLabel,barGroup.add(handleGroup)},/**
	         * @private
	         */
_modifyHandle:function(handleIndex,dx,dy){if(this._useHandle){
// Transform dx, dy to bar coordination.
var vertex=this._applyTransform([dx,dy],this._shapes.barGroup,!0);this._updateInterval(handleIndex,vertex[1]),this.api.dispatchAction({type:"selectDataRange",from:this.uid,visualMapId:this.visualMapModel.id,selected:this._dataInterval.slice()})}},/**
	         * @private
	         */
_resetInterval:function(){var visualMapModel=this.visualMapModel,dataInterval=this._dataInterval=visualMapModel.getSelected(),dataExtent=visualMapModel.getExtent(),sizeExtent=[0,visualMapModel.itemSize[1]];this._handleEnds=[linearMap(dataInterval[0],dataExtent,sizeExtent,!0),linearMap(dataInterval[1],dataExtent,sizeExtent,!0)]},/**
	         * @private
	         * @param {(number|string)} handleIndex 0 or 1 or 'all'
	         * @param {number} dx
	         * @param {number} dy
	         */
_updateInterval:function(handleIndex,delta){delta=delta||0;var visualMapModel=this.visualMapModel,handleEnds=this._handleEnds;sliderMove(delta,handleEnds,[0,visualMapModel.itemSize[1]],"all"===handleIndex?"rigid":"push",handleIndex);var dataExtent=visualMapModel.getExtent(),sizeExtent=[0,visualMapModel.itemSize[1]];
// Update data interval.
this._dataInterval=[linearMap(handleEnds[0],sizeExtent,dataExtent,!0),linearMap(handleEnds[1],sizeExtent,dataExtent,!0)]},/**
	         * @private
	         */
_updateView:function(forSketch){var visualMapModel=this.visualMapModel,dataExtent=visualMapModel.getExtent(),shapes=this._shapes,dataInterval=this._dataInterval,outOfRangeHandleEnds=[0,visualMapModel.itemSize[1]],inRangeHandleEnds=forSketch?outOfRangeHandleEnds:this._handleEnds,visualInRange=this._createBarVisual(dataInterval,dataExtent,inRangeHandleEnds,"inRange"),visualOutOfRange=this._createBarVisual(dataExtent,dataExtent,outOfRangeHandleEnds,"outOfRange");shapes.inRange.setStyle({fill:visualInRange.barColor,opacity:visualInRange.opacity}).setShape("points",visualInRange.barPoints),shapes.outOfRange.setStyle({fill:visualOutOfRange.barColor,opacity:visualOutOfRange.opacity}).setShape("points",visualOutOfRange.barPoints),this._useHandle&&each([0,1],function(handleIndex){shapes.handleThumbs[handleIndex].setStyle("fill",visualInRange.handlesColor[handleIndex]),shapes.handleLabels[handleIndex].setStyle({text:visualMapModel.formatValueText(dataInterval[handleIndex]),textAlign:this._applyTransform("horizontal"===this._orient?0===handleIndex?"bottom":"top":"left",shapes.barGroup)})},this),this._updateHandlePosition(inRangeHandleEnds)},/**
	         * @private
	         */
_createBarVisual:function(dataInterval,dataExtent,handleEnds,forceState){var opts={forceState:forceState,convertOpacityToAlpha:!0},colorStops=this.getControllerVisual(dataInterval,"color",opts),symbolSizes=[this.getControllerVisual(dataInterval[0],"symbolSize",opts),this.getControllerVisual(dataInterval[1],"symbolSize",opts)],barPoints=this._createBarPoints(handleEnds,symbolSizes);return{barColor:new LinearGradient(0,0,1,1,colorStops),barPoints:barPoints,handlesColor:[colorStops[0].color,colorStops[colorStops.length-1].color]}},/**
	         * @private
	         */
_createBarPoints:function(handleEnds,symbolSizes){var itemSize=this.visualMapModel.itemSize;return[[itemSize[0]-symbolSizes[0],handleEnds[0]],[itemSize[0],handleEnds[0]],[itemSize[0],handleEnds[1]],[itemSize[0]-symbolSizes[1],handleEnds[1]]]},/**
	         * @private
	         */
_createBarGroup:function(itemAlign){var orient=this._orient,inverse=this.visualMapModel.get("inverse");return new graphic.Group("horizontal"!==orient||inverse?"horizontal"===orient&&inverse?{scale:"bottom"===itemAlign?[-1,1]:[1,1],rotation:-Math.PI/2}:"vertical"!==orient||inverse?{scale:"left"===itemAlign?[1,1]:[-1,1]}:{scale:"left"===itemAlign?[1,-1]:[-1,-1]}:{scale:"bottom"===itemAlign?[1,1]:[-1,1],rotation:Math.PI/2})},/**
	         * @private
	         */
_updateHandlePosition:function(handleEnds){if(this._useHandle){var shapes=this._shapes;each([0,1],function(handleIndex){var handleGroup=shapes.handleGroups[handleIndex];handleGroup.position[1]=handleEnds[handleIndex];
// Update handle label position.
var labelPoint=shapes.handleLabelPoints[handleIndex],textPoint=graphic.applyTransform([labelPoint.x,labelPoint.y],graphic.getTransform(handleGroup,this.group));shapes.handleLabels[handleIndex].setStyle({x:textPoint[0],y:textPoint[1]})},this)}},/**
	         * @private
	         */
_applyTransform:function(vertex,element,inverse){var transform=graphic.getTransform(element,this.group);return graphic[zrUtil.isArray(vertex)?"applyTransform":"transformDirection"](vertex,transform,inverse)}});module.exports=ContinuousVisualMapView},/* 309 */
/***/
function(module,exports,__webpack_require__){var echarts=__webpack_require__(1),zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),formatUtil=__webpack_require__(6),layout=__webpack_require__(21),VisualMapping=__webpack_require__(187);module.exports=echarts.extendComponentView({type:"visualMap",/**
	         * @readOnly
	         * @type {Object}
	         */
autoPositionValues:{left:1,right:1,top:1,bottom:1},init:function(ecModel,api){/**
	             * @readOnly
	             * @type {module:echarts/model/Global}
	             */
this.ecModel=ecModel,/**
	             * @readOnly
	             * @type {module:echarts/ExtensionAPI}
	             */
this.api=api,/**
	             * @readOnly
	             * @type {module:echarts/component/visualMap/visualMapModel}
	             */
this.visualMapModel,/**
	             * @private
	             * @type {Object}
	             */
this._updatableShapes={}},/**
	         * @protected
	         */
render:function(visualMapModel,ecModel,api,payload){return this.visualMapModel=visualMapModel,visualMapModel.get("show")===!1?void this.group.removeAll():void this.doRender.apply(this,arguments)},/**
	         * @protected
	         */
renderBackground:function(group){var visualMapModel=this.visualMapModel,padding=formatUtil.normalizeCssArray(visualMapModel.get("padding")||0),rect=group.getBoundingRect();group.add(new graphic.Rect({z2:-1,// Lay background rect on the lowest layer.
silent:!0,shape:{x:rect.x-padding[3],y:rect.y-padding[0],width:rect.width+padding[3]+padding[1],height:rect.height+padding[0]+padding[2]},style:{fill:visualMapModel.get("backgroundColor"),stroke:visualMapModel.get("borderColor"),lineWidth:visualMapModel.get("borderWidth")}}))},/**
	         * @protected
	         * @param {(number|Array)} targetValue
	         * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
	         * @param {Object} [opts]
	         * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.
	         * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.
	         * @return {*} Visual value.
	         */
getControllerVisual:function(targetValue,visualCluster,opts){function getter(key){return visualObj[key]}function setter(key,value){visualObj[key]=value}opts=opts||{};var forceState=opts.forceState,visualMapModel=this.visualMapModel,targetIsArray=zrUtil.isArray(targetValue);
// targetValue is array when caculate gradient color,
// where forceState is required.
if(targetIsArray&&(!forceState||"color"!==visualCluster))throw new Error(targetValue);var visualObj={};if(
// Default values.
"symbol"===visualCluster&&(visualObj.symbol=visualMapModel.get("itemSymbol")),"color"===visualCluster){var defaultColor=visualMapModel.get("contentColor");visualObj.color=targetIsArray?[{color:defaultColor,offset:0},{color:defaultColor,offset:1}]:defaultColor}var mappings=visualMapModel.controllerVisuals[forceState||visualMapModel.getValueState(targetValue)],visualTypes=VisualMapping.prepareVisualTypes(mappings);return zrUtil.each(visualTypes,function(type){var visualMapping=mappings[type];opts.convertOpacityToAlpha&&"opacity"===type&&(type="colorAlpha",visualMapping=mappings.__alphaForOpacity),VisualMapping.dependsOn(type,visualCluster)&&visualMapping&&visualMapping.applyVisual(targetValue,getter,setter)}),visualObj[visualCluster]},/**
	         * @protected
	         */
positionGroup:function(group){var model=this.visualMapModel,api=this.api;layout.positionGroup(group,model.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()})},/**
	         * @protected
	         * @abstract
	         */
doRender:zrUtil.noop})},/* 310 */
/***/
function(module,exports,__webpack_require__){var layout=__webpack_require__(21),helper={/**
	         * @param {module:echarts/component/visualMap/VisualMapModel} visualMapModel\
	         * @param {module:echarts/ExtensionAPI} api
	         * @param {Array.<number>} itemSize always [short, long]
	         * @return {string} 'left' or 'right' or 'top' or 'bottom'
	         */
getItemAlign:function(visualMapModel,api,itemSize){var modelOption=visualMapModel.option,itemAlign=modelOption.align;if(null!=itemAlign&&"auto"!==itemAlign)return itemAlign;for(var ecSize={width:api.getWidth(),height:api.getHeight()},realIndex="horizontal"===modelOption.orient?1:0,paramsSet=[["left","right","width"],["top","bottom","height"]],reals=paramsSet[realIndex],fakeValue=[0,null,10],layoutInput={},i=0;3>i;i++)layoutInput[paramsSet[1-realIndex][i]]=fakeValue[i],layoutInput[reals[i]]=2===i?itemSize[0]:modelOption[reals[i]];var rParam=[["x","width",3],["y","height",0]][realIndex],rect=layout.getLayoutRect(layoutInput,ecSize,modelOption.padding);return reals[(rect.margin[rParam[2]]||0)+rect[rParam[0]]+.5*rect[rParam[1]]<.5*ecSize[rParam[1]]?0:1]}};module.exports=helper},/* 311 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data range action
	 */
var echarts=__webpack_require__(1),actionInfo={type:"selectDataRange",event:"dataRangeSelected",
// FIXME use updateView appears wrong
update:"update"};echarts.registerAction(actionInfo,function(payload,ecModel){ecModel.eachComponent({mainType:"visualMap",query:payload},function(model){model.setSelected(payload.selected)})})},/* 312 */
/***/
function(module,exports,__webpack_require__){/**
	 * DataZoom component entry
	 */
__webpack_require__(1).registerPreprocessor(__webpack_require__(302)),__webpack_require__(303),__webpack_require__(304),__webpack_require__(313),__webpack_require__(314),__webpack_require__(311)},/* 313 */
/***/
function(module,exports,__webpack_require__){function normalizeReverse(thisOption,arr){var inverse=thisOption.inverse;("vertical"===thisOption.orient?!inverse:inverse)&&arr.reverse()}var VisualMapModel=__webpack_require__(306),zrUtil=__webpack_require__(3),VisualMapping=__webpack_require__(187),PiecewiseModel=VisualMapModel.extend({type:"visualMap.piecewise",/**
	         * Order Rule:
	         *
	         * option.categories / option.pieces / option.text / option.selected:
	         *     If !option.inverse,
	         *     Order when vertical: ['top', ..., 'bottom'].
	         *     Order when horizontal: ['left', ..., 'right'].
	         *     If option.inverse, the meaning of
	         *     the order should be reversed.
	         *
	         * this._pieceList:
	         *     The order is always [low, ..., high].
	         *
	         * Mapping from location to low-high:
	         *     If !option.inverse
	         *     When vertical, top is high.
	         *     When horizontal, right is high.
	         *     If option.inverse, reverse.
	         */
/**
	         * @protected
	         */
defaultOption:{selected:null,// Object. If not specified, means selected.
// When pieces and splitNumber: {'0': true, '5': true}
// When categories: {'cate1': false, 'cate3': true}
// When selected === false, means all unselected.
align:"auto",// 'auto', 'left', 'right'
itemWidth:20,// 值域图形宽度
itemHeight:14,// 值域图形高度
itemSymbol:"roundRect",pieceList:null,// 值顺序：由高到低, item can be:
// {min, max, value, color, colorSaturation, colorAlpha, symbol, symbolSize}
categories:null,// 描述 category 数据。如：['some1', 'some2', 'some3']，设置后，min max失效。
splitNumber:5,// 分割段数，默认为5，为0时为线性渐变 (continous)
selectedMode:"multiple",itemGap:10},/**
	         * @override
	         */
doMergeOption:function(newOption,isInit){PiecewiseModel.superApply(this,"doMergeOption",arguments),/**
	             * The order is always [low, ..., high].
	             * [{text: string, interval: Array.<number>}, ...]
	             * @private
	             * @type {Array.<Object>}
	             */
this._pieceList=[],this.resetTargetSeries(newOption,isInit),this.resetExtent();/**
	             * 'pieces', 'categories', 'splitNumber'
	             * @type {string}
	             */
var mode=this._mode=this._decideMode();resetMethods[this._mode].call(this),this._resetSelected(newOption,isInit);var categories=this.option.categories;this.resetVisual(function(mappingOption,state){"categories"===mode?(mappingOption.mappingMethod="category",mappingOption.categories=zrUtil.clone(categories)):(mappingOption.mappingMethod="piecewise",mappingOption.pieceList=zrUtil.map(this._pieceList,function(piece){var piece=zrUtil.clone(piece);return"inRange"!==state&&(piece.visual=null),piece}))})},_resetSelected:function(newOption,isInit){var thisOption=this.option,pieceList=this._pieceList,selected=(isInit?thisOption:newOption).selected||{};if(thisOption.selected=selected,
// Consider 'not specified' means true.
zrUtil.each(pieceList,function(piece,index){var key=this.getSelectedMapKey(piece);key in selected||(selected[key]=!0)},this),"single"===thisOption.selectedMode){
// Ensure there is only one selected.
var hasSel=!1;zrUtil.each(pieceList,function(piece,index){var key=this.getSelectedMapKey(piece);selected[key]&&(hasSel?selected[key]=!1:hasSel=!0)},this)}},/**
	         * @public
	         */
getSelectedMapKey:function(piece){return"categories"===this._mode?piece.value+"":piece.index+""},/**
	         * @public
	         */
getPieceList:function(){return this._pieceList},/**
	         * @private
	         * @return {string}
	         */
_decideMode:function(){var option=this.option;return option.pieces&&option.pieces.length>0?"pieces":this.option.categories?"categories":"splitNumber"},/**
	         * @public
	         * @override
	         */
setSelected:function(selected){this.option.selected=zrUtil.clone(selected)},/**
	         * @public
	         * @override
	         */
getValueState:function(value){var pieceList=this._pieceList,index=VisualMapping.findPieceIndex(value,pieceList);return null!=index&&this.option.selected[this.getSelectedMapKey(pieceList[index])]?"inRange":"outOfRange"}}),resetMethods={splitNumber:function(){var thisOption=this.option,precision=thisOption.precision,dataExtent=this.getExtent(),splitNumber=thisOption.splitNumber;splitNumber=Math.max(parseInt(splitNumber,10),1),thisOption.splitNumber=splitNumber;
// Precision auto-adaption
for(var splitStep=(dataExtent[1]-dataExtent[0])/splitNumber;+splitStep.toFixed(precision)!==splitStep&&5>precision;)precision++;thisOption.precision=precision,splitStep=+splitStep.toFixed(precision);for(var i=0,curr=dataExtent[0];splitNumber>i;i++,curr+=splitStep){var max=i===splitNumber-1?dataExtent[1]:curr+splitStep;this._pieceList.push({text:this.formatValueText([curr,max]),index:i,interval:[curr,max]})}},categories:function(){var thisOption=this.option;zrUtil.each(thisOption.categories,function(cate){
// FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。
// 是否改一致。
this._pieceList.push({text:this.formatValueText(cate,!0),value:cate})},this),
// See "Order Rule".
normalizeReverse(thisOption,this._pieceList)},pieces:function(){var thisOption=this.option;zrUtil.each(thisOption.pieces,function(pieceListItem,index){zrUtil.isObject(pieceListItem)||(pieceListItem={value:pieceListItem});var hasLabel,item={text:"",index:index};if(null!=pieceListItem.label&&(item.text=pieceListItem.label,hasLabel=!0),pieceListItem.hasOwnProperty("value"))item.value=pieceListItem.value,hasLabel||(item.text=this.formatValueText(item.value));else{var min=pieceListItem.min,max=pieceListItem.max;null==min&&(min=-(1/0)),null==max&&(max=1/0),min===max&&(
// Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
// we use value to lift the priority when min === max
item.value=min),item.interval=[min,max],hasLabel||(item.text=this.formatValueText([min,max]))}item.visual=VisualMapping.retrieveVisuals(pieceListItem),this._pieceList.push(item)},this),
// See "Order Rule".
normalizeReverse(thisOption,this._pieceList)}};module.exports=PiecewiseModel},/* 314 */
/***/
function(module,exports,__webpack_require__){var VisualMapView=__webpack_require__(309),zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),symbolCreators=__webpack_require__(100),layout=__webpack_require__(21),helper=__webpack_require__(310),PiecewiseVisualMapView=VisualMapView.extend({type:"visualMap.piecewise",/**
	         * @protected
	         * @override
	         */
doRender:function(){function renderItem(item){var itemGroup=new graphic.Group;itemGroup.onclick=zrUtil.bind(this._onItemClick,this,item.piece),this._createItemSymbol(itemGroup,item.piece,[0,0,itemSize[0],itemSize[1]]),showLabel&&itemGroup.add(new graphic.Text({style:{x:"right"===itemAlign?-textGap:itemSize[0]+textGap,y:itemSize[1]/2,text:item.piece.text,textVerticalAlign:"middle",textAlign:itemAlign,textFont:textFont,fill:textFill}})),thisGroup.add(itemGroup)}var thisGroup=this.group;thisGroup.removeAll();var visualMapModel=this.visualMapModel,textGap=visualMapModel.get("textGap"),textStyleModel=visualMapModel.textStyleModel,textFont=textStyleModel.getFont(),textFill=textStyleModel.getTextColor(),itemAlign=this._getItemAlign(),itemSize=visualMapModel.itemSize,viewData=this._getViewData(),showLabel=!viewData.endsText,showEndsText=!showLabel;showEndsText&&this._renderEndsText(thisGroup,viewData.endsText[0],itemSize),zrUtil.each(viewData.pieceList,renderItem,this),showEndsText&&this._renderEndsText(thisGroup,viewData.endsText[1],itemSize),layout.box(visualMapModel.get("orient"),thisGroup,visualMapModel.get("itemGap")),this.renderBackground(thisGroup),this.positionGroup(thisGroup)},/**
	         * @private
	         */
_getItemAlign:function(){var visualMapModel=this.visualMapModel,modelOption=visualMapModel.option;if("vertical"===modelOption.orient)return helper.getItemAlign(visualMapModel,this.api,visualMapModel.itemSize);// horizontal, most case left unless specifying right.
var align=modelOption.align;return align&&"auto"!==align||(align="left"),align},/**
	         * @private
	         */
_renderEndsText:function(group,text,itemSize){if(text){var itemGroup=new graphic.Group,textStyleModel=this.visualMapModel.textStyleModel;itemGroup.add(new graphic.Text({style:{x:itemSize[0]/2,y:itemSize[1]/2,textVerticalAlign:"middle",textAlign:"center",text:text,textFont:textStyleModel.getFont(),fill:textStyleModel.getTextColor()}})),group.add(itemGroup)}},/**
	         * @private
	         * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
	         */
_getViewData:function(){var visualMapModel=this.visualMapModel,pieceList=zrUtil.map(visualMapModel.getPieceList(),function(piece,index){return{piece:piece,index:index}}),endsText=visualMapModel.get("text"),orient=visualMapModel.get("orient"),inverse=visualMapModel.get("inverse");
// Order of pieceList is always [low, ..., high]
return("horizontal"===orient?inverse:!inverse)?pieceList.reverse():endsText&&(endsText=endsText.slice().reverse()),{pieceList:pieceList,endsText:endsText}},/**
	         * @private
	         */
_createItemSymbol:function(group,piece,shapeParam){var representValue;if(this.visualMapModel.isCategory())representValue=piece.value;else if(null!=piece.value)representValue=piece.value;else{var pieceInterval=piece.interval||[];representValue=(pieceInterval[0]+pieceInterval[1])/2}group.add(symbolCreators.createSymbol(this.getControllerVisual(representValue,"symbol"),shapeParam[0],shapeParam[1],shapeParam[2],shapeParam[3],this.getControllerVisual(representValue,"color")))},/**
	         * @private
	         */
_onItemClick:function(piece){var visualMapModel=this.visualMapModel,option=visualMapModel.option,selected=zrUtil.clone(option.selected),newKey=visualMapModel.getSelectedMapKey(piece);"single"===option.selectedMode?(selected[newKey]=!0,zrUtil.each(selected,function(o,key){selected[key]=key===newKey})):selected[newKey]=!selected[newKey],this.api.dispatchAction({type:"selectDataRange",from:this.uid,visualMapId:this.visualMapModel.id,selected:selected})}});module.exports=PiecewiseVisualMapView},/* 315 */
/***/
function(module,exports,__webpack_require__){
// HINT Markpoint can't be used too much
__webpack_require__(316),__webpack_require__(317),__webpack_require__(1).registerPreprocessor(function(opt){
// Make sure markPoint component is enabled
opt.markPoint=opt.markPoint||{}})},/* 316 */
/***/
function(module,exports,__webpack_require__){
// Default enable markPoint
// var globalDefault = require('../../model/globalDefault');
var modelUtil=__webpack_require__(5),MarkPointModel=__webpack_require__(1).extendComponentModel({type:"markPoint",dependencies:["series","grid","polar"],/**
	         * @overrite
	         */
init:function(option,parentModel,ecModel,extraOpt){this.mergeDefaultAndTheme(option,ecModel),this.mergeOption(option,ecModel,extraOpt.createdBySelf,!0)},mergeOption:function(newOpt,ecModel,createdBySelf,isInit){createdBySelf||ecModel.eachSeries(function(seriesModel){var markPointOpt=seriesModel.get("markPoint"),mpModel=seriesModel.markPointModel;if(!markPointOpt||!markPointOpt.data)return void(seriesModel.markPointModel=null);if(mpModel)mpModel.mergeOption(markPointOpt,ecModel,!0);else{isInit&&
// Default label emphasis `position` and `show`
modelUtil.defaultEmphasis(markPointOpt.label,["position","show","textStyle","distance","formatter"]);var opt={
// Use the same series index and name
seriesIndex:seriesModel.seriesIndex,name:seriesModel.name,createdBySelf:!0};mpModel=new MarkPointModel(markPointOpt,this,ecModel,opt)}seriesModel.markPointModel=mpModel},this)},defaultOption:{zlevel:0,z:5,symbol:"pin",// 标注类型
symbolSize:50,// 标注大小
// symbolRotate: null, // 标注旋转控制
tooltip:{trigger:"item"},label:{normal:{show:!0,
// 标签文本格式器，同Tooltip.formatter，不支持回调
// formatter: null,
// 可选为'left'|'right'|'top'|'bottom'
position:"inside"},emphasis:{show:!0}},itemStyle:{normal:{
// color: 各异，
// 标注边线颜色，优先于color
// borderColor: 各异,
// 标注边线线宽，单位px，默认为1
borderWidth:2},emphasis:{}}}});module.exports=MarkPointModel},/* 317 */
/***/
function(module,exports,__webpack_require__){function updateMarkerLayout(mpData,seriesModel,api){var coordSys=seriesModel.coordinateSystem;mpData.each(function(idx){var point,itemModel=mpData.getItemModel(idx),xPx=itemModel.getShallow("x"),yPx=itemModel.getShallow("y");if(null!=xPx&&null!=yPx)point=[numberUtil.parsePercent(xPx,api.getWidth()),numberUtil.parsePercent(yPx,api.getHeight())];else if(seriesModel.getMarkerPosition)
// Use the getMarkerPoisition
point=seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions,idx));else if(coordSys){var x=mpData.get(coordSys.dimensions[0],idx),y=mpData.get(coordSys.dimensions[1],idx);point=coordSys.dataToPoint([x,y])}mpData.setItemLayout(idx,point)})}/**
	     * @inner
	     * @param {module:echarts/coord/*} [coordSys]
	     * @param {module:echarts/model/Series} seriesModel
	     * @param {module:echarts/model/Model} mpModel
	     */
function createList(coordSys,seriesModel,mpModel){var coordDimsInfos;coordDimsInfos=coordSys?zrUtil.map(coordSys&&coordSys.dimensions,function(coordDim){var info=seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0])||{};// In map series data don't have lng and lat dimension. Fallback to same with coordSys
return info.name=coordDim,info}):[{name:"value",type:"float"}];var mpData=new List(coordDimsInfos,mpModel),dataOpt=zrUtil.map(mpModel.get("data"),zrUtil.curry(markerHelper.dataTransform,seriesModel));return coordSys&&(dataOpt=zrUtil.filter(dataOpt,zrUtil.curry(markerHelper.dataFilter,coordSys))),mpData.initData(dataOpt,null,coordSys?markerHelper.dimValueGetter:function(item){return item.value}),mpData}var SymbolDraw=__webpack_require__(98),zrUtil=__webpack_require__(3),formatUtil=__webpack_require__(6),modelUtil=__webpack_require__(5),numberUtil=__webpack_require__(7),addCommas=formatUtil.addCommas,encodeHTML=formatUtil.encodeHTML,List=__webpack_require__(94),markerHelper=__webpack_require__(318),markPointFormatMixin={getRawDataArray:function(){return this.option.data},formatTooltip:function(dataIndex){var data=this.getData(),value=this.getRawValue(dataIndex),formattedValue=zrUtil.isArray(value)?zrUtil.map(value,addCommas).join(", "):addCommas(value),name=data.getName(dataIndex);return this.name+"<br />"+((name?encodeHTML(name)+" : ":"")+formattedValue)},getData:function(){return this._data},setData:function(data){this._data=data}};zrUtil.defaults(markPointFormatMixin,modelUtil.dataFormatMixin),__webpack_require__(1).extendComponentView({type:"markPoint",init:function(){this._symbolDrawMap={}},render:function(markPointModel,ecModel,api){var symbolDrawMap=this._symbolDrawMap;for(var name in symbolDrawMap)symbolDrawMap[name].__keep=!1;ecModel.eachSeries(function(seriesModel){var mpModel=seriesModel.markPointModel;mpModel&&this._renderSeriesMP(seriesModel,mpModel,api)},this);for(var name in symbolDrawMap)symbolDrawMap[name].__keep||(symbolDrawMap[name].remove(),this.group.remove(symbolDrawMap[name].group))},updateLayout:function(markPointModel,ecModel,api){ecModel.eachSeries(function(seriesModel){var mpModel=seriesModel.markPointModel;mpModel&&(updateMarkerLayout(mpModel.getData(),seriesModel,api),this._symbolDrawMap[seriesModel.name].updateLayout(mpModel))},this)},_renderSeriesMP:function(seriesModel,mpModel,api){var coordSys=seriesModel.coordinateSystem,seriesName=seriesModel.name,seriesData=seriesModel.getData(),symbolDrawMap=this._symbolDrawMap,symbolDraw=symbolDrawMap[seriesName];symbolDraw||(symbolDraw=symbolDrawMap[seriesName]=new SymbolDraw);var mpData=createList(coordSys,seriesModel,mpModel);
// FIXME
zrUtil.mixin(mpModel,markPointFormatMixin),mpModel.setData(mpData),updateMarkerLayout(mpModel.getData(),seriesModel,api),mpData.each(function(idx){var itemModel=mpData.getItemModel(idx),symbolSize=itemModel.getShallow("symbolSize");"function"==typeof symbolSize&&(
// FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
symbolSize=symbolSize(mpModel.getRawValue(idx),mpModel.getDataParams(idx))),mpData.setItemVisual(idx,{symbolSize:symbolSize,color:itemModel.get("itemStyle.normal.color")||seriesData.getVisual("color"),symbol:itemModel.getShallow("symbol")})}),
// TODO Text are wrong
symbolDraw.updateData(mpData),this.group.add(symbolDraw.group),
// Set host model for tooltip
// FIXME
mpData.eachItemGraphicEl(function(el){el.traverse(function(child){child.dataModel=mpModel})}),symbolDraw.__keep=!0}})},/* 318 */
/***/
function(module,exports,__webpack_require__){function getPrecision(data,valueAxisDim,dataIndex){var precision=-1;do precision=Math.max(numberUtil.getPrecision(data.get(valueAxisDim,dataIndex)),precision),data=data.stackedOn;while(data);return precision}function markerTypeCalculatorWithExtent(mlType,data,baseDataDim,valueDataDim,baseCoordIndex,valueCoordIndex){var coordArr=[],value=numCalculate(data,valueDataDim,mlType),dataIndex=data.indexOfNearest(valueDataDim,value,!0);coordArr[baseCoordIndex]=data.get(baseDataDim,dataIndex,!0),coordArr[valueCoordIndex]=data.get(valueDataDim,dataIndex,!0);var precision=getPrecision(data,valueDataDim,dataIndex);return precision>=0&&(coordArr[valueCoordIndex]=+coordArr[valueCoordIndex].toFixed(precision)),coordArr}var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),indexOf=zrUtil.indexOf,curry=zrUtil.curry,markerTypeCalculator={/**
	         * @method
	         * @param {module:echarts/data/List} data
	         * @param {string} baseAxisDim
	         * @param {string} valueAxisDim
	         */
min:curry(markerTypeCalculatorWithExtent,"min"),/**
	         * @method
	         * @param {module:echarts/data/List} data
	         * @param {string} baseAxisDim
	         * @param {string} valueAxisDim
	         */
max:curry(markerTypeCalculatorWithExtent,"max"),/**
	         * @method
	         * @param {module:echarts/data/List} data
	         * @param {string} baseAxisDim
	         * @param {string} valueAxisDim
	         */
average:curry(markerTypeCalculatorWithExtent,"average")},dataTransform=function(seriesModel,item){var data=seriesModel.getData(),coordSys=seriesModel.coordinateSystem;
// 1. If not specify the position with pixel directly
// 2. If `coord` is not a data array. Which uses `xAxis`,
// `yAxis` to specify the coord on each dimension
if((isNaN(item.x)||isNaN(item.y))&&!zrUtil.isArray(item.coord)&&coordSys){var axisInfo=getAxisInfo(item,data,coordSys,seriesModel);if(item=zrUtil.clone(item),item.type&&markerTypeCalculator[item.type]&&axisInfo.baseAxis&&axisInfo.valueAxis){var dims=coordSys.dimensions,baseCoordIndex=indexOf(dims,axisInfo.baseAxis.dim),valueCoordIndex=indexOf(dims,axisInfo.valueAxis.dim);item.coord=markerTypeCalculator[item.type](data,axisInfo.baseDataDim,axisInfo.valueDataDim,baseCoordIndex,valueCoordIndex),
// Force to use the value of calculated value.
item.value=item.coord[valueCoordIndex]}else
// FIXME Only has one of xAxis and yAxis.
item.coord=[null!=item.xAxis?item.xAxis:item.radiusAxis,null!=item.yAxis?item.yAxis:item.angleAxis]}return item},getAxisInfo=function(item,data,coordSys,seriesModel){var ret={};return null!=item.valueIndex||null!=item.valueDim?(ret.valueDataDim=null!=item.valueIndex?data.getDimension(item.valueIndex):item.valueDim,ret.valueAxis=coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim)),ret.baseAxis=coordSys.getOtherAxis(ret.valueAxis),ret.baseDataDim=seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0]):(ret.baseAxis=seriesModel.getBaseAxis(),ret.valueAxis=coordSys.getOtherAxis(ret.baseAxis),ret.baseDataDim=seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0],ret.valueDataDim=seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0]),ret},dataFilter=function(coordSys,item){
// Alwalys return true if there is no coordSys
return coordSys&&coordSys.containData&&item.coord&&(null==item.x||null==item.y)?coordSys.containData(item.coord):!0},dimValueGetter=function(item,dimName,dataIndex,dimIndex){
// x, y, radius, angle
// x, y, radius, angle
return 2>dimIndex?item.coord&&item.coord[dimIndex]:item.value},numCalculate=function(data,valueDataDim,mlType){return"average"===mlType?data.getSum(valueDataDim,!0)/data.count():data.getDataExtent(valueDataDim,!0)["max"===mlType?1:0]};module.exports={dataTransform:dataTransform,dataFilter:dataFilter,dimValueGetter:dimValueGetter,getAxisInfo:getAxisInfo,numCalculate:numCalculate}},/* 319 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(320),__webpack_require__(321),__webpack_require__(1).registerPreprocessor(function(opt){
// Make sure markLine component is enabled
opt.markLine=opt.markLine||{}})},/* 320 */
/***/
function(module,exports,__webpack_require__){
// Default enable markLine
// var globalDefault = require('../../model/globalDefault');
var modelUtil=__webpack_require__(5),MarkLineModel=__webpack_require__(1).extendComponentModel({type:"markLine",dependencies:["series","grid","polar"],/**
	         * @overrite
	         */
init:function(option,parentModel,ecModel,extraOpt){this.mergeDefaultAndTheme(option,ecModel),this.mergeOption(option,ecModel,extraOpt.createdBySelf,!0)},mergeOption:function(newOpt,ecModel,createdBySelf,isInit){createdBySelf||ecModel.eachSeries(function(seriesModel){var markLineOpt=seriesModel.get("markLine"),mlModel=seriesModel.markLineModel;if(!markLineOpt||!markLineOpt.data)return void(seriesModel.markLineModel=null);if(mlModel)mlModel.mergeOption(markLineOpt,ecModel,!0);else{isInit&&
// Default label emphasis `position` and `show`
modelUtil.defaultEmphasis(markLineOpt.label,["position","show","textStyle","distance","formatter"]);var opt={
// Use the same series index and name
seriesIndex:seriesModel.seriesIndex,name:seriesModel.name,createdBySelf:!0};mlModel=new MarkLineModel(markLineOpt,this,ecModel,opt)}seriesModel.markLineModel=mlModel},this)},defaultOption:{zlevel:0,z:5,
// 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string
symbol:["circle","arrow"],
// 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
symbolSize:[8,16],
// 标线起始和结束的symbol旋转控制
//symbolRotate: null,
//smooth: false,
precision:2,tooltip:{trigger:"item"},label:{normal:{show:!0,
// 标签文本格式器，同Tooltip.formatter，不支持回调
// formatter: null,
// 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'
position:"end"},emphasis:{show:!0}},lineStyle:{normal:{
// color
// width
type:"dashed"},emphasis:{width:3}},animationEasing:"linear"}});module.exports=MarkLineModel},/* 321 */
/***/
function(module,exports,__webpack_require__){function markLineFilter(coordSys,item){return markerHelper.dataFilter(coordSys,item[0])&&markerHelper.dataFilter(coordSys,item[1])}function updateSingleMarkerEndLayout(data,idx,isFrom,mlType,valueIndex,seriesModel,api){var point,coordSys=seriesModel.coordinateSystem,itemModel=data.getItemModel(idx),xPx=itemModel.get("x"),yPx=itemModel.get("y");if(null!=xPx&&null!=yPx)point=[numberUtil.parsePercent(xPx,api.getWidth()),numberUtil.parsePercent(yPx,api.getHeight())];else{
// Chart like bar may have there own marker positioning logic
if(seriesModel.getMarkerPosition)
// Use the getMarkerPoisition
point=seriesModel.getMarkerPosition(data.getValues(data.dimensions,idx));else{var dims=coordSys.dimensions,x=data.get(dims[0],idx),y=data.get(dims[1],idx);point=coordSys.dataToPoint([x,y])}
// Expand min, max, average line to the edge of grid
// FIXME Glue code
if(mlType&&"cartesian2d"===coordSys.type){var mlOnAxis=null!=valueIndex?coordSys.getAxis(1===valueIndex?"x":"y"):coordSys.getAxesByScale("ordinal")[0];mlOnAxis&&mlOnAxis.onBand&&(point["x"===mlOnAxis.dim?0:1]=mlOnAxis.toGlobalCoord(mlOnAxis.getExtent()[isFrom?0:1]))}}data.setItemLayout(idx,point)}/**
	     * @inner
	     * @param {module:echarts/coord/*} coordSys
	     * @param {module:echarts/model/Series} seriesModel
	     * @param {module:echarts/model/Model} mpModel
	     */
function createList(coordSys,seriesModel,mlModel){var coordDimsInfos;coordDimsInfos=coordSys?zrUtil.map(coordSys&&coordSys.dimensions,function(coordDim){var info=seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0])||{};// In map series data don't have lng and lat dimension. Fallback to same with coordSys
return info.name=coordDim,info}):[{name:"value",type:"float"}];var fromData=new List(coordDimsInfos,mlModel),toData=new List(coordDimsInfos,mlModel),lineData=new List([],mlModel),optData=zrUtil.map(mlModel.get("data"),zrUtil.curry(markLineTransform,seriesModel,coordSys,mlModel));coordSys&&(optData=zrUtil.filter(optData,zrUtil.curry(markLineFilter,coordSys)));var dimValueGetter=coordSys?markerHelper.dimValueGetter:function(item){return item.value};return fromData.initData(zrUtil.map(optData,function(item){return item[0]}),null,dimValueGetter),toData.initData(zrUtil.map(optData,function(item){return item[1]}),null,dimValueGetter),lineData.initData(zrUtil.map(optData,function(item){return item[2]})),{from:fromData,to:toData,line:lineData}}var zrUtil=__webpack_require__(3),List=__webpack_require__(94),formatUtil=__webpack_require__(6),modelUtil=__webpack_require__(5),numberUtil=__webpack_require__(7),addCommas=formatUtil.addCommas,encodeHTML=formatUtil.encodeHTML,markerHelper=__webpack_require__(318),LineDraw=__webpack_require__(194),markLineTransform=function(seriesModel,coordSys,mlModel,item){var data=seriesModel.getData(),mlType=item.type;if(!zrUtil.isArray(item)&&("min"===mlType||"max"===mlType||"average"===mlType)){var axisInfo=markerHelper.getAxisInfo(item,data,coordSys,seriesModel),baseAxisKey=axisInfo.baseAxis.dim+"Axis",valueAxisKey=axisInfo.valueAxis.dim+"Axis",baseScaleExtent=axisInfo.baseAxis.scale.getExtent(),mlFrom=zrUtil.clone(item),mlTo={};mlFrom.type=null,
// FIXME Polar should use circle
mlFrom[baseAxisKey]=baseScaleExtent[0],mlTo[baseAxisKey]=baseScaleExtent[1];var value=markerHelper.numCalculate(data,axisInfo.valueDataDim,mlType);
// Round if axis is cateogry
value=axisInfo.valueAxis.coordToData(axisInfo.valueAxis.dataToCoord(value));var precision=mlModel.get("precision");precision>=0&&(value=+value.toFixed(precision)),mlFrom[valueAxisKey]=mlTo[valueAxisKey]=value,item=[mlFrom,mlTo,{// Extra option for tooltip and label
type:mlType,valueIndex:item.valueIndex,
// Force to use the value of calculated value.
value:value}]}
// Avoid line data type is extended by from(to) data type
// Merge from option and to option into line option
return item=[markerHelper.dataTransform(seriesModel,item[0]),markerHelper.dataTransform(seriesModel,item[1]),zrUtil.extend({},item[2])],item[2].type=item[2].type||"",zrUtil.merge(item[2],item[0]),zrUtil.merge(item[2],item[1]),item},markLineFormatMixin={formatTooltip:function(dataIndex){var data=this._data,value=this.getRawValue(dataIndex),formattedValue=zrUtil.isArray(value)?zrUtil.map(value,addCommas).join(", "):addCommas(value),name=data.getName(dataIndex);return this.name+"<br />"+((name?encodeHTML(name)+" : ":"")+formattedValue)},getRawDataArray:function(){return this.option.data},getData:function(){return this._data},setData:function(data){this._data=data}};zrUtil.defaults(markLineFormatMixin,modelUtil.dataFormatMixin),__webpack_require__(1).extendComponentView({type:"markLine",init:function(){/**
	             * Markline grouped by series
	             * @private
	             * @type {Object}
	             */
this._markLineMap={}},render:function(markLineModel,ecModel,api){var lineDrawMap=this._markLineMap;for(var name in lineDrawMap)lineDrawMap[name].__keep=!1;ecModel.eachSeries(function(seriesModel){var mlModel=seriesModel.markLineModel;mlModel&&this._renderSeriesML(seriesModel,mlModel,ecModel,api)},this);for(var name in lineDrawMap)lineDrawMap[name].__keep||this.group.remove(lineDrawMap[name].group)},updateLayout:function(markLineModel,ecModel,api){ecModel.eachSeries(function(seriesModel){var mlModel=seriesModel.markLineModel;if(mlModel){var mlData=mlModel.getData(),fromData=mlModel.__from,toData=mlModel.__to;
// Update visual and layout of from symbol and to symbol
fromData.each(function(idx){var lineModel=mlData.getItemModel(idx),mlType=lineModel.get("type"),valueIndex=lineModel.get("valueIndex");updateSingleMarkerEndLayout(fromData,idx,!0,mlType,valueIndex,seriesModel,api),updateSingleMarkerEndLayout(toData,idx,!1,mlType,valueIndex,seriesModel,api)}),
// Update layout of line
mlData.each(function(idx){mlData.setItemLayout(idx,[fromData.getItemLayout(idx),toData.getItemLayout(idx)])}),this._markLineMap[seriesModel.name].updateLayout()}},this)},_renderSeriesML:function(seriesModel,mlModel,ecModel,api){function updateDataVisualAndLayout(data,idx,isFrom,mlType,valueIndex){var itemModel=data.getItemModel(idx);updateSingleMarkerEndLayout(data,idx,isFrom,mlType,valueIndex,seriesModel,api),data.setItemVisual(idx,{symbolSize:itemModel.get("symbolSize")||symbolSize[isFrom?0:1],symbol:itemModel.get("symbol",!0)||symbolType[isFrom?0:1],color:itemModel.get("itemStyle.normal.color")||seriesData.getVisual("color")})}var coordSys=seriesModel.coordinateSystem,seriesName=seriesModel.name,seriesData=seriesModel.getData(),lineDrawMap=this._markLineMap,lineDraw=lineDrawMap[seriesName];lineDraw||(lineDraw=lineDrawMap[seriesName]=new LineDraw),this.group.add(lineDraw.group);var mlData=createList(coordSys,seriesModel,mlModel),fromData=mlData.from,toData=mlData.to,lineData=mlData.line;mlModel.__from=fromData,mlModel.__to=toData,
// Line data for tooltip and formatter
zrUtil.extend(mlModel,markLineFormatMixin),mlModel.setData(lineData);var symbolType=mlModel.get("symbol"),symbolSize=mlModel.get("symbolSize");zrUtil.isArray(symbolType)||(symbolType=[symbolType,symbolType]),"number"==typeof symbolSize&&(symbolSize=[symbolSize,symbolSize]),
// Update visual and layout of from symbol and to symbol
mlData.from.each(function(idx){var lineModel=lineData.getItemModel(idx),mlType=lineModel.get("type"),valueIndex=lineModel.get("valueIndex");updateDataVisualAndLayout(fromData,idx,!0,mlType,valueIndex),updateDataVisualAndLayout(toData,idx,!1,mlType,valueIndex)}),
// Update visual and layout of line
lineData.each(function(idx){var lineColor=lineData.getItemModel(idx).get("lineStyle.normal.color");lineData.setItemVisual(idx,{color:lineColor||fromData.getItemVisual(idx,"color")}),lineData.setItemLayout(idx,[fromData.getItemLayout(idx),toData.getItemLayout(idx)])}),lineDraw.updateData(lineData,fromData,toData),
// Set host model for tooltip
// FIXME
mlData.line.eachItemGraphicEl(function(el,idx){el.traverse(function(child){child.dataModel=mlModel})}),lineDraw.__keep=!0}})},/* 322 */
/***/
function(module,exports,__webpack_require__){/**
	 * DataZoom component entry
	 */
var echarts=__webpack_require__(1);echarts.registerPreprocessor(__webpack_require__(323)),__webpack_require__(324),__webpack_require__(325),__webpack_require__(326),__webpack_require__(328)},/* 323 */
/***/
function(module,exports,__webpack_require__){function compatibleEC2(opt){var type=opt.type,ec2Types={number:"value",time:"time"};if(
// Compatible with ec2
ec2Types[type]&&(opt.axisType=ec2Types[type],delete opt.type),transferItem(opt),has(opt,"controlPosition")){var controlStyle=opt.controlStyle||(opt.controlStyle={});has(controlStyle,"position")||(controlStyle.position=opt.controlPosition),"none"!==controlStyle.position||has(controlStyle,"show")||(controlStyle.show=!1,delete controlStyle.position),delete opt.controlPosition}zrUtil.each(opt.data||[],function(dataItem){zrUtil.isObject(dataItem)&&!zrUtil.isArray(dataItem)&&(!has(dataItem,"value")&&has(dataItem,"name")&&(
// In ec2, using name as value.
dataItem.value=dataItem.name),transferItem(dataItem))})}function transferItem(opt){var itemStyle=opt.itemStyle||(opt.itemStyle={}),itemStyleEmphasis=itemStyle.emphasis||(itemStyle.emphasis={}),label=opt.label||opt.label||{},labelNormal=label.normal||(label.normal={}),excludeLabelAttr={normal:1,emphasis:1};zrUtil.each(label,function(value,name){excludeLabelAttr[name]||has(labelNormal,name)||(labelNormal[name]=value)}),itemStyleEmphasis.label&&!has(label,"emphasis")&&(label.emphasis=itemStyleEmphasis.label,delete itemStyleEmphasis.label)}function has(obj,attr){return obj.hasOwnProperty(attr)}/**
	 * @file Timeline preprocessor
	 */
var zrUtil=__webpack_require__(3);module.exports=function(option){var timelineOpt=option&&option.timeline;zrUtil.isArray(timelineOpt)||(timelineOpt=timelineOpt?[timelineOpt]:[]),zrUtil.each(timelineOpt,function(opt){opt&&compatibleEC2(opt)})}},/* 324 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(19).registerSubTypeDefaulter("timeline",function(){
// Only slider now.
return"slider"})},/* 325 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Timeilne action
	 */
var echarts=__webpack_require__(1);echarts.registerAction({type:"timelineChange",event:"timelineChanged",update:"prepareAndUpdate"},function(payload,ecModel){var timelineModel=ecModel.getComponent("timeline");timelineModel&&null!=payload.currentIndex&&(timelineModel.setCurrentIndex(payload.currentIndex),!timelineModel.get("loop",!0)&&timelineModel.isIndexMax()&&timelineModel.setPlayState(!1)),ecModel.resetOption("timeline")}),echarts.registerAction({type:"timelinePlayChange",event:"timelinePlayChanged",update:"update"},function(payload,ecModel){var timelineModel=ecModel.getComponent("timeline");timelineModel&&null!=payload.playState&&timelineModel.setPlayState(payload.playState)})},/* 326 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Silder timeline model
	 */
var TimelineModel=__webpack_require__(327);module.exports=TimelineModel.extend({type:"timeline.slider",/**
	         * @protected
	         */
defaultOption:{backgroundColor:"rgba(0,0,0,0)",// 时间轴背景颜色
borderColor:"#ccc",// 时间轴边框颜色
borderWidth:0,// 时间轴边框线宽，单位px，默认为0（无边框）
orient:"horizontal",// 'vertical'
inverse:!1,tooltip:{// boolean or Object
trigger:"item"},symbol:"emptyCircle",symbolSize:10,lineStyle:{show:!0,width:2,color:"#304654"},label:{// 文本标签
position:"auto",// auto left right top bottom
// When using number, label position is not
// restricted by viewRect.
// positive: right/bottom, negative: left/top
normal:{show:!0,interval:"auto",rotate:0,
// formatter: null,
textStyle:{// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:"#304654"}},emphasis:{show:!0,textStyle:{// 其余属性默认使用全局文本样式，详见TEXTSTYLE
color:"#c23531"}}},itemStyle:{normal:{color:"#304654",borderWidth:1},emphasis:{color:"#c23531"}},checkpointStyle:{symbol:"circle",symbolSize:13,color:"#c23531",borderWidth:5,borderColor:"rgba(194,53,49, 0.5)",animation:!0,animationDuration:300,animationEasing:"quinticInOut"},controlStyle:{show:!0,showPlayBtn:!0,showPrevBtn:!0,showNextBtn:!0,itemSize:22,itemGap:12,position:"left",// 'left' 'right' 'top' 'bottom'
playIcon:"path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",// jshint ignore:line
stopIcon:"path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",// jshint ignore:line
nextIcon:"path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",// jshint ignore:line
prevIcon:"path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",// jshint ignore:line
normal:{color:"#304654",borderColor:"#304654",borderWidth:1},emphasis:{color:"#c23531",borderColor:"#c23531",borderWidth:2}},data:[]}})},/* 327 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Timeline model
	 */
var ComponentModel=__webpack_require__(19),List=__webpack_require__(94),zrUtil=__webpack_require__(3),modelUtil=__webpack_require__(5),TimelineModel=ComponentModel.extend({type:"timeline",layoutMode:"box",/**
	         * @protected
	         */
defaultOption:{zlevel:0,// 一级层叠
z:4,// 二级层叠
show:!0,axisType:"time",// 模式是时间类型，支持 value, category
realtime:!0,left:"20%",top:null,right:"20%",bottom:0,width:null,height:40,padding:5,controlPosition:"left",// 'left' 'right' 'top' 'bottom' 'none'
autoPlay:!1,rewind:!1,// 反向播放
loop:!0,playInterval:2e3,// 播放时间间隔，单位ms
currentIndex:0,itemStyle:{normal:{},emphasis:{}},label:{normal:{textStyle:{color:"#000"}},emphasis:{}},data:[]},/**
	         * @override
	         */
init:function(option,parentModel,ecModel){/**
	             * @private
	             * @type {module:echarts/data/List}
	             */
this._data,/**
	             * @private
	             * @type {Array.<string>}
	             */
this._names,this.mergeDefaultAndTheme(option,ecModel),this._initData()},/**
	         * @override
	         */
mergeOption:function(option){TimelineModel.superApply(this,"mergeOption",arguments),this._initData()},/**
	         * @param {number} [currentIndex]
	         */
setCurrentIndex:function(currentIndex){null==currentIndex&&(currentIndex=this.option.currentIndex);var count=this._data.count();this.option.loop?currentIndex=(currentIndex%count+count)%count:(currentIndex>=count&&(currentIndex=count-1),0>currentIndex&&(currentIndex=0)),this.option.currentIndex=currentIndex},/**
	         * @return {number} currentIndex
	         */
getCurrentIndex:function(){return this.option.currentIndex},/**
	         * @return {boolean}
	         */
isIndexMax:function(){return this.getCurrentIndex()>=this._data.count()-1},/**
	         * @param {boolean} state true: play, false: stop
	         */
setPlayState:function(state){this.option.autoPlay=!!state},/**
	         * @return {boolean} true: play, false: stop
	         */
getPlayState:function(){return!!this.option.autoPlay},/**
	         * @private
	         */
_initData:function(){var thisOption=this.option,dataArr=thisOption.data||[],axisType=thisOption.axisType,names=this._names=[];if("category"===axisType){var idxArr=[];zrUtil.each(dataArr,function(item,index){var newItem,value=modelUtil.getDataItemValue(item);zrUtil.isObject(item)?(newItem=zrUtil.clone(item),newItem.value=index):newItem=index,idxArr.push(newItem),zrUtil.isString(value)||null!=value&&!isNaN(value)||(value=""),names.push(value+"")}),dataArr=idxArr}var dimType={category:"ordinal",time:"time"}[axisType]||"number",data=this._data=new List([{name:"value",type:dimType}],this);data.initData(dataArr,names)},getData:function(){return this._data},/**
	         * @public
	         * @return {Array.<string>} categoreis
	         */
getCategories:function(){return"category"===this.get("axisType")?this._names.slice():void 0}});module.exports=TimelineModel},/* 328 */
/***/
function(module,exports,__webpack_require__){function getViewRect(model,api){return layout.getLayoutRect(model.getBoxLayoutParams(),{width:api.getWidth(),height:api.getHeight()},model.get("padding"))}function makeIcon(timelineModel,objPath,rect,opts){var icon=graphic.makePath(timelineModel.get(objPath).replace(/^path:\/\//,""),zrUtil.clone(opts||{}),new BoundingRect(rect[0],rect[1],rect[2],rect[3]),"center");return icon}/**
	     * Create symbol or update symbol
	     */
function giveSymbol(hostModel,itemStyleModel,group,opt,symbol,callback){var symbolType=hostModel.get("symbol"),color=itemStyleModel.get("color"),symbolSize=hostModel.get("symbolSize"),halfSymbolSize=symbolSize/2,itemStyle=itemStyleModel.getItemStyle(["color","symbol","symbolSize"]);// Group may be new, also need to add.
return symbol?(symbol.setStyle(itemStyle),symbol.setColor(color),group.add(symbol),callback&&callback.onUpdate(symbol)):(symbol=symbolUtil.createSymbol(symbolType,-halfSymbolSize,-halfSymbolSize,symbolSize,symbolSize,color),group.add(symbol),callback&&callback.onCreate(symbol)),opt=zrUtil.merge({rectHover:!0,style:itemStyle,z2:100},opt,!0),symbol.attr(opt),symbol}function pointerMoveTo(pointer,dataIndex,axis,timelineModel,noAnimation){if(!pointer.dragging){var pointerModel=timelineModel.getModel("checkpointStyle"),toCoord=axis.dataToCoord(timelineModel.getData().get(["value"],dataIndex));noAnimation||!pointerModel.get("animation",!0)?pointer.attr({position:[toCoord,0]}):(pointer.stopAnimation(!0),pointer.animateTo({position:[toCoord,0]},pointerModel.get("animationDuration",!0),pointerModel.get("animationEasing",!0)))}}/**
	 * @file Silder timeline view
	 */
var zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),layout=__webpack_require__(21),TimelineView=__webpack_require__(329),TimelineAxis=__webpack_require__(330),symbolUtil=__webpack_require__(100),axisHelper=__webpack_require__(108),BoundingRect=__webpack_require__(15),matrix=__webpack_require__(17),numberUtil=__webpack_require__(7),modelUtil=__webpack_require__(5),formatUtil=__webpack_require__(6),encodeHTML=formatUtil.encodeHTML,bind=zrUtil.bind,each=zrUtil.each,PI=Math.PI;module.exports=TimelineView.extend({type:"timeline.slider",init:function(ecModel,api){this.api=api,/**
	             * @private
	             * @type {module:echarts/component/timeline/TimelineAxis}
	             */
this._axis,/**
	             * @private
	             * @type {module:zrender/core/BoundingRect}
	             */
this._viewRect,/**
	             * @type {number}
	             */
this._timer,/**
	             * @type {module:zrende/Element}
	             */
this._currentPointer,/**
	             * @type {module:zrender/container/Group}
	             */
this._mainGroup,/**
	             * @type {module:zrender/container/Group}
	             */
this._labelGroup},/**
	         * @override
	         */
render:function(timelineModel,ecModel,api,payload){if(this.model=timelineModel,this.api=api,this.ecModel=ecModel,this.group.removeAll(),timelineModel.get("show",!0)){var layoutInfo=this._layout(timelineModel,api),mainGroup=this._createGroup("mainGroup"),labelGroup=this._createGroup("labelGroup"),axis=this._axis=this._createAxis(layoutInfo,timelineModel);each(["AxisLine","AxisTick","Control","CurrentPointer"],function(name){this["_render"+name](layoutInfo,mainGroup,axis,timelineModel)},this),this._renderAxisLabel(layoutInfo,labelGroup,axis,timelineModel),this._position(layoutInfo,timelineModel)}this._doPlayStop()},/**
	         * @override
	         */
remove:function(){this._clearTimer(),this.group.removeAll()},/**
	         * @override
	         */
dispose:function(){this._clearTimer()},_layout:function(timelineModel,api){var labelPosOpt=timelineModel.get("label.normal.position"),orient=timelineModel.get("orient"),viewRect=getViewRect(timelineModel,api);
// Auto label offset.
null==labelPosOpt||"auto"===labelPosOpt?labelPosOpt="horizontal"===orient?viewRect.y+viewRect.height/2<api.getHeight()/2?"-":"+":viewRect.x+viewRect.width/2<api.getWidth()/2?"+":"-":isNaN(labelPosOpt)&&(labelPosOpt={horizontal:{top:"-",bottom:"+"},vertical:{left:"-",right:"+"}}[orient][labelPosOpt]);
// FIXME
// 暂没有实现用户传入
// var labelAlign = timelineModel.get('label.normal.textStyle.align');
// var labelBaseline = timelineModel.get('label.normal.textStyle.baseline');
var labelAlignMap={horizontal:"center",vertical:labelPosOpt>=0||"+"===labelPosOpt?"left":"right"},labelBaselineMap={horizontal:labelPosOpt>=0||"+"===labelPosOpt?"top":"bottom",vertical:"middle"},rotationMap={horizontal:0,vertical:PI/2},mainLength="vertical"===orient?viewRect.height:viewRect.width,controlModel=timelineModel.getModel("controlStyle"),showControl=controlModel.get("show"),controlSize=showControl?controlModel.get("itemSize"):0,controlGap=showControl?controlModel.get("itemGap"):0,sizePlusGap=controlSize+controlGap,labelRotation=timelineModel.get("label.normal.rotate")||0;labelRotation=labelRotation*PI/180;// To radian.
var playPosition,prevBtnPosition,nextBtnPosition,axisExtent,controlPosition=controlModel.get("position",!0),showControl=controlModel.get("show",!0),showPlayBtn=showControl&&controlModel.get("showPlayBtn",!0),showPrevBtn=showControl&&controlModel.get("showPrevBtn",!0),showNextBtn=showControl&&controlModel.get("showNextBtn",!0),xLeft=0,xRight=mainLength;
// position[0] means left, position[1] means middle.
// 'top' 'right'
return"left"===controlPosition||"bottom"===controlPosition?(showPlayBtn&&(playPosition=[0,0],xLeft+=sizePlusGap),showPrevBtn&&(prevBtnPosition=[xLeft,0],xLeft+=sizePlusGap),showNextBtn&&(nextBtnPosition=[xRight-controlSize,0],xRight-=sizePlusGap)):(showPlayBtn&&(playPosition=[xRight-controlSize,0],xRight-=sizePlusGap),showPrevBtn&&(prevBtnPosition=[0,0],xLeft+=sizePlusGap),showNextBtn&&(nextBtnPosition=[xRight-controlSize,0],xRight-=sizePlusGap)),axisExtent=[xLeft,xRight],timelineModel.get("inverse")&&axisExtent.reverse(),{viewRect:viewRect,mainLength:mainLength,orient:orient,rotation:rotationMap[orient],labelRotation:labelRotation,labelPosOpt:labelPosOpt,labelAlign:labelAlignMap[orient],labelBaseline:labelBaselineMap[orient],playPosition:playPosition,prevBtnPosition:prevBtnPosition,nextBtnPosition:nextBtnPosition,axisExtent:axisExtent,controlSize:controlSize,controlGap:controlGap}},_position:function(layoutInfo,timelineModel){function setOrigin(targetGroup){var pos=targetGroup.position;targetGroup.origin=[viewBound[0][0]-pos[0],viewBound[1][0]-pos[1]]}function getBound(rect){
// [[xmin, xmax], [ymin, ymax]]
return[[rect.x,rect.x+rect.width],[rect.y,rect.y+rect.height]]}function toBound(fromPos,from,to,dimIdx,boundIdx){fromPos[dimIdx]+=to[dimIdx][boundIdx]-from[dimIdx][boundIdx]}
// Position is be called finally, because bounding rect is needed for
// adapt content to fill viewRect (auto adapt offset).
// Timeline may be not all in the viewRect when 'offset' is specified
// as a number, because it is more appropriate that label aligns at
// 'offset' but not the other edge defined by viewRect.
var mainGroup=this._mainGroup,labelGroup=this._labelGroup,viewRect=layoutInfo.viewRect;if("vertical"===layoutInfo.orient){
// transfrom to horizontal, inverse rotate by left-top point.
var m=matrix.create(),rotateOriginX=viewRect.x,rotateOriginY=viewRect.y+viewRect.height;matrix.translate(m,m,[-rotateOriginX,-rotateOriginY]),matrix.rotate(m,m,-PI/2),matrix.translate(m,m,[rotateOriginX,rotateOriginY]),viewRect=viewRect.clone(),viewRect.applyTransform(m)}var viewBound=getBound(viewRect),mainBound=getBound(mainGroup.getBoundingRect()),labelBound=getBound(labelGroup.getBoundingRect()),mainPosition=mainGroup.position,labelsPosition=labelGroup.position;labelsPosition[0]=mainPosition[0]=viewBound[0][0];var labelPosOpt=layoutInfo.labelPosOpt;if(isNaN(labelPosOpt)){// '+' or '-'
var mainBoundIdx="+"===labelPosOpt?0:1;toBound(mainPosition,mainBound,viewBound,1,mainBoundIdx),toBound(labelsPosition,labelBound,viewBound,1,1-mainBoundIdx)}else{var mainBoundIdx=labelPosOpt>=0?0:1;toBound(mainPosition,mainBound,viewBound,1,mainBoundIdx),labelsPosition[1]=mainPosition[1]+labelPosOpt}mainGroup.position=mainPosition,labelGroup.position=labelsPosition,mainGroup.rotation=labelGroup.rotation=layoutInfo.rotation,setOrigin(mainGroup),setOrigin(labelGroup)},_createAxis:function(layoutInfo,timelineModel){var data=timelineModel.getData(),axisType=timelineModel.get("axisType"),scale=axisHelper.createScaleByModel(timelineModel,axisType),dataExtent=data.getDataExtent("value");scale.setExtent(dataExtent[0],dataExtent[1]),this._customizeScale(scale,data),scale.niceTicks();var axis=new TimelineAxis("value",scale,layoutInfo.axisExtent,axisType);return axis.model=timelineModel,axis},_customizeScale:function(scale,data){scale.getTicks=function(){return data.mapArray(["value"],function(value){return value})},scale.getTicksLabels=function(){return zrUtil.map(this.getTicks(),scale.getLabel,scale)}},_createGroup:function(name){var newGroup=this["_"+name]=new graphic.Group;return this.group.add(newGroup),newGroup},_renderAxisLine:function(layoutInfo,group,axis,timelineModel){var axisExtent=axis.getExtent();timelineModel.get("lineStyle.show")&&group.add(new graphic.Line({shape:{x1:axisExtent[0],y1:0,x2:axisExtent[1],y2:0},style:zrUtil.extend({lineCap:"round"},timelineModel.getModel("lineStyle").getLineStyle()),silent:!0,z2:1}))},/**
	         * @private
	         */
_renderAxisTick:function(layoutInfo,group,axis,timelineModel){var data=timelineModel.getData(),ticks=axis.scale.getTicks(),tooltipHostModel=this._prepareTooltipHostModel(data,timelineModel);each(ticks,function(value,dataIndex){var tickCoord=axis.dataToCoord(value),itemModel=data.getItemModel(dataIndex),itemStyleModel=itemModel.getModel("itemStyle.normal"),hoverStyleModel=itemModel.getModel("itemStyle.emphasis"),symbolOpt={position:[tickCoord,0],onclick:bind(this._changeTimeline,this,dataIndex)},el=giveSymbol(itemModel,itemStyleModel,group,symbolOpt);graphic.setHoverStyle(el,hoverStyleModel.getItemStyle()),itemModel.get("tooltip")?(el.dataIndex=dataIndex,el.dataModel=tooltipHostModel):el.dataIndex=el.dataModel=null},this)},/**
	         * @private
	         */
_prepareTooltipHostModel:function(data,timelineModel){var tooltipHostModel=modelUtil.createDataFormatModel({},data,timelineModel.get("data")),me=this;return tooltipHostModel.formatTooltip=function(dataIndex){return encodeHTML(me._axis.scale.getLabel(dataIndex))},tooltipHostModel},/**
	         * @private
	         */
_renderAxisLabel:function(layoutInfo,group,axis,timelineModel){var labelModel=timelineModel.getModel("label.normal");if(labelModel.get("show")){var data=timelineModel.getData(),ticks=axis.scale.getTicks(),labels=axisHelper.getFormattedLabels(axis,labelModel.get("formatter")),labelInterval=axis.getLabelInterval();each(ticks,function(tick,dataIndex){if(!axis.isLabelIgnored(dataIndex,labelInterval)){var itemModel=data.getItemModel(dataIndex),itemTextStyleModel=itemModel.getModel("label.normal.textStyle"),hoverTextStyleModel=itemModel.getModel("label.emphasis.textStyle"),tickCoord=axis.dataToCoord(tick),textEl=new graphic.Text({style:{text:labels[dataIndex],textAlign:layoutInfo.labelAlign,textVerticalAlign:layoutInfo.labelBaseline,textFont:itemTextStyleModel.getFont(),fill:itemTextStyleModel.getTextColor()},position:[tickCoord,0],rotation:layoutInfo.labelRotation-layoutInfo.rotation,onclick:bind(this._changeTimeline,this,dataIndex),silent:!1});group.add(textEl),graphic.setHoverStyle(textEl,hoverTextStyleModel.getItemStyle())}},this)}},/**
	         * @private
	         */
_renderControl:function(layoutInfo,group,axis,timelineModel){function makeBtn(position,iconPath,onclick,willRotate){if(position){var opt={position:position,origin:[controlSize/2,0],rotation:willRotate?-rotation:0,rectHover:!0,style:itemStyle,onclick:onclick},btn=makeIcon(timelineModel,iconPath,rect,opt);group.add(btn),graphic.setHoverStyle(btn,hoverStyle)}}var controlSize=layoutInfo.controlSize,rotation=layoutInfo.rotation,itemStyle=timelineModel.getModel("controlStyle.normal").getItemStyle(),hoverStyle=timelineModel.getModel("controlStyle.emphasis").getItemStyle(),rect=[0,-controlSize/2,controlSize,controlSize],playState=timelineModel.getPlayState(),inverse=timelineModel.get("inverse",!0);makeBtn(layoutInfo.nextBtnPosition,"controlStyle.nextIcon",bind(this._changeTimeline,this,inverse?"-":"+")),makeBtn(layoutInfo.prevBtnPosition,"controlStyle.prevIcon",bind(this._changeTimeline,this,inverse?"+":"-")),makeBtn(layoutInfo.playPosition,"controlStyle."+(playState?"stopIcon":"playIcon"),bind(this._handlePlayClick,this,!playState),!0)},_renderCurrentPointer:function(layoutInfo,group,axis,timelineModel){var data=timelineModel.getData(),currentIndex=timelineModel.getCurrentIndex(),pointerModel=data.getItemModel(currentIndex).getModel("checkpointStyle"),me=this,callback={onCreate:function(pointer){pointer.draggable=!0,pointer.drift=bind(me._handlePointerDrag,me),pointer.ondragend=bind(me._handlePointerDragend,me),pointerMoveTo(pointer,currentIndex,axis,timelineModel,!0)},onUpdate:function(pointer){pointerMoveTo(pointer,currentIndex,axis,timelineModel)}};
// Reuse when exists, for animation and drag.
this._currentPointer=giveSymbol(pointerModel,pointerModel,this._mainGroup,{},this._currentPointer,callback)},_handlePlayClick:function(nextState){this._clearTimer(),this.api.dispatchAction({type:"timelinePlayChange",playState:nextState,from:this.uid})},_handlePointerDrag:function(dx,dy,e){this._clearTimer(),this._pointerChangeTimeline([e.offsetX,e.offsetY])},_handlePointerDragend:function(e){this._pointerChangeTimeline([e.offsetX,e.offsetY],!0)},_pointerChangeTimeline:function(mousePos,trigger){var toCoord=this._toAxisCoord(mousePos)[0],axis=this._axis,axisExtent=numberUtil.asc(axis.getExtent().slice());toCoord>axisExtent[1]&&(toCoord=axisExtent[1]),toCoord<axisExtent[0]&&(toCoord=axisExtent[0]),this._currentPointer.position[0]=toCoord,this._currentPointer.dirty();var targetDataIndex=this._findNearestTick(toCoord),timelineModel=this.model;(trigger||targetDataIndex!==timelineModel.getCurrentIndex()&&timelineModel.get("realtime"))&&this._changeTimeline(targetDataIndex)},_doPlayStop:function(){function handleFrame(){
// Do not cache
var timelineModel=this.model;this._changeTimeline(timelineModel.getCurrentIndex()+(timelineModel.get("rewind",!0)?-1:1))}this._clearTimer(),this.model.getPlayState()&&(this._timer=setTimeout(bind(handleFrame,this),this.model.get("playInterval")))},_toAxisCoord:function(vertex){var trans=this._mainGroup.getLocalTransform();return graphic.applyTransform(vertex,trans,!0)},_findNearestTick:function(axisCoord){var targetDataIndex,data=this.model.getData(),dist=1/0,axis=this._axis;return data.each(["value"],function(value,dataIndex){var coord=axis.dataToCoord(value),d=Math.abs(coord-axisCoord);dist>d&&(dist=d,targetDataIndex=dataIndex)}),targetDataIndex},_clearTimer:function(){this._timer&&(clearTimeout(this._timer),this._timer=null)},_changeTimeline:function(nextIndex){var currentIndex=this.model.getCurrentIndex();"+"===nextIndex?nextIndex=currentIndex+1:"-"===nextIndex&&(nextIndex=currentIndex-1),this.api.dispatchAction({type:"timelineChange",currentIndex:nextIndex,from:this.uid})}})},/* 329 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Timeline view
	 */
// var zrUtil = require('zrender/lib/core/util');
// var graphic = require('../../util/graphic');
var ComponentView=__webpack_require__(28);module.exports=ComponentView.extend({type:"timeline"})},/* 330 */
/***/
function(module,exports,__webpack_require__){var zrUtil=__webpack_require__(3),Axis=__webpack_require__(117),axisHelper=__webpack_require__(108),TimelineAxis=function(dim,scale,coordExtent,axisType){Axis.call(this,dim,scale,coordExtent),/**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
this.type=axisType||"value",/**
	         * @private
	         * @type {number}
	         */
this._autoLabelInterval,/**
	         * Axis model
	         * @param {module:echarts/component/TimelineModel}
	         */
this.model=null};TimelineAxis.prototype={constructor:TimelineAxis,/**
	         * @public
	         * @return {number}
	         */
getLabelInterval:function(){var timelineModel=this.model,labelModel=timelineModel.getModel("label.normal"),labelInterval=labelModel.get("interval");if(null!=labelInterval&&"auto"!=labelInterval)return labelInterval;var labelInterval=this._autoLabelInterval;return labelInterval||(labelInterval=this._autoLabelInterval=axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(),this.dataToCoord,this),axisHelper.getFormattedLabels(this,labelModel.get("formatter")),labelModel.getModel("textStyle").getFont(),"horizontal"===timelineModel.get("orient"))),labelInterval},/**
	         * If label is ignored.
	         * Automatically used when axis is category and label can not be all shown
	         * @public
	         * @param  {number} idx
	         * @return {boolean}
	         */
isLabelIgnored:function(idx){if("category"===this.type){var labelInterval=this.getLabelInterval();return"function"==typeof labelInterval&&!labelInterval(idx,this.scale.getLabel(idx))||idx%(labelInterval+1)}}},zrUtil.inherits(TimelineAxis,Axis),module.exports=TimelineAxis},/* 331 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(332),__webpack_require__(334),__webpack_require__(336),__webpack_require__(337),__webpack_require__(338),__webpack_require__(339),__webpack_require__(344)},/* 332 */
/***/
function(module,exports,__webpack_require__){var featureManager=__webpack_require__(333),zrUtil=__webpack_require__(3),ToolboxModel=__webpack_require__(1).extendComponentModel({type:"toolbox",layoutMode:{type:"box",ignoreSize:!0},mergeDefaultAndTheme:function(option){ToolboxModel.superApply(this,"mergeDefaultAndTheme",arguments),zrUtil.each(this.option.feature,function(featureOpt,featureName){var Feature=featureManager.get(featureName);Feature&&zrUtil.merge(featureOpt,Feature.defaultOption)})},defaultOption:{show:!0,z:6,zlevel:0,orient:"horizontal",left:"right",top:"top",
// right
// bottom
backgroundColor:"transparent",borderColor:"#ccc",borderWidth:0,padding:5,itemSize:15,itemGap:8,showTitle:!0,iconStyle:{normal:{borderColor:"#666",color:"none"},emphasis:{borderColor:"#3E98C5"}}}});module.exports=ToolboxModel},/* 333 */
/***/
function(module,exports){"use strict";var features={};module.exports={register:function(name,ctor){features[name]=ctor},get:function(name){return features[name]}}},/* 334 */
/***/
function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */
(function(process){function isUserFeatureName(featureName){return 0===featureName.indexOf("my")}var featureManager=__webpack_require__(333),zrUtil=__webpack_require__(3),graphic=__webpack_require__(42),Model=__webpack_require__(8),DataDiffer=__webpack_require__(95),listComponentHelper=__webpack_require__(266),textContain=__webpack_require__(14);module.exports=__webpack_require__(1).extendComponentView({type:"toolbox",render:function(toolboxModel,ecModel,api){function process(newIndex,oldIndex){var feature,featureName=featureNames[newIndex],oldName=featureNames[oldIndex],featureOpt=featureOpts[featureName],featureModel=new Model(featureOpt,toolboxModel,toolboxModel.ecModel);if(featureName&&!oldName){// Create
if(isUserFeatureName(featureName))feature={model:featureModel,onclick:featureModel.option.onclick,featureName:featureName};else{var Feature=featureManager.get(featureName);if(!Feature)return;feature=new Feature(featureModel)}features[featureName]=feature}else{
// If feature does not exsit.
if(feature=features[oldName],!feature)return;feature.model=featureModel}return!featureName&&oldName?void(feature.dispose&&feature.dispose(ecModel,api)):!featureModel.get("show")||feature.unusable?void(feature.remove&&feature.remove(ecModel,api)):(createIconPaths(featureModel,feature,featureName),featureModel.setIconStatus=function(iconName,status){var option=this.option,iconPaths=this.iconPaths;option.iconStatus=option.iconStatus||{},option.iconStatus[iconName]=status,
// FIXME
iconPaths[iconName]&&iconPaths[iconName].trigger(status)},void(feature.render&&feature.render(featureModel,ecModel,api)))}function createIconPaths(featureModel,feature,featureName){var iconStyleModel=featureModel.getModel("iconStyle"),icons=feature.getIcons?feature.getIcons():featureModel.get("icon"),titles=featureModel.get("title")||{};if("string"==typeof icons){var icon=icons,title=titles;icons={},titles={},icons[featureName]=icon,titles[featureName]=title}var iconPaths=featureModel.iconPaths={};zrUtil.each(icons,function(icon,iconName){var normalStyle=iconStyleModel.getModel("normal").getItemStyle(),hoverStyle=iconStyleModel.getModel("emphasis").getItemStyle(),style={x:-itemSize/2,y:-itemSize/2,width:itemSize,height:itemSize},path=0===icon.indexOf("image://")?(style.image=icon.slice(8),new graphic.Image({style:style})):graphic.makePath(icon.replace("path://",""),{style:normalStyle,hoverStyle:hoverStyle,rectHover:!0},style,"center");graphic.setHoverStyle(path),toolboxModel.get("showTitle")&&(path.__title=titles[iconName],path.on("mouseover",function(){path.setStyle({text:titles[iconName],textPosition:hoverStyle.textPosition||"bottom",textFill:hoverStyle.fill||hoverStyle.stroke||"#000",textAlign:hoverStyle.textAlign||"center"})}).on("mouseout",function(){path.setStyle({textFill:null})})),path.trigger(featureModel.get("iconStatus."+iconName)||"normal"),group.add(path),path.on("click",zrUtil.bind(feature.onclick,feature,ecModel,api,iconName)),iconPaths[iconName]=path})}var group=this.group;if(group.removeAll(),toolboxModel.get("show")){var itemSize=+toolboxModel.get("itemSize"),featureOpts=toolboxModel.get("feature")||{},features=this._features||(this._features={}),featureNames=[];zrUtil.each(featureOpts,function(opt,name){featureNames.push(name)}),new DataDiffer(this._featureNames||[],featureNames).add(process).update(process).remove(zrUtil.curry(process,null)).execute(),
// Keep for diff.
this._featureNames=featureNames,listComponentHelper.layout(group,toolboxModel,api),
// Render background after group is layout
// FIXME
listComponentHelper.addBackground(group,toolboxModel),
// Adjust icon title positions to avoid them out of screen
group.eachChild(function(icon){var titleText=icon.__title,hoverStyle=icon.hoverStyle;
// May be background element
if(hoverStyle&&titleText){var rect=textContain.getBoundingRect(titleText,hoverStyle.font),offsetX=icon.position[0]+group.position[0],offsetY=icon.position[1]+group.position[1]+itemSize,needPutOnTop=!1;offsetY+rect.height>api.getHeight()&&(hoverStyle.textPosition="top",needPutOnTop=!0);var topOffset=needPutOnTop?-5-rect.height:itemSize+8;offsetX+rect.width/2>api.getWidth()?(hoverStyle.textPosition=["100%",topOffset],hoverStyle.textAlign="right"):offsetX-rect.width/2<0&&(hoverStyle.textPosition=[0,topOffset],hoverStyle.textAlign="left")}})}},remove:function(ecModel,api){zrUtil.each(this._features,function(feature){feature.remove&&feature.remove(ecModel,api)}),this.group.removeAll()},dispose:function(ecModel,api){zrUtil.each(this._features,function(feature){feature.dispose&&feature.dispose(ecModel,api)})}})}).call(exports,__webpack_require__(335))},/* 335 */
/***/
function(module,exports){function cleanUpNextTick(){draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue()}function drainQueue(){if(!draining){var timeout=setTimeout(cleanUpNextTick);draining=!0;for(var len=queue.length;len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,clearTimeout(timeout)}}
// v8 likes predictible objects
function Item(fun,array){this.fun=fun,this.array=array}function noop(){}
// shim for using process in browser
var currentQueue,process=module.exports={},queue=[],draining=!1,queueIndex=-1;process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||setTimeout(drainQueue,0)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",// empty string to avoid regexp issues
process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(name){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(dir){throw new Error("process.chdir is not supported")},process.umask=function(){return 0}},/* 336 */
/***/
function(module,exports,__webpack_require__){function SaveAsImage(model){this.model=model}var env=__webpack_require__(78);SaveAsImage.defaultOption={show:!0,icon:"M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",title:"保存为图片",type:"png",
// Default use option.backgroundColor
// backgroundColor: '#fff',
name:"",excludeComponents:["toolbox"],pixelRatio:1,lang:["右键另存为图片"]},SaveAsImage.prototype.unusable=!env.canvasSupported;var proto=SaveAsImage.prototype;proto.onclick=function(ecModel,api){var model=this.model,title=model.get("name")||ecModel.get("title.0.text")||"echarts",$a=document.createElement("a"),type=model.get("type",!0)||"png";$a.download=title+"."+type,$a.target="_blank";var url=api.getConnectedDataURL({type:type,backgroundColor:model.get("backgroundColor",!0)||ecModel.get("backgroundColor")||"#fff",excludeComponents:model.get("excludeComponents"),pixelRatio:model.get("pixelRatio")});
// Chrome and Firefox
if($a.href=url,"function"==typeof MouseEvent){var evt=new MouseEvent("click",{view:window,bubbles:!0,cancelable:!1});$a.dispatchEvent(evt)}else{var lang=model.get("lang"),html='<body style="margin:0;"><img src="'+url+'" style="max-width:100%;" title="'+(lang&&lang[0]||"")+'" /></body>',tab=window.open();tab.document.write(html)}},__webpack_require__(333).register("saveAsImage",SaveAsImage),module.exports=SaveAsImage},/* 337 */
/***/
function(module,exports,__webpack_require__){"use strict";function MagicType(model){this.model=model}var zrUtil=__webpack_require__(3);MagicType.defaultOption={show:!0,type:[],
// Icon group
icon:{line:"M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",bar:"M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",stack:"M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",// jshint ignore:line
tiled:"M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"},title:{line:"切换为折线图",bar:"切换为柱状图",stack:"切换为堆叠",tiled:"切换为平铺"},option:{},seriesIndex:{}};var proto=MagicType.prototype;proto.getIcons=function(){var model=this.model,availableIcons=model.get("icon"),icons={};return zrUtil.each(model.get("type"),function(type){availableIcons[type]&&(icons[type]=availableIcons[type])}),icons};var seriesOptGenreator={line:function(seriesType,seriesId,seriesModel,model){return"bar"===seriesType?zrUtil.merge({id:seriesId,type:"line",
// Preserve data related option
data:seriesModel.get("data"),stack:seriesModel.get("stack"),markPoint:seriesModel.get("markPoint"),markLine:seriesModel.get("markLine")},model.get("option.line")||{},!0):void 0},bar:function(seriesType,seriesId,seriesModel,model){return"line"===seriesType?zrUtil.merge({id:seriesId,type:"bar",
// Preserve data related option
data:seriesModel.get("data"),stack:seriesModel.get("stack"),markPoint:seriesModel.get("markPoint"),markLine:seriesModel.get("markLine")},model.get("option.bar")||{},!0):void 0},stack:function(seriesType,seriesId,seriesModel,model){return"line"===seriesType||"bar"===seriesType?zrUtil.merge({id:seriesId,stack:"__ec_magicType_stack__"},model.get("option.stack")||{},!0):void 0},tiled:function(seriesType,seriesId,seriesModel,model){return"line"===seriesType||"bar"===seriesType?zrUtil.merge({id:seriesId,stack:""},model.get("option.tiled")||{},!0):void 0}},radioTypes=[["line","bar"],["stack","tiled"]];proto.onclick=function(ecModel,api,type){var model=this.model,seriesIndex=model.get("seriesIndex."+type);
// Not supported magicType
if(seriesOptGenreator[type]){var newOption={series:[]},generateNewSeriesTypes=function(seriesModel){var seriesType=seriesModel.subType,seriesId=seriesModel.id,newSeriesOpt=seriesOptGenreator[type](seriesType,seriesId,seriesModel,model);newSeriesOpt&&(
// PENDING If merge original option?
zrUtil.defaults(newSeriesOpt,seriesModel.option),newOption.series.push(newSeriesOpt));
// Modify boundaryGap
var coordSys=seriesModel.coordinateSystem;if(coordSys&&"cartesian2d"===coordSys.type&&("line"===type||"bar"===type)){var categoryAxis=coordSys.getAxesByScale("ordinal")[0];if(categoryAxis){var axisDim=categoryAxis.dim,axisIndex=seriesModel.get(axisDim+"AxisIndex"),axisKey=axisDim+"Axis";newOption[axisKey]=newOption[axisKey]||[];for(var i=0;axisIndex>=i;i++)newOption[axisKey][axisIndex]=newOption[axisKey][axisIndex]||{};newOption[axisKey][axisIndex].boundaryGap="bar"===type}}};zrUtil.each(radioTypes,function(radio){zrUtil.indexOf(radio,type)>=0&&zrUtil.each(radio,function(item){model.setIconStatus(item,"normal")})}),model.setIconStatus(type,"emphasis"),ecModel.eachComponent({mainType:"series",query:null==seriesIndex?null:{seriesIndex:seriesIndex}},generateNewSeriesTypes),api.dispatchAction({type:"changeMagicType",currentType:type,newOption:newOption})}};var echarts=__webpack_require__(1);echarts.registerAction({type:"changeMagicType",event:"magicTypeChanged",update:"prepareAndUpdate"},function(payload,ecModel){ecModel.mergeOption(payload.newOption)}),__webpack_require__(333).register("magicType",MagicType),module.exports=MagicType},/* 338 */
/***/
function(module,exports,__webpack_require__){/**
	     * Group series into two types
	     *  1. on category axis, like line, bar
	     *  2. others, like scatter, pie
	     * @param {module:echarts/model/Global} ecModel
	     * @return {Object}
	     * @inner
	     */
function groupSeries(ecModel){var seriesGroupByCategoryAxis={},otherSeries=[],meta=[];return ecModel.eachRawSeries(function(seriesModel){var coordSys=seriesModel.coordinateSystem;if(!coordSys||"cartesian2d"!==coordSys.type&&"polar"!==coordSys.type)otherSeries.push(seriesModel);else{var baseAxis=coordSys.getBaseAxis();if("category"===baseAxis.type){var key=baseAxis.dim+"_"+baseAxis.index;seriesGroupByCategoryAxis[key]||(seriesGroupByCategoryAxis[key]={categoryAxis:baseAxis,valueAxis:coordSys.getOtherAxis(baseAxis),series:[]},meta.push({axisDim:baseAxis.dim,axisIndex:baseAxis.index})),seriesGroupByCategoryAxis[key].series.push(seriesModel)}else otherSeries.push(seriesModel)}}),{seriesGroupByCategoryAxis:seriesGroupByCategoryAxis,other:otherSeries,meta:meta}}/**
	     * Assemble content of series on cateogory axis
	     * @param {Array.<module:echarts/model/Series>} series
	     * @return {string}
	     * @inner
	     */
function assembleSeriesWithCategoryAxis(series){var tables=[];return zrUtil.each(series,function(group,key){var categoryAxis=group.categoryAxis,valueAxis=group.valueAxis,valueAxisDim=valueAxis.dim,headers=[" "].concat(zrUtil.map(group.series,function(series){return series.name})),columns=[categoryAxis.model.getCategories()];zrUtil.each(group.series,function(series){columns.push(series.getRawData().mapArray(valueAxisDim,function(val){return val}))});for(var lines=[headers.join(ITEM_SPLITER)],i=0;i<columns[0].length;i++){for(var items=[],j=0;j<columns.length;j++)items.push(columns[j][i]);lines.push(items.join(ITEM_SPLITER))}tables.push(lines.join("\n"))}),tables.join("\n\n"+BLOCK_SPLITER+"\n\n")}/**
	     * Assemble content of other series
	     * @param {Array.<module:echarts/model/Series>} series
	     * @return {string}
	     * @inner
	     */
function assembleOtherSeries(series){return zrUtil.map(series,function(series){var data=series.getRawData(),lines=[series.name],vals=[];return data.each(data.dimensions,function(){for(var argLen=arguments.length,dataIndex=arguments[argLen-1],name=data.getName(dataIndex),i=0;argLen-1>i;i++)vals[i]=arguments[i];lines.push((name?name+ITEM_SPLITER:"")+vals.join(ITEM_SPLITER))}),lines.join("\n")}).join("\n\n"+BLOCK_SPLITER+"\n\n")}/**
	     * @param {module:echarts/model/Global}
	     * @return {string}
	     * @inner
	     */
function getContentFromModel(ecModel){var result=groupSeries(ecModel);return{value:zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),assembleOtherSeries(result.other)],function(str){return str.replace(/[\n\t\s]/g,"")}).join("\n\n"+BLOCK_SPLITER+"\n\n"),meta:result.meta}}function trim(str){return str.replace(/^\s\s*/,"").replace(/\s\s*$/,"")}/**
	     * If a block is tsv format
	     */
function isTSVFormat(block){
// Simple method to find out if a block is tsv format
var firstLine=block.slice(0,block.indexOf("\n"));return firstLine.indexOf(ITEM_SPLITER)>=0?!0:void 0}/**
	     * @param {string} tsv
	     * @return {Array.<Object>}
	     */
function parseTSVContents(tsv){for(var tsvLines=tsv.split(/\n+/g),headers=trim(tsvLines.shift()).split(itemSplitRegex),categories=[],series=zrUtil.map(headers,function(header){return{name:header,data:[]}}),i=0;i<tsvLines.length;i++){var items=trim(tsvLines[i]).split(itemSplitRegex);categories.push(items.shift());for(var j=0;j<items.length;j++)series[j]&&(series[j].data[i]=items[j])}return{series:series,categories:categories}}/**
	     * @param {string} str
	     * @return {Array.<Object>}
	     * @inner
	     */
function parseListContents(str){for(var lines=str.split(/\n+/g),seriesName=trim(lines.shift()),data=[],i=0;i<lines.length;i++){var value,items=trim(lines[i]).split(itemSplitRegex),name="",hasName=!1;isNaN(items[0])?(hasName=!0,name=items[0],items=items.slice(1),data[i]={name:name,value:[]},value=data[i].value):value=data[i]=[];for(var j=0;j<items.length;j++)value.push(+items[j]);1===value.length&&(hasName?data[i].value=value[0]:data[i]=value[0])}return{name:seriesName,data:data}}/**
	     * @param {string} str
	     * @param {Array.<Object>} blockMetaList
	     * @return {Object}
	     * @inner
	     */
function parseContents(str,blockMetaList){var blocks=str.split(new RegExp("\n*"+BLOCK_SPLITER+"\n*","g")),newOption={series:[]};return zrUtil.each(blocks,function(block,idx){if(isTSVFormat(block)){var result=parseTSVContents(block),blockMeta=blockMetaList[idx],axisKey=blockMeta.axisDim+"Axis";blockMeta&&(newOption[axisKey]=newOption[axisKey]||[],newOption[axisKey][blockMeta.axisIndex]={data:result.categories},newOption.series=newOption.series.concat(result.series))}else{var result=parseListContents(block);newOption.series.push(result)}}),newOption}/**
	     * @alias {module:echarts/component/toolbox/feature/DataView}
	     * @constructor
	     * @param {module:echarts/model/Model} model
	     */
function DataView(model){this._dom=null,this.model=model}/**
	     * @inner
	     */
function tryMergeDataOption(newData,originalData){return zrUtil.map(newData,function(newVal,idx){var original=originalData&&originalData[idx];return zrUtil.isObject(original)&&!zrUtil.isArray(original)?(zrUtil.isObject(newVal)&&!zrUtil.isArray(newVal)&&(newVal=newVal.value),zrUtil.defaults({value:newVal},original)):newVal})}/**
	 * @module echarts/component/toolbox/feature/DataView
	 */
var zrUtil=__webpack_require__(3),eventTool=__webpack_require__(80),BLOCK_SPLITER=new Array(60).join("-"),ITEM_SPLITER="	",itemSplitRegex=new RegExp("["+ITEM_SPLITER+"]+","g");DataView.defaultOption={show:!0,readOnly:!1,optionToContent:null,contentToOption:null,icon:"M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",title:"数据视图",lang:["数据视图","关闭","刷新"],backgroundColor:"#fff",textColor:"#000",textareaColor:"#fff",textareaBorderColor:"#333",buttonColor:"#c23531",buttonTextColor:"#fff"},DataView.prototype.onclick=function(ecModel,api){function close(){container.removeChild(root),self._dom=null}var container=api.getDom(),model=this.model;this._dom&&container.removeChild(this._dom);var root=document.createElement("div");root.style.cssText="position:absolute;left:5px;top:5px;bottom:5px;right:5px;",root.style.backgroundColor=model.get("backgroundColor")||"#fff";
// Create elements
var header=document.createElement("h4"),lang=model.get("lang")||[];header.innerHTML=lang[0]||model.get("title"),header.style.cssText="margin: 10px 20px;",header.style.color=model.get("textColor");var viewMain=document.createElement("div"),textarea=document.createElement("textarea");viewMain.style.cssText="display:block;width:100%;overflow:hidden;";var optionToContent=model.get("optionToContent"),contentToOption=model.get("contentToOption"),result=getContentFromModel(ecModel);if("function"==typeof optionToContent){var htmlOrDom=optionToContent(api.getOption());"string"==typeof htmlOrDom?viewMain.innerHTML=htmlOrDom:zrUtil.isDom(htmlOrDom)&&viewMain.appendChild(htmlOrDom)}else
// Use default textarea
viewMain.appendChild(textarea),textarea.readOnly=model.get("readOnly"),textarea.style.cssText="width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;",textarea.style.color=model.get("textColor"),textarea.style.borderColor=model.get("textareaBorderColor"),textarea.style.backgroundColor=model.get("textareaColor"),textarea.value=result.value;var blockMetaList=result.meta,buttonContainer=document.createElement("div");buttonContainer.style.cssText="position:absolute;bottom:0;left:0;right:0;";var buttonStyle="float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",closeButton=document.createElement("div"),refreshButton=document.createElement("div");buttonStyle+=";background-color:"+model.get("buttonColor"),buttonStyle+=";color:"+model.get("buttonTextColor");var self=this;eventTool.addEventListener(closeButton,"click",close),eventTool.addEventListener(refreshButton,"click",function(){var newOption;try{newOption="function"==typeof contentToOption?contentToOption(viewMain,api.getOption()):parseContents(textarea.value,blockMetaList)}catch(e){throw close(),new Error("Data view format error "+e)}newOption&&api.dispatchAction({type:"changeDataView",newOption:newOption}),close()}),closeButton.innerHTML=lang[1],refreshButton.innerHTML=lang[2],refreshButton.style.cssText=buttonStyle,closeButton.style.cssText=buttonStyle,!model.get("readOnly")&&buttonContainer.appendChild(refreshButton),buttonContainer.appendChild(closeButton),
// http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
eventTool.addEventListener(textarea,"keydown",function(e){if(9===(e.keyCode||e.which)){
// get caret position/selection
var val=this.value,start=this.selectionStart,end=this.selectionEnd;
// set textarea value to: text before caret + tab + text after caret
this.value=val.substring(0,start)+ITEM_SPLITER+val.substring(end),
// put caret at right position again
this.selectionStart=this.selectionEnd=start+1,
// prevent the focus lose
eventTool.stop(e)}}),root.appendChild(header),root.appendChild(viewMain),root.appendChild(buttonContainer),viewMain.style.height=container.clientHeight-80+"px",container.appendChild(root),this._dom=root},DataView.prototype.remove=function(ecModel,api){this._dom&&api.getDom().removeChild(this._dom)},DataView.prototype.dispose=function(ecModel,api){this.remove(ecModel,api)},__webpack_require__(333).register("dataView",DataView),__webpack_require__(1).registerAction({type:"changeDataView",event:"dataViewChanged",update:"prepareAndUpdate"},function(payload,ecModel){var newSeriesOptList=[];zrUtil.each(payload.newOption.series,function(seriesOpt){var seriesModel=ecModel.getSeriesByName(seriesOpt.name)[0];if(seriesModel){var originalData=seriesModel.get("data");newSeriesOptList.push({name:seriesOpt.name,data:tryMergeDataOption(seriesOpt.data,originalData)})}else
// New created series
// Geuss the series type
newSeriesOptList.push(zrUtil.extend({
// Default is scatter
type:"scatter"},seriesOpt))}),ecModel.mergeOption(zrUtil.defaults({series:newSeriesOptList},payload.newOption))}),module.exports=DataView},/* 339 */
/***/
function(module,exports,__webpack_require__){"use strict";function DataZoom(model){this.model=model,/**
	         * @private
	         * @type {module:zrender/container/Group}
	         */
this._controllerGroup,/**
	         * @private
	         * @type {module:echarts/component/helper/SelectController}
	         */
this._controller,/**
	         * Is zoom active.
	         * @private
	         * @type {Object}
	         */
this._isZoomActive}function prepareCoordInfo(grid,ecModel){
// Default use the first axis.
// FIXME
var coordInfo=[{axisModel:grid.getAxis("x").model,axisIndex:0},// x
{axisModel:grid.getAxis("y").model,axisIndex:0}];return coordInfo.grid=grid,ecModel.eachComponent({mainType:"dataZoom",subType:"select"},function(dzModel,dataZoomIndex){isTheAxis("xAxis",coordInfo[0].axisModel,dzModel,ecModel)&&(coordInfo[0].dataZoomModel=dzModel),isTheAxis("yAxis",coordInfo[1].axisModel,dzModel,ecModel)&&(coordInfo[1].dataZoomModel=dzModel)}),coordInfo}function isTheAxis(axisName,axisModel,dataZoomModel,ecModel){var axisIndex=dataZoomModel.get(axisName+"Index");return null!=axisIndex&&ecModel.getComponent(axisName,axisIndex)===axisModel}function pointToDataInCartesian(selRange,coordInfo){var grid=coordInfo.grid,selRect=new BoundingRect(selRange[0][0],selRange[1][0],selRange[0][1]-selRange[0][0],selRange[1][1]-selRange[1][0]);if(selRect.intersect(grid.getRect())){var cartesian=grid.getCartesian(coordInfo[0].axisIndex,coordInfo[1].axisIndex),dataLeftTop=cartesian.pointToData([selRange[0][0],selRange[1][0]],!0),dataRightBottom=cartesian.pointToData([selRange[0][1],selRange[1][1]],!0);return[asc([dataLeftTop[0],dataRightBottom[0]]),// x, using asc to handle inverse
asc([dataLeftTop[1],dataRightBottom[1]])]}}function scaleCartesianAxis(selDataRange,coordInfo,dimIdx,dimName){var dimCoordInfo=coordInfo[dimIdx],dataZoomModel=dimCoordInfo.dataZoomModel;return dataZoomModel?{dataZoomId:dataZoomModel.id,startValue:selDataRange[dimIdx][0],endValue:selDataRange[dimIdx][1]}:void 0}function updateBackBtnStatus(featureModel,ecModel){featureModel.setIconStatus("back",history.count(ecModel)>1?"emphasis":"normal")}var zrUtil=__webpack_require__(3),numberUtil=__webpack_require__(7),SelectController=__webpack_require__(225),BoundingRect=__webpack_require__(15),Group=__webpack_require__(29),history=__webpack_require__(340),interactionMutex=__webpack_require__(160),each=zrUtil.each,asc=numberUtil.asc;
// Use dataZoomSelect
__webpack_require__(341);
// Spectial component id start with \0ec\0, see echarts/model/Global.js~hasInnerId
var DATA_ZOOM_ID_BASE="\x00_ec_\x00toolbox-dataZoom_";DataZoom.defaultOption={show:!0,
// Icon group
icon:{zoom:"M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",back:"M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"},title:{zoom:"区域缩放",back:"区域缩放还原"}};var proto=DataZoom.prototype;proto.render=function(featureModel,ecModel,api){updateBackBtnStatus(featureModel,ecModel)},proto.onclick=function(ecModel,api,type){var controllerGroup=this._controllerGroup;this._controllerGroup||(controllerGroup=this._controllerGroup=new Group,api.getZr().add(controllerGroup)),handlers[type].call(this,controllerGroup,this.model,ecModel,api)},proto.remove=function(ecModel,api){this._disposeController(),interactionMutex.release("globalPan",api.getZr())},proto.dispose=function(ecModel,api){var zr=api.getZr();interactionMutex.release("globalPan",zr),this._disposeController(),this._controllerGroup&&zr.remove(this._controllerGroup)};/**
	     * @private
	     */
var handlers={zoom:function(controllerGroup,featureModel,ecModel,api){var isZoomActive=this._isZoomActive=!this._isZoomActive,zr=api.getZr();interactionMutex[isZoomActive?"take":"release"]("globalPan",zr),featureModel.setIconStatus("zoom",isZoomActive?"emphasis":"normal"),isZoomActive?(zr.setDefaultCursorStyle("crosshair"),this._createController(controllerGroup,featureModel,ecModel,api)):(zr.setDefaultCursorStyle("default"),this._disposeController())},back:function(controllerGroup,featureModel,ecModel,api){this._dispatchAction(history.pop(ecModel),api)}};/**
	     * @private
	     */
proto._createController=function(controllerGroup,featureModel,ecModel,api){var controller=this._controller=new SelectController("rect",api.getZr(),{
// FIXME
lineWidth:3,stroke:"#333",fill:"rgba(0,0,0,0.2)"});controller.on("selectEnd",zrUtil.bind(this._onSelected,this,controller,featureModel,ecModel,api)),controller.enable(controllerGroup,!1)},proto._disposeController=function(){var controller=this._controller;controller&&(controller.off("selected"),controller.dispose())},/**
	     * @private
	     */
proto._onSelected=function(controller,featureModel,ecModel,api,selRanges){if(selRanges.length){var selRange=selRanges[0];controller.update();// remove cover
var snapshot={};
// FIXME
// polar
ecModel.eachComponent("grid",function(gridModel,gridIndex){var grid=gridModel.coordinateSystem,coordInfo=prepareCoordInfo(grid,ecModel),selDataRange=pointToDataInCartesian(selRange,coordInfo);if(selDataRange){var xBatchItem=scaleCartesianAxis(selDataRange,coordInfo,0,"x"),yBatchItem=scaleCartesianAxis(selDataRange,coordInfo,1,"y");xBatchItem&&(snapshot[xBatchItem.dataZoomId]=xBatchItem),yBatchItem&&(snapshot[yBatchItem.dataZoomId]=yBatchItem)}},this),history.push(ecModel,snapshot),this._dispatchAction(snapshot,api)}},/**
	     * @private
	     */
proto._dispatchAction=function(snapshot,api){var batch=[];each(snapshot,function(batchItem){batch.push(batchItem)}),batch.length&&api.dispatchAction({type:"dataZoom",from:this.uid,batch:zrUtil.clone(batch,!0)})},__webpack_require__(333).register("dataZoom",DataZoom),
// Create special dataZoom option for select
__webpack_require__(1).registerPreprocessor(function(option){function addForAxis(axisName,dataZoomOpt){if(dataZoomOpt){var axisIndicesName=axisName+"Index",givenAxisIndices=dataZoomOpt[axisIndicesName];null==givenAxisIndices||zrUtil.isArray(givenAxisIndices)||(givenAxisIndices=givenAxisIndices===!1?[]:[givenAxisIndices]),forEachComponent(axisName,function(axisOpt,axisIndex){if(null==givenAxisIndices||-1!==zrUtil.indexOf(givenAxisIndices,axisIndex)){var newOpt={type:"select",$fromToolbox:!0,
// Id for merge mapping.
id:DATA_ZOOM_ID_BASE+axisName+axisIndex};
// FIXME
// Only support one axis now.
newOpt[axisIndicesName]=axisIndex,dataZoomOpts.push(newOpt)}})}}function forEachComponent(mainType,cb){var opts=option[mainType];zrUtil.isArray(opts)||(opts=opts?[opts]:[]),each(opts,cb)}if(option){var dataZoomOpts=option.dataZoom||(option.dataZoom=[]);zrUtil.isArray(dataZoomOpts)||(dataZoomOpts=[dataZoomOpts]);var toolboxOpt=option.toolbox;if(toolboxOpt&&(
// Assume there is only one toolbox
zrUtil.isArray(toolboxOpt)&&(toolboxOpt=toolboxOpt[0]),toolboxOpt&&toolboxOpt.feature)){var dataZoomOpt=toolboxOpt.feature.dataZoom;addForAxis("xAxis",dataZoomOpt),addForAxis("yAxis",dataZoomOpt)}}}),module.exports=DataZoom},/* 340 */
/***/
function(module,exports,__webpack_require__){/**
	     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]
	     * History length of each dataZoom may be different.
	     * this._history[0] is used to store origin range.
	     * @type {Array.<Object>}
	     */
function giveStore(ecModel){var store=ecModel[ATTR];return store||(store=ecModel[ATTR]=[{}]),store}/**
	 * @file History manager.
	 */
var zrUtil=__webpack_require__(3),each=zrUtil.each,ATTR="\x00_ec_hist_store",history={/**
	         * @public
	         * @param {module:echarts/model/Global} ecModel
	         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}
	         */
push:function(ecModel,newSnapshot){var store=giveStore(ecModel);
// If previous dataZoom can not be found,
// complete an range with current range.
each(newSnapshot,function(batchItem,dataZoomId){for(var i=store.length-1;i>=0;i--){var snapshot=store[i];if(snapshot[dataZoomId])break}if(0>i){
// No origin range set, create one by current range.
var dataZoomModel=ecModel.queryComponents({mainType:"dataZoom",subType:"select",id:dataZoomId})[0];if(dataZoomModel){var percentRange=dataZoomModel.getPercentRange();store[0][dataZoomId]={dataZoomId:dataZoomId,start:percentRange[0],end:percentRange[1]}}}}),store.push(newSnapshot)},/**
	         * @public
	         * @param {module:echarts/model/Global} ecModel
	         * @return {Object} snapshot
	         */
pop:function(ecModel){var store=giveStore(ecModel),head=store[store.length-1];store.length>1&&store.pop();
// Find top for all dataZoom.
var snapshot={};return each(head,function(batchItem,dataZoomId){for(var i=store.length-1;i>=0;i--){var batchItem=store[i][dataZoomId];if(batchItem){snapshot[dataZoomId]=batchItem;break}}}),snapshot},/**
	         * @public
	         */
clear:function(ecModel){ecModel[ATTR]=null},/**
	         * @public
	         * @param {module:echarts/model/Global} ecModel
	         * @return {number} records. always >= 1.
	         */
count:function(ecModel){return giveStore(ecModel).length}};module.exports=history},/* 341 */
/***/
function(module,exports,__webpack_require__){/**
	 * DataZoom component entry
	 */
__webpack_require__(287),__webpack_require__(288),__webpack_require__(290),__webpack_require__(342),__webpack_require__(343),__webpack_require__(298),__webpack_require__(299)},/* 342 */
/***/
function(module,exports,__webpack_require__){/**
	 * @file Data zoom model
	 */
var DataZoomModel=__webpack_require__(288);module.exports=DataZoomModel.extend({type:"dataZoom.select"})},/* 343 */
/***/
function(module,exports,__webpack_require__){module.exports=__webpack_require__(290).extend({type:"dataZoom.select"})},/* 344 */
/***/
function(module,exports,__webpack_require__){"use strict";function Restore(model){this.model=model}var history=__webpack_require__(340);Restore.defaultOption={show:!0,icon:"M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",title:"还原"};var proto=Restore.prototype;proto.onclick=function(ecModel,api,type){history.clear(ecModel),api.dispatchAction({type:"restore",from:this.uid})},__webpack_require__(333).register("restore",Restore),__webpack_require__(1).registerAction({type:"restore",event:"restore",update:"prepareAndUpdate"},function(payload,ecModel){ecModel.resetOption("recreate")}),module.exports=Restore},/* 345 */
/***/
function(module,exports,__webpack_require__){__webpack_require__(346),__webpack_require__(77).registerPainter("vml",__webpack_require__(348))},/* 346 */
/***/
function(module,exports,__webpack_require__){
// http://www.w3.org/TR/NOTE-VML
// TODO Use proxy like svg instead of overwrite brush methods
if(!__webpack_require__(78).canvasSupported){var vec2=__webpack_require__(16),BoundingRect=__webpack_require__(15),CMD=__webpack_require__(48).CMD,colorTool=__webpack_require__(38),textContain=__webpack_require__(14),RectText=__webpack_require__(47),Displayable=__webpack_require__(45),ZImage=__webpack_require__(59),Text=__webpack_require__(62),Path=__webpack_require__(44),Gradient=__webpack_require__(4),vmlCore=__webpack_require__(347),round=Math.round,sqrt=Math.sqrt,abs=Math.abs,cos=Math.cos,sin=Math.sin,mathMax=Math.max,applyTransform=vec2.applyTransform,comma=",",imageTransformPrefix="progid:DXImageTransform.Microsoft",Z=21600,Z2=Z/2,ZLEVEL_BASE=1e5,Z_BASE=1e3,initRootElStyle=function(el){el.style.cssText="position:absolute;left:0;top:0;width:1px;height:1px;",el.coordsize=Z+","+Z,el.coordorigin="0,0"},encodeHtmlAttribute=function(s){return String(s).replace(/&/g,"&amp;").replace(/"/g,"&quot;")},rgb2Str=function(r,g,b){return"rgb("+[r,g,b].join(",")+")"},append=function(parent,child){child&&parent&&child.parentNode!==parent&&parent.appendChild(child)},remove=function(parent,child){child&&parent&&child.parentNode===parent&&parent.removeChild(child)},getZIndex=function(zlevel,z,z2){
// z 的取值范围为 [0, 1000]
return(parseFloat(zlevel)||0)*ZLEVEL_BASE+(parseFloat(z)||0)*Z_BASE+z2},parsePercent=function(value,maxValue){return"string"==typeof value?value.lastIndexOf("%")>=0?parseFloat(value)/100*maxValue:parseFloat(value):value},setColorAndOpacity=function(el,color,opacity){var colorArr=colorTool.parse(color);opacity=+opacity,isNaN(opacity)&&(opacity=1),colorArr&&(el.color=rgb2Str(colorArr[0],colorArr[1],colorArr[2]),el.opacity=opacity*colorArr[3])},getColorAndAlpha=function(color){var colorArr=colorTool.parse(color);return[rgb2Str(colorArr[0],colorArr[1],colorArr[2]),colorArr[3]]},updateFillNode=function(el,style,zrEl){
// TODO pattern
var fill=style.fill;if(null!=fill)
// Modified from excanvas
if(fill instanceof Gradient){var gradientType,angle=0,focus=[0,0],shift=0,expansion=1,rect=zrEl.getBoundingRect(),rectWidth=rect.width,rectHeight=rect.height;if("linear"===fill.type){gradientType="gradient";var transform=zrEl.transform,p0=[fill.x*rectWidth,fill.y*rectHeight],p1=[fill.x2*rectWidth,fill.y2*rectHeight];transform&&(applyTransform(p0,p0,transform),applyTransform(p1,p1,transform));var dx=p1[0]-p0[0],dy=p1[1]-p0[1];angle=180*Math.atan2(dx,dy)/Math.PI,
// The angle should be a non-negative number.
0>angle&&(angle+=360),
// Very small angles produce an unexpected result because they are
// converted to a scientific notation string.
1e-6>angle&&(angle=0)}else{gradientType="gradientradial";var p0=[fill.x*rectWidth,fill.y*rectHeight],transform=zrEl.transform,scale=zrEl.scale,width=rectWidth,height=rectHeight;focus=[
// Percent in bounding rect
(p0[0]-rect.x)/width,(p0[1]-rect.y)/height],transform&&applyTransform(p0,p0,transform),width/=scale[0]*Z,height/=scale[1]*Z;var dimension=mathMax(width,height);shift=0/dimension,expansion=2*fill.r/dimension-shift}
// We need to sort the color stops in ascending order by offset,
// otherwise IE won't interpret it correctly.
var stops=fill.colorStops.slice();stops.sort(function(cs1,cs2){return cs1.offset-cs2.offset});for(var length=stops.length,colorAndAlphaList=[],colors=[],i=0;length>i;i++){var stop=stops[i],colorAndAlpha=getColorAndAlpha(stop.color);colors.push(stop.offset*expansion+shift+" "+colorAndAlpha[0]),0!==i&&i!==length-1||colorAndAlphaList.push(colorAndAlpha)}if(length>=2){var color1=colorAndAlphaList[0][0],color2=colorAndAlphaList[1][0],opacity1=colorAndAlphaList[0][1]*style.opacity,opacity2=colorAndAlphaList[1][1]*style.opacity;el.type=gradientType,el.method="none",el.focus="100%",el.angle=angle,el.color=color1,el.color2=color2,el.colors=colors.join(","),
// When colors attribute is used, the meanings of opacity and o:opacity2
// are reversed.
el.opacity=opacity2,
// FIXME g_o_:opacity ?
el.opacity2=opacity1}"radial"===gradientType&&(el.focusposition=focus.join(","))}else
// FIXME Change from Gradient fill to color fill
setColorAndOpacity(el,fill,style.opacity)},updateStrokeNode=function(el,style){null!=style.lineJoin&&(el.joinstyle=style.lineJoin),null!=style.miterLimit&&(el.miterlimit=style.miterLimit*Z),null!=style.lineCap&&(el.endcap=style.lineCap),null!=style.lineDash&&(el.dashstyle=style.lineDash.join(" ")),null==style.stroke||style.stroke instanceof Gradient||setColorAndOpacity(el,style.stroke,style.opacity)},updateFillAndStroke=function(vmlEl,type,style,zrEl){var isFill="fill"==type,el=vmlEl.getElementsByTagName(type)[0];
// Stroke must have lineWidth
null!=style[type]&&"none"!==style[type]&&(isFill||!isFill&&style.lineWidth)?(vmlEl[isFill?"filled":"stroked"]="true",
// FIXME Remove before updating, or set `colors` will throw error
style[type]instanceof Gradient&&remove(vmlEl,el),el||(el=vmlCore.createNode(type)),isFill?updateFillNode(el,style,zrEl):updateStrokeNode(el,style),append(vmlEl,el)):(vmlEl[isFill?"filled":"stroked"]="false",remove(vmlEl,el))},points=[[],[],[]],pathDataToString=function(data,m){var nPoint,cmdStr,cmd,i,xi,yi,M=CMD.M,C=CMD.C,L=CMD.L,A=CMD.A,Q=CMD.Q,str=[];for(i=0;i<data.length;){switch(cmd=data[i++],cmdStr="",nPoint=0,cmd){case M:cmdStr=" m ",nPoint=1,xi=data[i++],yi=data[i++],points[0][0]=xi,points[0][1]=yi;break;case L:cmdStr=" l ",nPoint=1,xi=data[i++],yi=data[i++],points[0][0]=xi,points[0][1]=yi;break;case Q:case C:cmdStr=" c ",nPoint=3;var x3,y3,x1=data[i++],y1=data[i++],x2=data[i++],y2=data[i++];cmd===Q?(x3=x2,y3=y2,x2=(x2+2*x1)/3,y2=(y2+2*y1)/3,x1=(xi+2*x1)/3,y1=(yi+2*y1)/3):(x3=data[i++],y3=data[i++]),points[0][0]=x1,points[0][1]=y1,points[1][0]=x2,points[1][1]=y2,points[2][0]=x3,points[2][1]=y3,xi=x3,yi=y3;break;case A:var x=0,y=0,sx=1,sy=1,angle=0;m&&(x=m[4],y=m[5],sx=sqrt(m[0]*m[0]+m[1]*m[1]),sy=sqrt(m[2]*m[2]+m[3]*m[3]),angle=Math.atan2(-m[1]/sy,m[0]/sx));var cx=data[i++],cy=data[i++],rx=data[i++],ry=data[i++],startAngle=data[i++]+angle,endAngle=data[i++]+startAngle+angle;
// FIXME
// var psi = data[i++];
i++;var clockwise=data[i++],x0=cx+cos(startAngle)*rx,y0=cy+sin(startAngle)*ry,x1=cx+cos(endAngle)*rx,y1=cy+sin(endAngle)*ry,type=clockwise?" wa ":" at ";
// IE won't render arches drawn counter clockwise if x0 == x1.
Math.abs(x0-x1)<1e-10&&clockwise&&(
// Offset x0 by 1/80 of a pixel. Use something
// that can be represented in binary
x0+=270/Z),str.push(type,round(((cx-rx)*sx+x)*Z-Z2),comma,round(((cy-ry)*sy+y)*Z-Z2),comma,round(((cx+rx)*sx+x)*Z-Z2),comma,round(((cy+ry)*sy+y)*Z-Z2),comma,round((x0*sx+x)*Z-Z2),comma,round((y0*sy+y)*Z-Z2),comma,round((x1*sx+x)*Z-Z2),comma,round((y1*sy+y)*Z-Z2)),xi=x1,yi=y1;break;case CMD.R:var p0=points[0],p1=points[1];
// x0, y0
p0[0]=data[i++],p0[1]=data[i++],
// x1, y1
p1[0]=p0[0]+data[i++],p1[1]=p0[1]+data[i++],m&&(applyTransform(p0,p0,m),applyTransform(p1,p1,m)),p0[0]=round(p0[0]*Z-Z2),p1[0]=round(p1[0]*Z-Z2),p0[1]=round(p0[1]*Z-Z2),p1[1]=round(p1[1]*Z-Z2),str.push(
// x0, y0
" m ",p0[0],comma,p0[1],
// x1, y0
" l ",p1[0],comma,p0[1],
// x1, y1
" l ",p1[0],comma,p1[1],
// x0, y1
" l ",p0[0],comma,p1[1]);break;case CMD.Z:
// FIXME Update xi, yi
str.push(" x ")}if(nPoint>0){str.push(cmdStr);for(var k=0;nPoint>k;k++){var p=points[k];m&&applyTransform(p,p,m),
// 不 round 会非常慢
str.push(round(p[0]*Z-Z2),comma,round(p[1]*Z-Z2),nPoint-1>k?comma:"")}}}return str.join("")};
// Rewrite the original path method
Path.prototype.brushVML=function(vmlRoot){var style=this.style,vmlEl=this._vmlEl;vmlEl||(vmlEl=vmlCore.createNode("shape"),initRootElStyle(vmlEl),this._vmlEl=vmlEl),updateFillAndStroke(vmlEl,"fill",style,this),updateFillAndStroke(vmlEl,"stroke",style,this);var m=this.transform,needTransform=null!=m,strokeEl=vmlEl.getElementsByTagName("stroke")[0];if(strokeEl){var lineWidth=style.lineWidth;
// Get the line scale.
// Determinant of this.m_ means how much the area is enlarged by the
// transformation. So its square root can be used as a scale factor
// for width.
if(needTransform&&!style.strokeNoScale){var det=m[0]*m[3]-m[1]*m[2];lineWidth*=sqrt(abs(det))}strokeEl.weight=lineWidth+"px"}var path=this.path;this.__dirtyPath&&(path.beginPath(),this.buildPath(path,this.shape),path.toStatic(),this.__dirtyPath=!1),vmlEl.path=pathDataToString(path.data,this.transform),vmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2),
// Append to root
append(vmlRoot,vmlEl),
// Text
style.text&&this.drawRectText(vmlRoot,this.getBoundingRect())},Path.prototype.onRemove=function(vmlRoot){remove(vmlRoot,this._vmlEl),this.removeRectText(vmlRoot)},Path.prototype.onAdd=function(vmlRoot){append(vmlRoot,this._vmlEl),this.appendRectText(vmlRoot)};/***************************************************
	     * IMAGE
	     **************************************************/
var isImage=function(img){
// FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
return"object"==typeof img&&img.tagName&&"IMG"===img.tagName.toUpperCase()};
// Rewrite the original path method
ZImage.prototype.brushVML=function(vmlRoot){var ow,oh,style=this.style,image=style.image;if(isImage(image)){var src=image.src;if(src===this._imageSrc)ow=this._imageWidth,oh=this._imageHeight;else{var imageRuntimeStyle=image.runtimeStyle,oldRuntimeWidth=imageRuntimeStyle.width,oldRuntimeHeight=imageRuntimeStyle.height;imageRuntimeStyle.width="auto",imageRuntimeStyle.height="auto",
// get the original size
ow=image.width,oh=image.height,
// and remove overides
imageRuntimeStyle.width=oldRuntimeWidth,imageRuntimeStyle.height=oldRuntimeHeight,
// Caching image original width, height and src
this._imageSrc=src,this._imageWidth=ow,this._imageHeight=oh}image=src}else image===this._imageSrc&&(ow=this._imageWidth,oh=this._imageHeight);if(image){var x=style.x||0,y=style.y||0,dw=style.width,dh=style.height,sw=style.sWidth,sh=style.sHeight,sx=style.sx||0,sy=style.sy||0,hasCrop=sw&&sh,vmlEl=this._vmlEl;vmlEl||(vmlEl=vmlCore.doc.createElement("div"),initRootElStyle(vmlEl),this._vmlEl=vmlEl);var m,vmlElStyle=vmlEl.style,hasRotation=!1,scaleX=1,scaleY=1;if(this.transform&&(m=this.transform,scaleX=sqrt(m[0]*m[0]+m[1]*m[1]),scaleY=sqrt(m[2]*m[2]+m[3]*m[3]),hasRotation=m[1]||m[2]),hasRotation){
// If filters are necessary (rotation exists), create them
// filters are bog-slow, so only create them if abbsolutely necessary
// The following check doesn't account for skews (which don't exist
// in the canvas spec (yet) anyway.
// From excanvas
var p0=[x,y],p1=[x+dw,y],p2=[x,y+dh],p3=[x+dw,y+dh];applyTransform(p0,p0,m),applyTransform(p1,p1,m),applyTransform(p2,p2,m),applyTransform(p3,p3,m);var maxX=mathMax(p0[0],p1[0],p2[0],p3[0]),maxY=mathMax(p0[1],p1[1],p2[1],p3[1]),transformFilter=[];transformFilter.push("M11=",m[0]/scaleX,comma,"M12=",m[2]/scaleY,comma,"M21=",m[1]/scaleX,comma,"M22=",m[3]/scaleY,comma,"Dx=",round(x*scaleX+m[4]),comma,"Dy=",round(y*scaleY+m[5])),vmlElStyle.padding="0 "+round(maxX)+"px "+round(maxY)+"px 0",
// FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
vmlElStyle.filter=imageTransformPrefix+".Matrix("+transformFilter.join("")+", SizingMethod=clip)"}else m&&(x=x*scaleX+m[4],y=y*scaleY+m[5]),vmlElStyle.filter="",vmlElStyle.left=round(x)+"px",vmlElStyle.top=round(y)+"px";var imageEl=this._imageEl,cropEl=this._cropEl;imageEl||(imageEl=vmlCore.doc.createElement("div"),this._imageEl=imageEl);var imageELStyle=imageEl.style;if(hasCrop){
// Needs know image original width and height
if(ow&&oh)imageELStyle.width=round(scaleX*ow*dw/sw)+"px",imageELStyle.height=round(scaleY*oh*dh/sh)+"px";else{var tmpImage=new Image,self=this;tmpImage.onload=function(){tmpImage.onload=null,ow=tmpImage.width,oh=tmpImage.height,imageELStyle.width=round(scaleX*ow*dw/sw)+"px",imageELStyle.height=round(scaleY*oh*dh/sh)+"px",self._imageWidth=ow,self._imageHeight=oh,self._imageSrc=image},tmpImage.src=image}cropEl||(cropEl=vmlCore.doc.createElement("div"),cropEl.style.overflow="hidden",this._cropEl=cropEl);var cropElStyle=cropEl.style;cropElStyle.width=round((dw+sx*dw/sw)*scaleX),cropElStyle.height=round((dh+sy*dh/sh)*scaleY),cropElStyle.filter=imageTransformPrefix+".Matrix(Dx="+-sx*dw/sw*scaleX+",Dy="+-sy*dh/sh*scaleY+")",cropEl.parentNode||vmlEl.appendChild(cropEl),imageEl.parentNode!=cropEl&&cropEl.appendChild(imageEl)}else imageELStyle.width=round(scaleX*dw)+"px",imageELStyle.height=round(scaleY*dh)+"px",vmlEl.appendChild(imageEl),cropEl&&cropEl.parentNode&&(vmlEl.removeChild(cropEl),this._cropEl=null);var filterStr="",alpha=style.opacity;1>alpha&&(filterStr+=".Alpha(opacity="+round(100*alpha)+") "),filterStr+=imageTransformPrefix+".AlphaImageLoader(src="+image+", SizingMethod=scale)",imageELStyle.filter=filterStr,vmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2),
// Append to root
append(vmlRoot,vmlEl),
// Text
style.text&&this.drawRectText(vmlRoot,this.getBoundingRect())}},ZImage.prototype.onRemove=function(vmlRoot){remove(vmlRoot,this._vmlEl),this._vmlEl=null,this._cropEl=null,this._imageEl=null,this.removeRectText(vmlRoot)},ZImage.prototype.onAdd=function(vmlRoot){append(vmlRoot,this._vmlEl),this.appendRectText(vmlRoot)};/***************************************************
	     * TEXT
	     **************************************************/
var textMeasureEl,DEFAULT_STYLE_NORMAL="normal",fontStyleCache={},fontStyleCacheCount=0,MAX_FONT_CACHE_SIZE=100,fontEl=document.createElement("div"),getFontStyle=function(fontString){var fontStyle=fontStyleCache[fontString];if(!fontStyle){
// Clear cache
fontStyleCacheCount>MAX_FONT_CACHE_SIZE&&(fontStyleCacheCount=0,fontStyleCache={});var fontFamily,style=fontEl.style;try{style.font=fontString,fontFamily=style.fontFamily.split(",")[0]}catch(e){}fontStyle={style:style.fontStyle||DEFAULT_STYLE_NORMAL,variant:style.fontVariant||DEFAULT_STYLE_NORMAL,weight:style.fontWeight||DEFAULT_STYLE_NORMAL,size:0|parseFloat(style.fontSize||12),family:fontFamily||"Microsoft YaHei"},fontStyleCache[fontString]=fontStyle,fontStyleCacheCount++}return fontStyle};
// Overwrite measure text method
textContain.measureText=function(text,textFont){var doc=vmlCore.doc;textMeasureEl||(textMeasureEl=doc.createElement("div"),textMeasureEl.style.cssText="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;",vmlCore.doc.body.appendChild(textMeasureEl));try{textMeasureEl.style.font=textFont}catch(ex){}
// Don't use innerHTML or innerText because they allow markup/whitespace.
return textMeasureEl.innerHTML="",textMeasureEl.appendChild(doc.createTextNode(text)),{width:textMeasureEl.offsetWidth}};
// In case Displayable has been mixed in RectText
for(var tmpRect=new BoundingRect,drawRectText=function(vmlRoot,rect,textRect,fromTextEl){var style=this.style,text=style.text;if(text){var x,y,align=style.textAlign,fontStyle=getFontStyle(style.textFont),font=fontStyle.style+" "+fontStyle.variant+" "+fontStyle.weight+" "+fontStyle.size+'px "'+fontStyle.family+'"',baseline=style.textBaseline,verticalAlign=style.textVerticalAlign;textRect=textRect||textContain.getBoundingRect(text,font,align,baseline);
// Transform rect to view space
var m=this.transform;if(
// Ignore transform for text in other element
m&&!fromTextEl&&(tmpRect.copy(rect),tmpRect.applyTransform(m),rect=tmpRect),fromTextEl)x=rect.x,y=rect.y;else{var textPosition=style.textPosition,distance=style.textDistance;
// Text position represented by coord
if(textPosition instanceof Array)x=rect.x+parsePercent(textPosition[0],rect.width),y=rect.y+parsePercent(textPosition[1],rect.height),align=align||"left",baseline=baseline||"top";else{var res=textContain.adjustTextPositionOnRect(textPosition,rect,textRect,distance);x=res.x,y=res.y,
// Default align and baseline when has textPosition
align=align||res.textAlign,baseline=baseline||res.textBaseline}}if(verticalAlign){switch(verticalAlign){case"middle":y-=textRect.height/2;break;case"bottom":y-=textRect.height}
// Ignore baseline
baseline="top"}var fontSize=fontStyle.size;
// 1.75 is an arbitrary number, as there is no info about the text baseline
switch(baseline){case"hanging":case"top":y+=fontSize/1.75;break;case"middle":break;default:
// case null:
// case 'alphabetic':
// case 'ideographic':
// case 'bottom':
y-=fontSize/2.25}switch(align){case"left":break;case"center":x-=textRect.width/2;break;case"right":x-=textRect.width}var pathEl,textPathEl,skewEl,createNode=vmlCore.createNode,textVmlEl=this._textVmlEl;textVmlEl?(skewEl=textVmlEl.firstChild,pathEl=skewEl.nextSibling,textPathEl=pathEl.nextSibling):(textVmlEl=createNode("line"),pathEl=createNode("path"),textPathEl=createNode("textpath"),skewEl=createNode("skew"),textPathEl.style["v-text-align"]="left",initRootElStyle(textVmlEl),pathEl.textpathok=!0,textPathEl.on=!0,textVmlEl.from="0 0",textVmlEl.to="1000 0.05",append(textVmlEl,skewEl),append(textVmlEl,pathEl),append(textVmlEl,textPathEl),this._textVmlEl=textVmlEl);var coords=[x,y],textVmlElStyle=textVmlEl.style;
// Ignore transform for text in other element
m&&fromTextEl?(applyTransform(coords,coords,m),skewEl.on=!0,skewEl.matrix=m[0].toFixed(3)+comma+m[2].toFixed(3)+comma+m[1].toFixed(3)+comma+m[3].toFixed(3)+",0,0",
// Text position
skewEl.offset=(round(coords[0])||0)+","+(round(coords[1])||0),
// Left top point as origin
skewEl.origin="0 0",textVmlElStyle.left="0px",textVmlElStyle.top="0px"):(skewEl.on=!1,textVmlElStyle.left=round(x)+"px",textVmlElStyle.top=round(y)+"px"),textPathEl.string=encodeHtmlAttribute(text);
// TODO
try{textPathEl.style.font=font}
// Error font format
catch(e){}updateFillAndStroke(textVmlEl,"fill",{fill:fromTextEl?style.fill:style.textFill,opacity:style.opacity},this),updateFillAndStroke(textVmlEl,"stroke",{stroke:fromTextEl?style.stroke:style.textStroke,opacity:style.opacity,lineDash:style.lineDash},this),textVmlEl.style.zIndex=getZIndex(this.zlevel,this.z,this.z2),
// Attached to root
append(vmlRoot,textVmlEl)}},removeRectText=function(vmlRoot){remove(vmlRoot,this._textVmlEl),this._textVmlEl=null},appendRectText=function(vmlRoot){append(vmlRoot,this._textVmlEl)},list=[RectText,Displayable,ZImage,Path,Text],i=0;i<list.length;i++){var proto=list[i].prototype;proto.drawRectText=drawRectText,proto.removeRectText=removeRectText,proto.appendRectText=appendRectText}Text.prototype.brushVML=function(root){var style=this.style;style.text&&this.drawRectText(root,{x:style.x||0,y:style.y||0,width:0,height:0},this.getBoundingRect(),!0)},Text.prototype.onRemove=function(vmlRoot){this.removeRectText(vmlRoot)},Text.prototype.onAdd=function(vmlRoot){this.appendRectText(vmlRoot)}}},/* 347 */
/***/
function(module,exports,__webpack_require__){if(!__webpack_require__(78).canvasSupported){var createNode,urn="urn:schemas-microsoft-com:vml",win=window,doc=win.document,vmlInited=!1;try{!doc.namespaces.zrvml&&doc.namespaces.add("zrvml",urn),createNode=function(tagName){return doc.createElement("<zrvml:"+tagName+' class="zrvml">')}}catch(e){createNode=function(tagName){return doc.createElement("<"+tagName+' xmlns="'+urn+'" class="zrvml">')}}
// From raphael
var initVML=function(){if(!vmlInited){vmlInited=!0;var styleSheets=doc.styleSheets;styleSheets.length<31?doc.createStyleSheet().addRule(".zrvml","behavior:url(#default#VML)"):
// http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
styleSheets[0].addRule(".zrvml","behavior:url(#default#VML)")}};
// Not useing return to avoid error when converting to CommonJS module
module.exports={doc:doc,initVML:initVML,createNode:createNode}}},/* 348 */
/***/
function(module,exports,__webpack_require__){function parseInt10(val){return parseInt(val,10)}/**
	     * @alias module:zrender/vml/Painter
	     */
function VMLPainter(root,storage){vmlCore.initVML(),this.root=root,this.storage=storage;var vmlViewport=document.createElement("div"),vmlRoot=document.createElement("div");vmlViewport.style.cssText="display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;",vmlRoot.style.cssText="position:absolute;left:0;top:0;",root.appendChild(vmlViewport),this._vmlRoot=vmlRoot,this._vmlViewport=vmlViewport,this.resize();
// Modify storage
var oldDelFromMap=storage.delFromMap,oldAddToMap=storage.addToMap;storage.delFromMap=function(elId){var el=storage.get(elId);oldDelFromMap.call(storage,elId),el&&el.onRemove&&el.onRemove(vmlRoot)},storage.addToMap=function(el){
// Displayable already has a vml node
el.onAdd&&el.onAdd(vmlRoot),oldAddToMap.call(storage,el)},this._firstPaint=!0}
// Not supported methods
function createMethodNotSupport(method){return function(){zrLog('In IE8.0 VML mode painter not support method "'+method+'"')}}/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
var zrLog=__webpack_require__(39),vmlCore=__webpack_require__(347);VMLPainter.prototype={constructor:VMLPainter,/**
	         * @return {HTMLDivElement}
	         */
getViewportRoot:function(){return this._vmlViewport},/**
	         * 刷新
	         */
refresh:function(){var list=this.storage.getDisplayList(!0,!0);this._paintList(list)},_paintList:function(list){for(var vmlRoot=this._vmlRoot,i=0;i<list.length;i++){var el=list[i];el.invisible||el.ignore?(el.__alreadyNotVisible||el.onRemove(vmlRoot),
// Set as already invisible
el.__alreadyNotVisible=!0):(el.__alreadyNotVisible&&el.onAdd(vmlRoot),el.__alreadyNotVisible=!1,el.__dirty&&(el.beforeBrush&&el.beforeBrush(),(el.brushVML||el.brush).call(el,vmlRoot),el.afterBrush&&el.afterBrush())),el.__dirty=!1}this._firstPaint&&(
// Detached from document at first time
// to avoid page refreshing too many times
// FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
this._vmlViewport.appendChild(vmlRoot),this._firstPaint=!1)},resize:function(){var width=this._getWidth(),height=this._getHeight();if(this._width!=width&&this._height!=height){this._width=width,this._height=height;var vmlViewportStyle=this._vmlViewport.style;vmlViewportStyle.width=width+"px",vmlViewportStyle.height=height+"px"}},dispose:function(){this.root.innerHTML="",this._vmlRoot=this._vmlViewport=this.storage=null},getWidth:function(){return this._width},getHeight:function(){return this._height},_getWidth:function(){var root=this.root,stl=root.currentStyle;return(root.clientWidth||parseInt10(stl.width))-parseInt10(stl.paddingLeft)-parseInt10(stl.paddingRight)|0},_getHeight:function(){var root=this.root,stl=root.currentStyle;return(root.clientHeight||parseInt10(stl.height))-parseInt10(stl.paddingTop)-parseInt10(stl.paddingBottom)|0}};for(var notSupportedMethods=["getLayer","insertLayer","eachLayer","eachBuildinLayer","eachOtherLayer","getLayers","modLayer","delLayer","clearLayer","toDataURL","pathToImage"],i=0;i<notSupportedMethods.length;i++){var name=notSupportedMethods[i];VMLPainter.prototype[name]=createMethodNotSupport(name)}module.exports=VMLPainter}])});
/*! xybbGarten 最后修改于： 2016-06-21 */